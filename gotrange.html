<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Taco Basket Ball - Qu√©bec √âdition</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1066px;
            height: 600px;
            background: #000;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        canvas {
            border: 8px solid #5D4037;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
            border-radius: 4px;
            width: 100%;
            height: 100%;
            display: block;
            box-sizing: border-box;
        }

        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
            text-align: left;
        }

        #controls {
            position: absolute;
            bottom: 125px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: auto;
            z-index: 20;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .ui-btn {
            background: linear-gradient(to bottom, #FFD700, #DAA520);
            color: #000;
            border: 2px solid #fff;
            padding: 8px 18px;
            cursor: pointer;
            font-weight: 800;
            display: inline-block;
            border-radius: 6px;
            box-shadow: 0 4px 0 #B8860B;
            transition: transform 0.1s, background 0.1s;
            font-size: 16px;
            text-transform: uppercase;
            text-shadow: none;
        }
        .ui-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #B8860B; }
        .ui-btn:hover { background: #fff; }

        h1 {
            margin: 0;
            font-size: 42px;
            color: #FFD700;
            text-shadow: 3px 3px 0 #8B0000;
            font-weight: 900;
            font-style: italic;
        }
        p { margin: 5px 0; color: #fff; font-weight: bold; font-size: 1.2em; }
        .stat-label { color: #00FF00; }
        .highscore-label { color: #FFD700; }

        .modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 550px;
            max-height: 85%;
            overflow-y: auto;
            background: rgba(30, 30, 30, 0.98);
            border: 4px solid #DAA520;
            padding: 25px;
            color: white;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
            border-radius: 15px;
        }

        .modal::-webkit-scrollbar { width: 10px; }
        .modal::-webkit-scrollbar-track { background: #333; border-radius: 5px; }
        .modal::-webkit-scrollbar-thumb { background: #DAA520; border-radius: 5px; }

        .modal-header { color: #FFD700; margin-bottom: 20px; font-size: 2.2em; text-shadow: 2px 2px #d32f2f; font-weight: 800; border-bottom: 2px solid #555; padding-bottom: 10px; }

        .upgrade-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to right, rgba(255,255,255,0.05), rgba(255,255,255,0.1));
            margin: 10px 0;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .difficulty-row {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #FFD700;
            margin: 15px 0;
            padding: 15px;
            border-radius: 8px;
            text-align: left;
        }
        input[type=range] { width: 100%; margin: 15px 0; cursor: pointer; accent-color: #FFD700; }

        .ach-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0,0,0,0.5);
            border: 1px solid #555;
            margin: 8px 0;
            padding: 12px;
            border-radius: 8px;
            text-align: left;
            opacity: 0.7;
            transition: 0.3s;
        }
        .ach-row.unlocked {
            border-color: #00FF00;
            background: linear-gradient(to right, rgba(0, 100, 0, 0.4), rgba(0, 50, 0, 0.2));
            opacity: 1;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.1);
        }
        .ach-icon { font-size: 28px; margin-right: 15px; }
        .ach-info h4 { margin: 0; color: #aaa; font-size: 1.1em; }
        .ach-row.unlocked .ach-info h4 { color: #FFD700; }
        .ach-info span { font-size: 0.9em; color: #ccc; }

        .btn {
            background: linear-gradient(to bottom, #228B22, #006400);
            color: white;
            border: none;
            padding: 8px 20px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            border-radius: 4px;
            box-shadow: 0 3px 0 #004d00;
        }
        .btn:active { transform: translateY(3px); box-shadow: none; }
        .btn:disabled { background: #555; cursor: not-allowed; box-shadow: none; transform: none; color: #888; }
        .btn-close { background: #d32f2f; padding: 12px 30px; font-size: 1.2em; margin-top: 20px; width: 100%; box-shadow: 0 4px 0 #8B0000; }

        .skin-viewer {
            margin-top: 20px;
            border-top: 2px solid #555;
            padding-top: 15px;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 15px;
        }
        .skin-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 10px 0;
        }
        .selector-label { width: 180px; font-size: 1.2em; color: #FFD700; font-weight: bold; text-transform: uppercase; }

        #notification {
            position: absolute;
            bottom: 250px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(to right, #000, #333);
            border: 2px solid #FFD700;
            color: #FFD700;
            padding: 15px 40px;
            border-radius: 50px;
            font-size: 1.2em;
            font-weight: bold;
            display: none;
            z-index: 200;
            text-align: center;
            box-shadow: 0 0 25px #FFD700;
            animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popUp {
            from { bottom: 150px; opacity: 0; }
            to { bottom: 250px; opacity: 1; }
        }
        #courtNameDisplay {
            position: absolute;
            top: 60px;
            right: 20px;
            font-size: 1.5em;
            color: rgba(255,255,255,0.7);
            font-weight: 900;
            pointer-events: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            text-transform: uppercase;
            font-style: italic;
            text-align: right;
        }
        #strikes {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.5em;
            font-weight: bold;
            color: #FF4500;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }
        #contest-ui {
            display: none;
            position: absolute;
            top: 150px;
            left: 20px;
            font-size: 1.2em;
            color: #fff;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
        }

        /* Mobile Controls */
        .mobile-shoot-btn {
            position: fixed;
            right: 30px;
            bottom: 40%;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #FFA500, #FF4500);
            border: 4px solid #331a00;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            display: none;
            z-index: 9999;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            cursor: pointer;
            user-select: none;
        }
        .mobile-shoot-btn:active { transform: scale(0.95); box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .mobile-shoot-btn::before { /* Horizontal Line */
            content: ''; position: absolute; top: 48%; left: 0; width: 100%; height: 4%; background: #331a00; opacity: 0.8;
        }
        .mobile-shoot-btn::after { /* Vertical Line */
            content: ''; position: absolute; left: 48%; top: 0; height: 100%; width: 4%; background: #331a00; opacity: 0.8;
        }
        .mb-curve {
             position: absolute; top: 5%; bottom: 5%; left: 5%; right: 5%;
             border-radius: 50%; border: 4px solid #331a00; opacity: 0.8;
             clip-path: polygon(0 0, 25% 0, 25% 100%, 0 100%);
        }
        .mb-curve.right { transform: scaleX(-1); }

        #startup-ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            text-align: center;
        }
        .startup-btn {
            background: linear-gradient(to bottom, #FF8C00, #FF4500);
            border: 3px solid #FFF;
            color: white;
            font-size: 1.5em;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 900;
            text-shadow: 2px 2px 0 #000;
            box-shadow: 0 5px 0 #8B0000;
            transition: transform 0.1s;
        }
        .startup-btn:active { transform: translateY(5px); box-shadow: none; }
        .startup-btn:hover { background: #FFD700; color: #000; text-shadow: none; }

        #orientation-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 10000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }
        .rotate-icon {
            font-size: 5em;
            margin-bottom: 20px;
            animation: rotatePhone 2s infinite ease-in-out;
        }
        @keyframes rotatePhone {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
            100% { transform: rotate(0deg); }
        }

        #btn-force-fullscreen {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #FFD700;
            border-radius: 8px;
            color: #FFD700;
            font-size: 30px;
            display: none;
            z-index: 99999;
            cursor: pointer;
            justify-content: center;
            align-items: center;
            line-height: 50px;
            text-align: center;
        }
    </style>
</head>
<body>

<div id="btn-force-fullscreen" onclick="forceFullscreen()">‚õ∂</div>

<div id="orientation-overlay">
    <div class="rotate-icon">üì±</div>
    <h2>PIVOTEZ VOTRE APPAREIL</h2>
    <p>ROTATE YOUR DEVICE</p>
</div>

<div id="game-container">
    <div id="ui">
        <h1>TACO BASKET BALL</h1>
        <p>Tacos: <span id="scoreVal" class="stat-label">0</span></p>
        <div id="classic-stats">
            <p>Distance: <span id="distVal" class="stat-label">10 ft</span></p>
            <p>Record: <span id="highScoreVal" class="highscore-label">10 ft</span></p>
        </div>
    </div>
    <div id="strikes">MISS: <span id="missVal">0</span>/2</div>
    <div id="courtNameDisplay">COUR ARRI√àRE DE L√âVIS</div>
    <div id="contest-ui">
        <p style="color:#FFFF00; font-size:1.5em;">TEMPS: <span id="contestTime">60</span>s</p>
        <p>SCORE: <span id="contestScore" style="color:#00FF00">0</span></p>
        <p>STATION: <span id="contestRack">1</span>/5</p>
    </div>
    <div id="controls">
        <div class="ui-btn" onclick="toggleMode()">MODE: <span id="modeBtnText">CLASSIQUE</span></div>
        <div class="ui-btn" onclick="openShop()">BOUTIQUE [P]</div>
        <div class="ui-btn" onclick="openAchievements()">TROPH√âES [O]</div>
        <div class="ui-btn" onclick="openStats()">STATS [S]</div>
    </div>
    <div id="notification">
        <div>üèÜ SUCC√àS D√âBLOQU√â !</div>
        <div id="notifText" style="color:white; font-size:0.8em; margin-top:5px;">Rookie</div>
    </div>

    <div id="mobileShootBtn" class="mobile-shoot-btn">
        <div class="mb-curve"></div>
        <div class="mb-curve right"></div>
    </div>

    <div id="startup-ui">
        <h1 style="font-size: 4em; margin: 0; position: absolute; top: 10%; width: 100%;">TACO BASKET BALL</h1>
        <div style="position: absolute; bottom: 10%; width: 100%;">
            <h2 style="color: #FFD700; text-shadow: 2px 2px 0 #000; font-size: 2em; margin-bottom: 20px;">CHOISIS TA PLATEFORME</h2>
            <div>
                <button class="startup-btn" onclick="choosePlatform('desktop')">ORDI üíª</button>
                <button class="startup-btn" onclick="choosePlatform('mobile')">MOBILE üì±</button>
            </div>
        </div>
    </div>

    <!-- MODALS -->
    <div id="statsUI" class="modal">
        <div class="modal-header">STATISTIQUES √Ä VIE</div>
        <div style="text-align:left; padding: 10px; font-size: 1.2em;">
            <p style="overflow:hidden;">Tirs Totaux: <span id="statShots" style="color:#FFF; float:right">0</span></p>
            <p style="overflow:hidden;">Paniers: <span id="statMakes" style="color:#00FF00; float:right">0</span></p>
            <p style="overflow:hidden;">Rat√©s: <span id="statMisses" style="color:#FF0000; float:right">0</span></p>
            <p style="overflow:hidden;">Pr√©cision: <span id="statAccuracy" style="color:#FFD700; float:right">0%</span></p>
            <p style="overflow:hidden;">Concours Jou√©s: <span id="statContests" style="color:#00FFFF; float:right">0</span></p>
            <hr style="border-color:#555; margin:15px 0;">
            <p style="overflow:hidden;">Meilleure Distance: <span id="statBestDist" style="color:#FFD700; float:right">0 pi</span></p>
        </div>
        <button id="btnReset" class="btn" style="background: #8B0000; margin-top: 20px; width: 100%; border: 1px solid #ff4444;" onclick="attemptReset()">R√âINITIALISER PROGRESSION</button>
        <button id="btnUnlock" class="btn" style="background: #4B0082; margin-top: 10px; width: 100%; border: 1px solid #9370DB;" onclick="unlockAllSkins()">D√âBLOQUER TOUS LES SKINS</button>
        <button id="btnToggleMobile" class="btn" style="background: #006400; margin-top: 10px; width: 100%; border: 1px solid #00FF00;" onclick="toggleMobileControls()">TOUCH: OFF</button>
        <button id="btnToggleMeter" class="btn" style="background: #2F4F4F; margin-top: 10px; width: 100%; border: 1px solid #00CED1;" onclick="toggleMeter()">VIS√âE: OUI</button>
        <button id="btnCycleMeterShape" class="btn" style="background: #2F4F4F; margin-top: 10px; width: 100%; border: 1px solid #00CED1;" onclick="cycleMeterShape()">FORME: ARC</button>
        <button class="btn btn-close" onclick="closeStats()">FERMER</button>
    </div>

    <div id="shopUI" class="modal">
        <div class="modal-header">TACO MERCADO</div>
        <p>Tacos Disponibles: <span id="shopTacos" style="color:#FFFF00; font-size: 1.2em; font-weight: bold;">0</span></p>
        <div class="difficulty-row">
            <div style="display:flex; justify-content:space-between; margin-bottom:5px;"><strong>DIFFICULT√â</strong><span id="diffLabel" style="color:#00FF00; font-weight:bold;">NORMAL (x1.0)</span></div>
            <input type="range" id="diffSlider" min="1" max="3" step="0.5" value="1" oninput="updateDifficulty()">
            <div style="font-size:0.8em; color:#aaa;">Plus c'est dur, plus √ßa paye !</div>
        </div>
        <div class="upgrade-row"><div style="text-align:left;"><strong style="font-size:1.1em; color:#FFD700;">SIROP D'√âRABLE</strong> (Niv <span id="lvlIncome">1</span>)<br><span style="font-size:0.85em; color:#ccc;">R√©compense sucr√©e ! (Multiplicateur x0.5/niv)</span></div><div id="ctrl_income" class="upgrade-controls"></div></div>
        <div class="upgrade-row"><div style="text-align:left;"><strong style="font-size:1.1em; color:#FFD700;">VIS√âE ASSIST√âE</strong> (Niv <span id="lvlAim">1</span>)<br><span style="font-size:0.85em; color:#ccc;">Fen√™tre de tir plus large.</span></div><div id="ctrl_aim" class="upgrade-controls"></div></div>
        <div class="upgrade-row"><div style="text-align:left;"><strong style="font-size:1.1em; color:#FFD700;">TACO GREASE</strong> (Niv <span id="lvlLuck">1</span>)<br><span style="font-size:0.85em; color:#ccc;">Chance de rebond favorable.</span></div><div id="ctrl_luck" class="upgrade-controls"></div></div>
        <div class="upgrade-row"><div style="text-align:left;"><strong style="font-size:1.1em; color:#FFD700;">MOONWALK</strong> (Niv <span id="lvlMoonwalk">1</span>)<br><span style="font-size:0.85em; color:#ccc;">Recule plus vite apr√®s chaque panier !</span></div><div id="ctrl_moonwalk" class="upgrade-controls"></div></div>
        <div class="upgrade-row"><div style="text-align:left;"><strong style="font-size:1.1em; color:#FFD700;">SECONDE CHANCE</strong> (Niv <span id="lvlExtraLives">0</span>)<br><span style="font-size:0.85em; color:#ccc;">Tirs de plus avant Game Over.</span></div><div id="ctrl_extraLives" class="upgrade-controls"></div></div>
        <div class="skin-viewer">
            <h3 style="color:#aaa; border-bottom:1px solid #555; padding-bottom:5px;">VESTIAIRE</h3>
            <div class="skin-nav"><button class="btn" onclick="changeAnimal(-1)">&lt;</button><span id="animalName" class="selector-label">Rat</span><button class="btn" onclick="changeAnimal(1)">&gt;</button></div>
            <div class="skin-nav"><button class="btn" onclick="changeSkin(-1)">&lt;</button><span id="skinName" class="selector-label">Classic</span><button class="btn" onclick="changeSkin(1)">&gt;</button></div>
            <div id="skinStatus" style="margin-bottom:15px; color:#aaa; font-style:italic;">√âquip√©</div>
            <button id="btnEquipSkin" class="btn" style="width:100%; font-size: 1.1em;" onclick="buyOrEquipSkin()">√âquiper</button>

            <h3 style="color:#aaa; border-bottom:1px solid #555; padding-bottom:5px; margin-top:20px;">STYLE DE TIR</h3>
            <div class="skin-nav"><button class="btn" onclick="changeShootingStyle(-1)">&lt;</button><span id="styleName" class="selector-label">Classique</span><button class="btn" onclick="changeShootingStyle(1)">&gt;</button></div>
            <div id="styleDesc" style="font-size:0.9em; color:#ccc; margin-bottom:5px; height:40px;">Standard</div>
            <div id="styleStatus" style="margin-bottom:15px; color:#aaa; font-style:italic;">√âquip√©</div>
            <button id="btnEquipStyle" class="btn" style="width:100%; font-size: 1.1em;" onclick="buyOrEquipShootingStyle()">√âquiper</button>
            <button id="btnToggleHand" class="btn" style="width:100%; margin-top:10px; background:linear-gradient(to bottom, #444, #222); border:1px solid #666;" onclick="toggleHandedness()">MAIN: DROITIER</button>
        </div>
        <button class="btn btn-close" onclick="closeShop()">FERMER</button>
    </div>

    <div id="achUI" class="modal">
        <div class="modal-header">SALLE DES TROPH√âES</div>
        <div id="achList"></div>
        <button class="btn btn-close" onclick="closeAchievements()">FERMER</button>
    </div>

    <canvas id="gameCanvas"></canvas>
</div>

<script>
    // --- 1. DATA & CONSTANTS (DEFINED FIRST) ---
    var ACHIEVEMENTS = [
        { id: 'rookie', name: 'Recrue', desc: 'Premier panier marqu√©', reward: 10 },
        { id: 'veteran', name: 'V√©t√©ran', desc: 'Marquer 100 paniers au total', reward: 150 },
        { id: 'ball_hog', name: 'Ball Hog', desc: 'Tirer 500 fois', reward: 100 },
        { id: 'bricklayer', name: 'Briqueur', desc: 'Rater 50 tirs', reward: 25 },
        { id: 'amateur', name: 'Amateur', desc: 'Atteindre 25 pi', reward: 25 },
        { id: 'sniper', name: 'Sniper', desc: 'Atteindre 50 pi', reward: 50 },
        { id: 'pro', name: 'Pro Shooter', desc: 'Atteindre 75 pi', reward: 75 },
        { id: 'parking_lot', name: 'Parking', desc: 'Atteindre 100 pi', reward: 100 },
        { id: 'longshot', name: 'Longue Distance', desc: 'Atteindre 125 pi', reward: 125 },
        { id: 'levis_legend', name: 'L√©vis Legend', desc: 'Atteindre 150 pi', reward: 200 },
        { id: 'interstellar', name: 'Interstellaire', desc: 'Atteindre 200 pi', reward: 300 },
        { id: 'moonwalker', name: 'Marcheur Lunaire', desc: 'Atteindre 500 pi', reward: 500 },
        { id: 'demigod', name: 'Demi-Dieu', desc: 'Atteindre 1000 pi', reward: 1000 },
        { id: 'contest_winner', name: 'Roi du Concours', desc: 'Score > 10 au Concours', reward: 200 },
        { id: 'contest_perfect', name: 'Perfection', desc: 'Score > 20 au Concours', reward: 500 },
        { id: 'pocket_change', name: 'Fond de poche', desc: 'Avoir 100 Tacos', reward: 10 },
        { id: 'tycoon', name: 'Taco Tycoon', desc: 'Avoir 500 Tacos', reward: 50 },
        { id: 'millionaire', name: 'Millionaire', desc: 'Avoir 2000 Tacos', reward: 200 },
        { id: 'sweet_tooth', name: 'Bec Sucr√©', desc: 'Sirop √ârable Niv 5', reward: 100 },
        { id: 'hawkeye', name: 'Oeil de Lynx', desc: 'Vis√©e Assist√©e Niv 5', reward: 100 },
        { id: 'leprechaun', name: 'Chanceux', desc: 'Taco Grease Niv 5', reward: 100 },
        { id: 'fashionista', name: 'Fashionista', desc: 'D√©bloquer 5 skins', reward: 100 },
        { id: 'wardrobe_malfunction', name: 'Garde-robe Pleine', desc: 'D√©bloquer 10 skins', reward: 300 },
        { id: 'collector', name: 'Collectionneur', desc: 'D√©bloquer 15 skins', reward: 500 },
        { id: 'zoo', name: 'Gardien de Zoo', desc: 'Skins pour 3 animaux diff√©rents', reward: 150 },
        { id: 'lucky', name: 'Chance Pure', desc: 'Avoir un rebond chanceux', reward: 25 },
        { id: 'daredevil', name: 'Casse-cou', desc: 'Marquer en difficult√© max', reward: 50 },
        { id: 'hard_mode', name: 'Travaillant', desc: 'Marquer en mode Difficile', reward: 25 },
        { id: 'cosplay', name: 'Cosplay', desc: '√âquiper Robot/Alien/Ninja', reward: 20 },
        { id: 'eh', name: 'Canadien', desc: '√âquiper B√ªcheron ou Hockey', reward: 20 },
        { id: 'spooky', name: 'Effrayant', desc: '√âquiper Zombie/Vampire/Diable', reward: 20 },
        { id: 'urban_legend', name: 'L√©gende Urbaine', desc: 'Jouer sur le Terrain de Rue', reward: 50 },
        { id: 'ice_cold', name: 'Glace', desc: 'Jouer sur la Patinoire', reward: 100 },
        { id: 'astronaut_training', name: 'Cadet Spatial', desc: 'Jouer sur la Lune', reward: 150 },
        // STREAK ACHIEVEMENTS
        { id: 'streak_2', name: 'Le D√©but', desc: '2 paniers de suite', reward: 5, type: 'streak', threshold: 2 },
        { id: 'streak_3', name: 'Le Hat Trick', desc: '3 paniers de suite', reward: 10, type: 'streak', threshold: 3 },
        { id: 'streak_4', name: 'Le Quatuor', desc: '4 paniers de suite', reward: 15, type: 'streak', threshold: 4 },
        { id: 'streak_5', name: 'En Feu', desc: '5 paniers de suite', reward: 20, type: 'streak', threshold: 5 },
        { id: 'streak_6', name: 'Six-pack', desc: '6 paniers de suite', reward: 25, type: 'streak', threshold: 6 },
        { id: 'streak_7', name: 'Chanceux 7', desc: '7 paniers de suite', reward: 30, type: 'streak', threshold: 7 },
        { id: 'streak_8', name: 'Huitre', desc: '8 paniers de suite', reward: 35, type: 'streak', threshold: 8 },
        { id: 'streak_9', name: 'Le Neuf', desc: '9 paniers de suite', reward: 40, type: 'streak', threshold: 9 },
        { id: 'streak_10', name: 'La Dizaine', desc: '10 paniers de suite', reward: 50, type: 'streak', threshold: 10 },
        { id: 'streak_11', name: 'Onze', desc: '11 paniers de suite', reward: 55, type: 'streak', threshold: 11 },
        { id: 'streak_12', name: 'Douzaine', desc: '12 paniers de suite', reward: 60, type: 'streak', threshold: 12 },
        { id: 'streak_13', name: 'Malchance?', desc: '13 paniers de suite', reward: 65, type: 'streak', threshold: 13 },
        { id: 'streak_14', name: 'Quatorze', desc: '14 paniers de suite', reward: 70, type: 'streak', threshold: 14 },
        { id: 'streak_15', name: 'Quinze', desc: '15 paniers de suite', reward: 75, type: 'streak', threshold: 15 },
        { id: 'streak_16', name: 'Seize', desc: '16 paniers de suite', reward: 80, type: 'streak', threshold: 16 },
        { id: 'streak_17', name: 'Dix-sept', desc: '17 paniers de suite', reward: 85, type: 'streak', threshold: 17 },
        { id: 'streak_18', name: 'Majeur', desc: '18 paniers de suite', reward: 90, type: 'streak', threshold: 18 },
        { id: 'streak_19', name: 'Presque 20', desc: '19 paniers de suite', reward: 95, type: 'streak', threshold: 19 },
        { id: 'streak_20', name: 'Vingtaine', desc: '20 paniers de suite', reward: 100, type: 'streak', threshold: 20 },
        { id: 'streak_25', name: 'Quart de Si√®cle', desc: '25 paniers de suite', reward: 150, type: 'streak', threshold: 25 },
        { id: 'streak_30', name: 'Trente', desc: '30 paniers de suite', reward: 200, type: 'streak', threshold: 30 },
        { id: 'streak_35', name: 'Trente-Cinq', desc: '35 paniers de suite', reward: 250, type: 'streak', threshold: 35 },
        { id: 'streak_40', name: 'Quarantaine', desc: '40 paniers de suite', reward: 300, type: 'streak', threshold: 40 },
        { id: 'streak_45', name: 'Mi-temps', desc: '45 paniers de suite', reward: 350, type: 'streak', threshold: 45 },
        { id: 'streak_50', name: 'Demi-Centenaire', desc: '50 paniers de suite', reward: 500, type: 'streak', threshold: 50 },
        { id: 'streak_55', name: 'Vitesse de Croisi√®re', desc: '55 paniers de suite', reward: 550, type: 'streak', threshold: 55 },
        { id: 'streak_60', name: 'Soixante', desc: '60 paniers de suite', reward: 600, type: 'streak', threshold: 60 },
        { id: 'streak_65', name: 'L\'√Çge d\'Or', desc: '65 paniers de suite', reward: 650, type: 'streak', threshold: 65 },
        { id: 'streak_70', name: 'Septante', desc: '70 paniers de suite', reward: 700, type: 'streak', threshold: 70 },
        { id: 'streak_75', name: 'Trois Quarts', desc: '75 paniers de suite', reward: 750, type: 'streak', threshold: 75 },
        { id: 'streak_80', name: 'Quatre-Vingts', desc: '80 paniers de suite', reward: 800, type: 'streak', threshold: 80 },
        { id: 'streak_85', name: 'Inarr√™table', desc: '85 paniers de suite', reward: 850, type: 'streak', threshold: 85 },
        { id: 'streak_90', name: 'L\'√âlite', desc: '90 paniers de suite', reward: 900, type: 'streak', threshold: 90 },
        { id: 'streak_95', name: 'Presque L√†', desc: '95 paniers de suite', reward: 950, type: 'streak', threshold: 95 },
        { id: 'streak_100', name: 'Le Centenaire', desc: '100 paniers de suite !', reward: 2000, type: 'streak', threshold: 100 },
        // DISTANCE ACHIEVEMENTS
        { id: 'dist_250', name: 'La Colline', desc: 'Atteindre 250 pi', reward: 100, type: 'distance', threshold: 250 },
        { id: 'dist_300', name: 'Tour Eiffel (presque)', desc: 'Atteindre 300 pi', reward: 120, type: 'distance', threshold: 300 },
        { id: 'dist_350', name: 'Gratte-ciel', desc: 'Atteindre 350 pi', reward: 140, type: 'distance', threshold: 350 },
        { id: 'dist_400', name: 'Hauteur de la Tour', desc: 'Atteindre 400 pi', reward: 160, type: 'distance', threshold: 400 },
        { id: 'dist_450', name: 'Vue Panoramique', desc: 'Atteindre 450 pi', reward: 180, type: 'distance', threshold: 450 },
        { id: 'dist_600', name: 'Space Needle', desc: 'Atteindre 600 pi', reward: 200, type: 'distance', threshold: 600 },
        { id: 'dist_700', name: 'Haut Perche', desc: 'Atteindre 700 pi', reward: 220, type: 'distance', threshold: 700 },
        { id: 'dist_800', name: 'Nuages Bas', desc: 'Atteindre 800 pi', reward: 240, type: 'distance', threshold: 800 },
        { id: 'dist_900', name: 'Tour Eiffel (Sommet)', desc: 'Atteindre 900 pi', reward: 260, type: 'distance', threshold: 900 },
        { id: 'dist_1100', name: 'Le Mille +', desc: 'Atteindre 1100 pi', reward: 300, type: 'distance', threshold: 1100 },
        { id: 'dist_1200', name: 'Empire State', desc: 'Atteindre 1200 pi', reward: 320, type: 'distance', threshold: 1200 },
        { id: 'dist_1300', name: 'Chicago', desc: 'Atteindre 1300 pi', reward: 340, type: 'distance', threshold: 1300 },
        { id: 'dist_1400', name: 'CN Tower (Base)', desc: 'Atteindre 1400 pi', reward: 360, type: 'distance', threshold: 1400 },
        { id: 'dist_1500', name: 'CN Tower (Sommet)', desc: 'Atteindre 1500 pi', reward: 380, type: 'distance', threshold: 1500 },
        { id: 'dist_1750', name: 'One World Trade', desc: 'Atteindre 1750 pi', reward: 400, type: 'distance', threshold: 1750 },
        { id: 'dist_2000', name: 'Burj Khalifa (Base)', desc: 'Atteindre 2000 pi', reward: 450, type: 'distance', threshold: 2000 },
        { id: 'dist_2250', name: 'Burj Khalifa (Demi)', desc: 'Atteindre 2250 pi', reward: 500, type: 'distance', threshold: 2250 },
        { id: 'dist_2500', name: 'Burj Khalifa (Sommet)', desc: 'Atteindre 2500 pi', reward: 550, type: 'distance', threshold: 2500 },
        { id: 'dist_2717', name: 'Plus Haut Batiment', desc: 'Atteindre 2717 pi', reward: 600, type: 'distance', threshold: 2717 },
        { id: 'dist_3000', name: 'Montagne', desc: 'Atteindre 3000 pi', reward: 650, type: 'distance', threshold: 3000 },
        { id: 'dist_3500', name: 'Kilom√®tre Vertical', desc: 'Atteindre 3500 pi', reward: 700, type: 'distance', threshold: 3500 },
        { id: 'dist_4000', name: 'H√©licopt√®re', desc: 'Atteindre 4000 pi', reward: 750, type: 'distance', threshold: 4000 },
        { id: 'dist_4500', name: 'Grand Canyon', desc: 'Atteindre 4500 pi', reward: 800, type: 'distance', threshold: 4500 },
        { id: 'dist_5000', name: 'Un Mille Marin', desc: 'Atteindre 5000 pi', reward: 850, type: 'distance', threshold: 5000 },
        { id: 'dist_6000', name: 'Denver', desc: 'Atteindre 6000 pi', reward: 900, type: 'distance', threshold: 6000 },
        { id: 'dist_7000', name: 'Mexico City', desc: 'Atteindre 7000 pi', reward: 950, type: 'distance', threshold: 7000 },
        { id: 'dist_8000', name: 'Machu Picchu', desc: 'Atteindre 8000 pi', reward: 1000, type: 'distance', threshold: 8000 },
        { id: 'dist_9000', name: 'Quito', desc: 'Atteindre 9000 pi', reward: 1100, type: 'distance', threshold: 9000 },
        { id: 'dist_10000', name: 'Aviation L√©g√®re', desc: 'Atteindre 10000 pi', reward: 1200, type: 'distance', threshold: 10000 },
        { id: 'dist_12000', name: 'Mont Fuji', desc: 'Atteindre 12000 pi', reward: 1300, type: 'distance', threshold: 12000 },
        { id: 'dist_14000', name: 'Mont Rainier', desc: 'Atteindre 14000 pi', reward: 1400, type: 'distance', threshold: 14000 },
        { id: 'dist_16000', name: 'Mont Blanc', desc: 'Atteindre 16000 pi', reward: 1500, type: 'distance', threshold: 16000 },
        { id: 'dist_18000', name: 'Camp de Base', desc: 'Atteindre 18000 pi', reward: 1600, type: 'distance', threshold: 18000 },
        { id: 'dist_19000', name: 'Kilimanjaro', desc: 'Atteindre 19000 pi', reward: 1800, type: 'distance', threshold: 19000 },
        { id: 'dist_20000', name: 'Denali', desc: 'Atteindre 20000 pi', reward: 2000, type: 'distance', threshold: 20000 }
    ];

    var COURT_ZONES = [
        { limit: 50, name: "COUR ARRI√àRE", type: 'grass', ground1: '#228B22', ground2: '#32CD32', sky1: '#87CEEB', sky2: '#FFF' },
        { limit: 100, name: "PARC DE LA PAIX", type: 'tree', ground1: '#8B4513', ground2: '#D2691E', sky1: '#87CEEB', sky2: '#E0FFFF' },
        { limit: 200, name: "VIEUX-L√âVIS", type: 'castle', ground1: '#8B0000', ground2: '#A52A2A', sky1: '#4682B4', sky2: '#87CEEB' },
        { limit: 350, name: "TERRAIN DE RUE", type: 'castle', ground1: '#696969', ground2: '#808080', sky1: '#4682B4', sky2: '#87CEEB' },
        { limit: 500, name: "FOR√äT BOR√âALE", type: 'tree', ground1: '#006400', ground2: '#2F4F4F', sky1: '#2E8B57', sky2: '#8FBC8F' },
        { limit: 750, name: "LA PATINOIRE", type: 'mountain', ground1: '#E0FFFF', ground2: '#FFFFFF', sky1: '#87CEEB', sky2: '#F0F8FF' },
        { limit: 1000, name: "FLEUVE ST-LAURENT", type: 'water', ground1: '#00008B', ground2: '#1E90FF', sky1: '#191970', sky2: '#4169E1' },
        { limit: 1500, name: "MONT-SAINTE-ANNE", type: 'mountain', ground1: '#F0FFFF', ground2: '#E0FFFF', sky1: '#87CEEB', sky2: '#00BFFF' },
        { limit: 2500, name: "HAUTE ATMOSPH√àRE", type: 'space', ground1: '#483D8B', ground2: '#6A5ACD', sky1: '#000080', sky2: '#000000' },
        { limit: 4000, name: "BASE LUNAIRE", type: 'space', ground1: '#808080', ground2: '#A9A9A9', sky1: '#000000', sky2: '#191970' },
        { limit: 6000, name: "MARS", type: 'space', ground1: '#8B4513', ground2: '#CD853F', sky1: '#FF4500', sky2: '#000000' },
        { limit: 8000, name: "LE NETHER", type: 'space', ground1: '#8B0000', ground2: '#2F0000', sky1: '#330000', sky2: '#000000' },
        { limit: 9999999, name: "DIMENSION TACO", type: 'grass', ground1: '#FF00FF', ground2: '#00FFFF', sky1: '#FFFF00', sky2: '#FF0000' }
    ];

    var SCALE_OBJECTS = [
        { limit: 15, name: "Voiture Compacte", icon: "üöó" },
        { limit: 25, name: "Orignal (2m)", icon: "ü¶å" },
        { limit: 30, name: "Ligne de 3 points", icon: "üèÄ" },
        { limit: 40, name: "Autobus Scolaire", icon: "üöå" },
        { limit: 60, name: "Piste de Bowling", icon: "üé≥" },
        { limit: 94, name: "Terrain NBA", icon: "üèÄ" },
        { limit: 150, name: "Baleine Bleue", icon: "üêã" },
        { limit: 195, name: "Tour de Pise", icon: "üáÆüáπ" },
        { limit: 230, name: "Envergure Boeing 747", icon: "‚úàÔ∏è" },
        { limit: 272, name: "Chute Montmorency", icon: "üåä" },
        { limit: 305, name: "Statue de la Libert√©", icon: "üóΩ" },
        { limit: 350, name: "Ch√¢teau Frontenac", icon: "üè∞" },
        { limit: 450, name: "Pyramide de Gizeh", icon: "üî∫" },
        { limit: 600, name: "Space Needle", icon: "üõ∏" },
        { limit: 984, name: "Tour Eiffel", icon: "üá´üá∑" },
        { limit: 1454, name: "Empire State Building", icon: "üèôÔ∏è" },
        { limit: 1815, name: "Tour CN", icon: "üóº" },
        { limit: 2200, name: "Pont de Qu√©bec (Trav√©e)", icon: "üåâ" },
        { limit: 2717, name: "Burj Khalifa", icon: "üè¢" },
        { limit: 5280, name: "Un Mille (1.6km)", icon: "üõ£Ô∏è" },
        { limit: 10000, name: "Piste A√©roport", icon: "üõ´" },
        { limit: 14410, name: "Mont Rainier", icon: "üèîÔ∏è" },
        { limit: 20310, name: "Mont Denali", icon: "‚õ∞Ô∏è" },
        { limit: 29029, name: "Mont Everest", icon: "üóª" },
        { limit: 35000, name: "Altitude de Croisi√®re", icon: "‚úàÔ∏è" },
        { limit: 100000, name: "Stratosph√®re", icon: "üéà" },
        { limit: 328000, name: "Ligne de K√°rm√°n (Espace)", icon: "üåå" },
        { limit: 1300000, name: "Station Spatiale (ISS)", icon: "üõ∞Ô∏è" },
        { limit: 9999999, name: "La Lune", icon: "üåë" }
    ];

    var SKINS_DB = [
        // RATS
        { id: 'rat_classic', animal: 'rat', name: 'Classique', cost: 0 },
        { id: 'rat_lumberjack', animal: 'rat', name: 'B√ªcheron', cost: 500, jerseyColor: '#b30000', shortsColor: '#00008b', legType: 'pants', shoesColor: '#8B4513', pattern: 'plaid', headAccessory: 'beanie', hatColor: '#FF0000', backProp: 'axe', clothingDetail: 'suspenders' },
        { id: 'rat_mariachi', animal: 'rat', name: 'El Mariachi', cost: 1000, jerseyColor: '#1a1a1a', shortsColor: '#1a1a1a', legType: 'pants', shoesColor: '#000', pattern: 'suit', headAccessory: 'sombrero', hatColor: '#1a1a1a', backProp: 'guitar' },
        { id: 'rat_luchador', animal: 'rat', name: 'Luchador', cost: 1500, jerseyColor: '#008000', shortsColor: '#008000', legType: 'pants', shoesColor: '#000', socksColor: '#FFF' },
        { id: 'rat_alien', animal: 'rat', name: 'Alien', cost: 3000, jerseyColor: '#C0C0C0', shortsColor: '#C0C0C0', sleeveColor: '#C0C0C0', legType: 'pants', shoesColor: '#555', headDetail: 'antenna' },
        { id: 'rat_zombie', animal: 'rat', name: 'Zombie', cost: 3000, jerseyColor: '#5D4037', shortsColor: '#3E2723', legType: 'pants', shoesColor: '#111' },
        { id: 'rat_astronaut', animal: 'rat', name: 'Astronaute', cost: 5000, jerseyColor: '#FFF', shortsColor: '#FFF', sleeveColor: '#FFF', legType: 'pants', shoesColor: '#AAA', headAccessory: 'helmet', hatColor: '#87CEEB', backProp: 'oxygen_tank' },
        { id: 'rat_ninja', animal: 'rat', name: 'Ninja', cost: 5000, jerseyColor: '#111', shortsColor: '#111', sleeveColor: '#111', legType: 'pants', headAccessory: 'headband', hatColor: '#F00', backProp: 'katanas' },
        { id: 'rat_robot', animal: 'rat', name: 'Robot', cost: 5000, jerseyColor: '#808080', shortsColor: '#808080', sleeveColor: '#808080', legType: 'pants', backProp: 'windup_key', headDetail: 'antenna' },
        { id: 'rat_pirate', animal: 'rat', name: 'Pirate', cost: 1500, jerseyColor: '#FFF', shortsColor: '#000', legType: 'pants', shoesColor: '#000', headAccessory: 'eyepatch', backProp: 'sword', headDetail: 'bandana_ties' },
        { id: 'rat_clown', animal: 'rat', name: 'Clown', cost: 1500, jerseyColor: '#FFD700', shortsColor: '#FF4500', shoesColor: '#F00', headAccessory: 'red_nose' },
        { id: 'rat_vampire', animal: 'rat', name: 'Vampire', cost: 3000, jerseyColor: '#FFF', shortsColor: '#000', legType: 'pants', shoesColor: '#000', backAccessory: 'cape', backColor: '#000' },
        { id: 'rat_chef', animal: 'rat', name: 'Chef', cost: 750, jerseyColor: '#FFF', shortsColor: '#000', shoesColor: '#000', headAccessory: 'chef_hat', clothingDetail: 'apron_ties' },
        { id: 'rat_hockey', animal: 'rat', name: 'Joueur Hockey', cost: 7500, jerseyColor: '#CC0000', shortsColor: '#000', legType: 'pants', shoesColor: '#FFF', headAccessory: 'helmet', hatColor: '#FFF', backProp: 'hockey_sticks' },
        { id: 'rat_poutine', animal: 'rat', name: 'Poutine', cost: 7500, jerseyColor: '#8B4513', shortsColor: '#F4C430', shoesColor: '#8B4513' },
        { id: 'rat_king', animal: 'rat', name: 'Roi', cost: 10000, jerseyColor: '#800080', shortsColor: '#800080', legType: 'pants', shoesColor: '#FFD700', headAccessory: 'crown', backAccessory: 'cape', backColor: '#800080' },
        { id: 'rat_wizard', animal: 'rat', name: 'Sorcier', cost: 10000, jerseyColor: '#000080', shortsColor: '#000080', legType: 'pants', shoesColor: '#000', headAccessory: 'wizard_hat', backAccessory: 'cape', backColor: '#000080', backProp: 'staff' },
        { id: 'rat_devil', animal: 'rat', name: 'Diable', cost: 15000, jerseyColor: '#800000', shortsColor: '#800000', legType: 'pants', shoesColor: '#000', headAccessory: 'horns', tailType: 'devil' },
        { id: 'rat_angel', animal: 'rat', name: 'Ange', cost: 15000, jerseyColor: '#FFF', shortsColor: '#FFF', legType: 'pants', shoesColor: '#FFD700', headAccessory: 'halo', backAccessory: 'wings' },
        // NEW RATS
        { id: 'rat_ghost', animal: 'rat', name: 'Fant√¥me', cost: 2000, furColor: 'rgba(255,255,255,0.6)', jerseyColor: 'rgba(255,255,255,0.3)', shortsColor: 'rgba(255,255,255,0.3)' },
        { id: 'rat_jester', animal: 'rat', name: 'Bouffon', cost: 2500, jerseyColor: '#FF00FF', shortsColor: '#FFFF00', shoesColor: '#00FFFF', headAccessory: 'crown', hatColor: '#FF00FF' },
        { id: 'rat_miner', animal: 'rat', name: 'Mineur', cost: 3000, jerseyColor: '#555', shortsColor: '#333', headAccessory: 'helmet', hatColor: '#FFA500' },
        { id: 'rat_rapper', animal: 'rat', name: 'Rappeur', cost: 3500, jerseyColor: '#FFF', shortsColor: '#000', headAccessory: 'beanie', hatColor: '#000', backAccessory: 'backpack' },
        { id: 'rat_detective', animal: 'rat', name: 'D√©tective', cost: 4000, jerseyColor: '#D2B48C', shortsColor: '#8B4513', legType: 'pants', headAccessory: 'hat', hatColor: '#8B4513' },

        // CATS
        { id: 'cat_classic', animal: 'cat', name: 'Classique', cost: 250 },
        { id: 'cat_tabby', animal: 'cat', name: 'Tigr√©', cost: 1000, furColor: '#FFA500' },
        { id: 'cat_tuxedo', animal: 'cat', name: 'Tuxedo', cost: 1000, furColor: '#111' },
        // NEW CATS
        { id: 'cat_panther', animal: 'cat', name: 'Panth√®re', cost: 2500, furColor: '#000', headAccessory: 'collar', hatColor: '#FFD700' },
        { id: 'cat_siamese', animal: 'cat', name: 'Siamois', cost: 2500, furColor: '#D2B48C', hasSpots: true, headAccessory: 'bow', hatColor: '#FF69B4' },
        { id: 'cat_sphinx', animal: 'cat', name: 'Sphinx', cost: 3000, furColor: '#FFC0CB', headAccessory: 'crown' },
        { id: 'cat_garfield', animal: 'cat', name: 'Lundi', cost: 3500, furColor: '#FF8C00', pattern: 'stripes', headAccessory: 'beanie', hatColor: '#000' },
        { id: 'cat_persian', animal: 'cat', name: 'Persan', cost: 4000, furColor: '#FFF', headAccessory: 'bow', hatColor: '#800080' },

        // DOGS
        { id: 'dog_classic', animal: 'dog', name: 'Classique', cost: 250 },
        { id: 'dog_dalmation', animal: 'dog', name: 'Dalmatien', cost: 1000, furColor: '#FFF', hasSpots: true },
        { id: 'dog_pug', animal: 'dog', name: 'Carlin', cost: 1500, furColor: '#d2b48c' },
        // NEW DOGS
        { id: 'dog_husky', animal: 'dog', name: 'Husky', cost: 2500, furColor: '#AAA', headAccessory: 'scarf', hatColor: '#FF0000' },
        { id: 'dog_boxer', animal: 'dog', name: 'Boxer', cost: 2500, furColor: '#8B4513', headAccessory: 'headband', hatColor: '#FFF' },
        { id: 'dog_police', animal: 'dog', name: 'K-9', cost: 3000, jerseyColor: '#000080', shortsColor: '#000080', headAccessory: 'hat', hatColor: '#000080' },
        { id: 'dog_golden', animal: 'dog', name: 'Golden', cost: 3500, furColor: '#FFD700', headAccessory: 'halo' },
        { id: 'dog_hotdog', animal: 'dog', name: 'Hot-Dog', cost: 4000, jerseyColor: '#FFA500', shortsColor: '#8B4513' },
        { id: 'dog_airbud', animal: 'dog', name: 'Air Bud', cost: 500, furColor: '#DAA520', jerseyColor: '#191970', shortsColor: '#191970', trimColor: '#FFD700', number: '1', numberColor: '#FFD700' },

        // BEARS
        { id: 'bear_classic', animal: 'bear', name: 'Classique', cost: 500 },
        { id: 'bear_panda', animal: 'bear', name: 'Panda', cost: 3000, furColor: '#FFF', legType: 'panda_limbs' },
        { id: 'bear_polar', animal: 'bear', name: 'Polaire', cost: 3000, furColor: '#F0F8FF' },
        // NEW BEARS
        { id: 'bear_grizzly', animal: 'bear', name: 'Grizzly', cost: 2500, furColor: '#3E2723', headAccessory: 'hat', hatColor: '#5D4037' },
        { id: 'bear_teddy', animal: 'bear', name: 'Toutou', cost: 2500, furColor: '#D2691E', headAccessory: 'bow', hatColor: '#FF0000' },
        { id: 'bear_cyborg', animal: 'bear', name: 'Cyborg', cost: 4000, furColor: '#C0C0C0', headDetail: 'antenna' },
        { id: 'bear_gummy', animal: 'bear', name: 'G√©latine', cost: 3500, furColor: 'rgba(255,0,0,0.6)' },
        { id: 'bear_care', animal: 'bear', name: 'Calin', cost: 3500, furColor: '#FF69B4', pattern: 'heart' },

        // RABBITS
        { id: 'rabbit_classic', animal: 'rabbit', name: 'Classique', cost: 250, furColor: '#8B4513' },
        { id: 'rabbit_jack', animal: 'rabbit', name: 'Li√®vre', cost: 1000, furColor: '#FFFFFF' },
        { id: 'rabbit_magic', animal: 'rabbit', name: 'Magicien', cost: 2500, jerseyColor: '#000', shortsColor: '#000', legType: 'pants', shoesColor: '#FFF', headAccessory: 'wizard_hat', hatColor: '#000', backProp: 'staff' },
        // NEW RABBITS
        { id: 'rabbit_easter', animal: 'rabbit', name: 'P√¢ques', cost: 2500, furColor: '#ADD8E6', pattern: 'spots', backProp: 'basket' },
        { id: 'rabbit_energizer', animal: 'rabbit', name: 'Duracell', cost: 3000, furColor: '#FF69B4', headAccessory: 'headband', hatColor: '#000' },
        { id: 'rabbit_velveteen', animal: 'rabbit', name: 'Peluche', cost: 2000, furColor: '#A0522D', clothingDetail: 'stitches' },
        { id: 'rabbit_killer', animal: 'rabbit', name: 'Vorpal', cost: 5000, furColor: '#FFF', headAccessory: 'collar', hatColor: '#FF0000' },
        { id: 'rabbit_cyborg', animal: 'rabbit', name: 'Robo-Lapin', cost: 4000, furColor: '#C0C0C0' },

        // MOOSE
        { id: 'moose_classic', animal: 'moose', name: 'Classique', cost: 750 },
        { id: 'moose_royal', animal: 'moose', name: 'Royal', cost: 5000, headAccessory: 'crown', backAccessory: 'cape', backColor: '#800080' },
        // NEW MOOSE
        { id: 'moose_mountie', animal: 'moose', name: 'Gendarme', cost: 3000, jerseyColor: '#FF0000', shortsColor: '#000', headAccessory: 'hat', hatColor: '#8B4513' },
        { id: 'moose_christmas', animal: 'moose', name: 'No√´l', cost: 3000, jerseyColor: '#006400', shortsColor: '#FF0000', headAccessory: 'antlers_lights' },
        { id: 'moose_swamp', animal: 'moose', name: 'Marais', cost: 2500, furColor: '#556B2F', headAccessory: 'algae' },
        { id: 'moose_albino', animal: 'moose', name: 'Albinos', cost: 4000, furColor: '#FFF', headAccessory: 'halo' },
        { id: 'moose_bullwinkle', animal: 'moose', name: 'Toon', cost: 3500, furColor: '#8B4513', jerseyType: 'tshirt' },

        // FOXES (NEW)
        { id: 'fox_classic', animal: 'fox', name: 'Classique', cost: 1000 },
        { id: 'fox_arctic', animal: 'fox', name: 'Arctique', cost: 2000, furColor: '#FFF', headAccessory: 'ear_muffs', hatColor: '#ADD8E6' },
        { id: 'fox_kitsune', animal: 'fox', name: 'Kitsune', cost: 5000, furColor: '#FFD700', tailType: 'multi' },
        { id: 'fox_ninja', animal: 'fox', name: 'Ombre', cost: 3000, jerseyColor: '#000', shortsColor: '#000', headAccessory: 'headband' },
        { id: 'fox_pilot', animal: 'fox', name: 'Pilote', cost: 3000, jerseyColor: '#FFF', shortsColor: '#228B22', headAccessory: 'helmet', hatColor: '#CCC' },
        { id: 'fox_gentleman', animal: 'fox', name: 'Gentleman', cost: 4000, jerseyColor: '#000', shortsColor: '#000', legType: 'pants', pattern: 'suit', headAccessory: 'top_hat' },

        // WOLVES (NEW)
        { id: 'wolf_classic', animal: 'wolf', name: 'Classique', cost: 1000 },
        { id: 'wolf_black', animal: 'wolf', name: 'Noir', cost: 2000, furColor: '#1a1a1a', headAccessory: 'collar', hatColor: '#FF0000' },
        { id: 'wolf_white', animal: 'wolf', name: 'Blanc', cost: 2000, furColor: '#FFF', headAccessory: 'scarf', hatColor: '#00008B' },
        { id: 'wolf_alpha', animal: 'wolf', name: 'Alpha', cost: 5000, furColor: '#333' },
        { id: 'wolf_cyber', animal: 'wolf', name: 'Cyber', cost: 4000, furColor: '#C0C0C0', headDetail: 'visor' },
        { id: 'wolf_shaman', animal: 'wolf', name: 'Chaman', cost: 3500, furColor: '#808080', headAccessory: 'feathers' },

        // LIONS (NEW)
        { id: 'lion_classic', animal: 'lion', name: 'Classique', cost: 1500 },
        { id: 'lion_scar', animal: 'lion', name: 'Balafr√©', cost: 3000, furColor: '#8B4513' },
        { id: 'lion_white', animal: 'lion', name: 'Blanc', cost: 3000, furColor: '#FFF', headAccessory: 'crown' },
        { id: 'lion_king', animal: 'lion', name: 'Roi', cost: 10000, headAccessory: 'crown', backAccessory: 'cape', backColor: '#800080' },
        { id: 'lion_rasta', animal: 'lion', name: 'Rasta', cost: 4000, jerseyColor: '#008000', shortsColor: '#FFFF00', shoesColor: '#FF0000', headAccessory: 'beanie' },
        { id: 'lion_mech', animal: 'lion', name: 'Mecha', cost: 5000, furColor: '#C0C0C0', headDetail: 'visor' },

        // TIGERS (NEW)
        { id: 'tiger_classic', animal: 'tiger', name: 'Classique', cost: 1500, pattern: 'tiger_stripes' },
        { id: 'tiger_white', animal: 'tiger', name: 'Blanc', cost: 3000, furColor: '#FFF', pattern: 'tiger_stripes', headAccessory: 'headband', hatColor: '#FFF' },
        { id: 'tiger_sabretooth', animal: 'tiger', name: 'Smilodon', cost: 5000, furColor: '#D2B48C', headAccessory: 'collar', hatColor: '#000' },
        { id: 'tiger_karate', animal: 'tiger', name: 'Karat√©', cost: 3500, jerseyColor: '#FFF', shortsColor: '#FFF', legType: 'pants', headAccessory: 'headband' },
        { id: 'tiger_tony', animal: 'tiger', name: 'Mascotte', cost: 4000, jerseyColor: '#FF0000', headAccessory: 'bandana_neck' },
        { id: 'tiger_neon', animal: 'tiger', name: 'N√©on', cost: 4500, furColor: '#00FFFF', pattern: 'tiger_stripes' },

        // PIGS (NEW)
        { id: 'pig_classic', animal: 'pig', name: 'Classique', cost: 1000 },
        { id: 'pig_muddy', animal: 'pig', name: 'Boueux', cost: 2000, furColor: '#FFC0CB', pattern: 'spots', spotColor: '#8B4513' },
        { id: 'pig_boar', animal: 'pig', name: 'Sanglier', cost: 3000, furColor: '#5D4037', headDetail: 'mohawk', hairColor: '#000' },
        { id: 'pig_bank', animal: 'pig', name: 'Tirelire', cost: 4000, furColor: '#FF69B4', skinType: 'shiny' },
        { id: 'pig_police', animal: 'pig', name: 'Police', cost: 3500, jerseyColor: '#000080', shortsColor: '#000080', headAccessory: 'hat', hatColor: '#000080' },
        { id: 'pig_gentleman', animal: 'pig', name: 'Riche', cost: 5000, jerseyColor: '#000', shortsColor: '#000', legType: 'pants', headAccessory: 'top_hat', pattern: 'suit' },

        // COWS (NEW)
        { id: 'cow_classic', animal: 'cow', name: 'Classique', cost: 1000, pattern: 'cow_spots' },
        { id: 'cow_highland', animal: 'cow', name: 'Highland', cost: 3000, furColor: '#8B0000' },
        { id: 'cow_bull', animal: 'cow', name: 'Taureau', cost: 3500, furColor: '#000', headAccessory: 'bandana_neck' },
        { id: 'cow_strawberry', animal: 'cow', name: 'Fraise', cost: 2500, furColor: '#FFC0CB', pattern: 'cow_spots', headAccessory: 'flower' },
        { id: 'cow_farmer', animal: 'cow', name: 'Fermier', cost: 3000, clothingDetail: 'overalls', jerseyColor: '#87CEEB', shortsColor: '#000080' },
        { id: 'cow_space', animal: 'cow', name: 'Espace', cost: 5000, furColor: '#00FF00', headAccessory: 'helmet' },

        // MONKEYS (NEW)
        { id: 'monkey_classic', animal: 'monkey', name: 'Classique', cost: 1000 },
        { id: 'monkey_gorilla', animal: 'monkey', name: 'Gorille', cost: 3000, furColor: '#000', backProp: 'barrel' },
        { id: 'monkey_chimp', animal: 'monkey', name: 'Chimpanz√©', cost: 2500, furColor: '#333', headAccessory: 'fez' },
        { id: 'monkey_wukong', animal: 'monkey', name: 'Wukong', cost: 10000, furColor: '#FFD700', headAccessory: 'crown', backProp: 'staff' },
        { id: 'monkey_space', animal: 'monkey', name: 'Cosmonaute', cost: 4000, jerseyColor: '#FFA500', shortsColor: '#FFA500', legType: 'pants', headAccessory: 'helmet' },
        { id: 'monkey_zombie', animal: 'monkey', name: 'Zombie', cost: 3000, furColor: '#556B2F' },

        // PENGUINS (NEW)
        { id: 'penguin_classic', animal: 'penguin', name: 'Classique', cost: 1000 },
        { id: 'penguin_emperor', animal: 'penguin', name: 'Empereur', cost: 2500, headDetail: 'yellow_neck' },
        { id: 'penguin_tuxedo', animal: 'penguin', name: 'Tuxedo', cost: 2000, pattern: 'suit' },
        { id: 'penguin_icy', animal: 'penguin', name: 'Glace', cost: 3000, furColor: '#ADD8E6', headAccessory: 'ear_muffs', hatColor: '#FFF' },
        { id: 'penguin_pilot', animal: 'penguin', name: 'Pilote', cost: 3500, headAccessory: 'helmet', hatColor: '#CCC' },
        { id: 'penguin_rico', animal: 'penguin', name: 'Rico', cost: 3000, headDetail: 'mohawk' },

        // NBA LEGENDS (Humans - Accurate Colors & Patterns)
        { id: 'human_wall', animal: 'human', name: 'Speedy', cost: 5000, heightScale: 1.085, widthScale: 0.9, jerseyColor: '#002B5C', shortsColor: '#002B5C', sideStripesColor: '#E31837', number: '2', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', sleeveRight: '#E31837' },
        { id: 'human_lebron', animal: 'human', name: 'The King', cost: 25000, heightScale: 1.170, widthScale: 1.0, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '23', numberColor: '#552583', skinTone: '#4a3020', hairStyle: 'headband', hairColor: '#000', headbandColor: '#552583', sleeveRight: '#FDB927', socksColor: '#FFF', shoesColor: '#552583' },
        { id: 'human_kobe8', animal: 'human', name: 'Frobe', cost: 30000, heightScale: 1.130, widthScale: 0.9, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '8', numberColor: '#552583', skinTone: '#5c3a21', hairStyle: 'afro', hairColor: '#000', socksColor: '#FFF', shoesColor: '#111' },
        { id: 'human_kobe24', animal: 'human', name: 'Black Mamba', cost: 30000, heightScale: 1.130, widthScale: 0.9, jerseyColor: '#FFF', shortsColor: '#FFF', trimColor: '#552583', number: '24', numberColor: '#552583', skinTone: '#5c3a21', hairStyle: 'bald', hairColor: '#000', sleeveRight: '#FFF', socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_curry', animal: 'human', name: 'Chef Curry', cost: 30000, heightScale: 1.070, widthScale: 0.85, jerseyColor: '#1D428A', shortsColor: '#1D428A', trimColor: '#FFC72C', number: '30', numberColor: '#FFC72C', skinTone: '#dcb98a', hairStyle: 'short', hairColor: '#000', jerseyType: 'tshirt', socksColor: '#FFF', shoesColor: '#FFC72C' },
        { id: 'human_magic', animal: 'human', name: 'Magic', cost: 30000, heightScale: 1.170, widthScale: 0.95, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '32', numberColor: '#552583', skinTone: '#5c3a21', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#FFF', shortsLength: 'short' },
        { id: 'human_drj', animal: 'human', name: 'The Doctor', cost: 35000, heightScale: 1.140, widthScale: 0.9, jerseyColor: '#FFF', shortsColor: '#FFF', trimColor: '#ED174C', number: '32', numberColor: '#ED174C', skinTone: '#5c3a21', hairStyle: 'afro', hairColor: '#000', socksColor: '#FFF', shoesColor: '#ED174C', shortsLength: 'short' },
        { id: 'human_wilt', animal: 'human', name: 'The Stilt', cost: 40000, heightScale: 1.230, widthScale: 0.95, jerseyColor: '#552583', shortsColor: '#552583', sideStripesColor: '#FDB927', number: '13', numberColor: '#FFF', skinTone: '#4a3020', hairStyle: 'headband', hairColor: '#000', headbandColor: '#FDB927', socksColor: '#FFF', shoesColor: '#FFF', shortsLength: 'short' },
        { id: 'human_mj', animal: 'human', name: 'The G.O.A.T.', cost: 50000, heightScale: 1.130, widthScale: 0.9, jerseyColor: '#CE1141', shortsColor: '#CE1141', trimColor: '#000', number: '23', numberColor: '#000', skinTone: '#3e271a', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#CE1141' },
        { id: 'human_bird', animal: 'human', name: 'Larry Legend', cost: 40000, heightScale: 1.170, widthScale: 0.95, jerseyColor: '#007A33', shortsColor: '#007A33', trimColor: '#FFF', number: '33', numberColor: '#FFF', skinTone: '#f0d5be', hairStyle: 'short', hairColor: '#e3c179', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_shaq', animal: 'human', name: 'Diesel', cost: 40000, heightScale: 1.230, widthScale: 1.2, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '34', numberColor: '#552583', skinTone: '#3c2415', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#111' },
        { id: 'human_ai', animal: 'human', name: 'The Answer', cost: 35000, heightScale: 1.040, widthScale: 0.8, jerseyColor: '#000', shortsColor: '#000', trimColor: '#ED174C', number: '3', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'cornrows', hairColor: '#000', headbandColor: '#FFF', sleeveRight: '#000', socksColor: '#000', shoesColor: '#FFF' },
        { id: 'human_duncan', animal: 'human', name: 'Big Fundamental', cost: 35000, heightScale: 1.200, widthScale: 0.95, jerseyColor: '#000', shortsColor: '#000', trimColor: '#C4CED4', number: '21', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'short', hairColor: '#000', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_rodman', animal: 'human', name: 'The Worm', cost: 30000, heightScale: 1.140, widthScale: 0.9, jerseyColor: '#CE1141', shortsColor: '#000', trimColor: '#000', number: '91', numberColor: '#000', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#00FF00', socksColor: '#FFF', shoesColor: '#FFF', shortsLength: 'short' },
        { id: 'human_barkley', animal: 'human', name: 'Sir Charles', cost: 30000, heightScale: 1.130, widthScale: 1.05, jerseyColor: '#1D1160', shortsColor: '#1D1160', sideStripesColor: '#E56020', number: '34', numberColor: '#E56020', skinTone: '#8d5524', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_dirk', animal: 'human', name: 'German Jesus', cost: 30000, heightScale: 1.215, widthScale: 0.92, jerseyColor: '#00538C', shortsColor: '#00538C', sideStripesColor: '#B8C4CA', number: '41', numberColor: '#FFF', skinTone: '#f0d5be', hairStyle: 'curly_long', hairColor: '#dcb98a', socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_giannis', animal: 'human', name: 'Greek Freak', cost: 25000, heightScale: 1.200, widthScale: 0.98, jerseyColor: '#00471B', shortsColor: '#00471B', sideStripesColor: '#EEE1C6', number: '34', numberColor: '#EEE1C6', skinTone: '#4a3020', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_joker', animal: 'human', name: 'The Joker', cost: 25000, heightScale: 1.200, widthScale: 1.1, jerseyColor: '#0E2240', shortsColor: '#0E2240', trimColor: '#FEC524', number: '15', numberColor: '#FEC524', skinTone: '#f0d5be', hairStyle: 'short', hairColor: '#4a3020', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_luka', animal: 'human', name: 'Luka Magic', cost: 25000, heightScale: 1.140, widthScale: 1.0, jerseyColor: '#00538C', shortsColor: '#00538C', sideStripesColor: '#B8C4CA', number: '77', numberColor: '#FFF', skinTone: '#f0d5be', hairStyle: 'short', hairColor: '#4a3020', socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_kd', animal: 'human', name: 'Slim Reaper', cost: 30000, heightScale: 1.200, widthScale: 0.85, jerseyColor: '#1D1160', shortsColor: '#1D1160', sideStripesColor: '#E56020', number: '35', numberColor: '#E56020', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#1D428A' },
        { id: 'human_harden', animal: 'human', name: 'The Beard', cost: 25000, heightScale: 1.110, widthScale: 0.95, jerseyColor: '#CE1141', shortsColor: '#CE1141', sideStripesColor: '#FFF', number: '13', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'mohawk', hairColor: '#000', beard: true, beardColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_vince', animal: 'human', name: 'Vinsanity', cost: 30000, heightScale: 1.130, widthScale: 0.92, jerseyColor: '#753BBD', shortsColor: '#753BBD', pinstripesColor: '#CE1141', number: '15', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_kareem', animal: 'human', name: 'Cap', cost: 45000, heightScale: 1.245, widthScale: 0.88, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '33', numberColor: '#552583', skinTone: '#4a3020', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#1D428A', shortsLength: 'short' },
        { id: 'human_russell', animal: 'human', name: 'Bill', cost: 50000, heightScale: 1.185, widthScale: 0.9, jerseyColor: '#007A33', shortsColor: '#007A33', trimColor: '#FFF', number: '6', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#000', beard: true, beardColor: '#ccc', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_pip', animal: 'human', name: 'Pip', cost: 30000, heightScale: 1.160, widthScale: 0.9, jerseyColor: '#CE1141', shortsColor: '#CE1141', trimColor: '#000', number: '33', numberColor: '#000', skinTone: '#4a3020', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_wade', animal: 'human', name: 'Flash', cost: 30000, heightScale: 1.100, widthScale: 0.92, jerseyColor: '#000', shortsColor: '#000', sideStripesColor: '#98002E', number: '3', numberColor: '#FFF', skinTone: '#4a3020', hairStyle: 'short', hairColor: '#000', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_reggie', animal: 'human', name: 'Reggie', cost: 25000, heightScale: 1.140, widthScale: 0.85, jerseyColor: '#002D62', shortsColor: '#002D62', pinstripesColor: '#FDB927', number: '31', numberColor: '#FDB927', skinTone: '#8d5524', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_tmac', animal: 'human', name: 'T-Mac', cost: 25000, heightScale: 1.160, widthScale: 0.9, jerseyColor: '#007DC5', shortsColor: '#007DC5', pinstripesColor: '#C4CED4', number: '1', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_kg', animal: 'human', name: 'Big Ticket', cost: 30000, heightScale: 1.200, widthScale: 0.88, jerseyColor: '#005083', shortsColor: '#005083', trimColor: '#78BE20', number: '21', numberColor: '#FFF', skinTone: '#2e1e16', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_jackie', animal: 'human', name: 'Jackie Moon', cost: 500, heightScale: 1.1, widthScale: 1.0, jerseyColor: '#FFF', shortsColor: '#FFF', trimColor: '#FFA500', sideStripesColor: '#00CED1', number: '33', numberColor: '#00CED1', skinTone: '#ffe0bd', hairStyle: 'afro', hairColor: '#5D4037', headAccessory: 'headband', hatColor: '#FFA500', socksColor: '#FFF', shoesColor: '#FFF', shortsLength: 'short' },

        // PARODIES & MYTHICAL (Unique)
        { id: 'human_hedgehog', animal: 'human', name: 'H√©risson Bleu', cost: 15000, heightScale: 0.9, widthScale: 0.9, jerseyColor: '#0000FF', shortsColor: '#0000FF', sleeveColor: '#0000FF', skinTone: '#0000FF', hairStyle: 'spikes', hairColor: '#0000FF', shoesColor: '#FF0000', socksColor: '#FFF' },
        { id: 'human_soldier', animal: 'human', name: 'Soldat du Futur', cost: 20000, heightScale: 1.2, widthScale: 1.1, jerseyColor: '#2E8B57', shortsColor: '#2E8B57', sleeveColor: '#000', headAccessory: 'helmet', hatColor: '#2E8B57', skinTone: '#000', headDetail: 'visor' },
        { id: 'human_raider', animal: 'human', name: 'Aventuri√®re', cost: 15000, heightScale: 1.05, widthScale: 0.95, jerseyColor: '#00CED1', shortsColor: '#8B4513', skinTone: '#f0d5be', hairStyle: 'long', hairColor: '#5D4037', backAccessory: 'backpack', backColor: '#8B4513', shortsLength: 'short' },
        { id: 'human_goku', animal: 'human', name: 'Guerrier Z', cost: 25000, heightScale: 1.1, widthScale: 1.05, jerseyColor: '#FF4500', shortsColor: '#FF4500', sleeveColor: '#000080', skinTone: '#f0d5be', hairStyle: 'spikes', hairColor: '#FFD700', shoesColor: '#000080' },
        { id: 'human_samus', animal: 'human', name: 'Chasseuse Spatiale', cost: 25000, heightScale: 1.15, widthScale: 1.0, jerseyColor: '#FF4500', shortsColor: '#FF4500', headAccessory: 'helmet', hatColor: '#FF0000', headDetail: 'visor', skinTone: '#FFD700', sleeveColor: '#FFD700', shoesColor: '#FFD700' },
        { id: 'hybrid_marsupial', animal: 'human', name: 'Marsupial', cost: 15000, headType: 'bandicoot', heightScale: 1.0, widthScale: 1.0, jerseyType: 'none', shortsColor: '#0000FF', skinTone: '#FFA500', furColor: '#FFA500', shoesColor: '#FF0000' },
        { id: 'hybrid_yeti', animal: 'human', name: 'Y√©ti', cost: 20000, headType: 'yeti', heightScale: 1.3, widthScale: 1.3, jerseyType: 'none', shortsColor: '#FFF', skinTone: '#FFF', furColor: '#FFF' },
        { id: 'hybrid_cyclops', animal: 'human', name: 'Cyclope', cost: 25000, headType: 'cyclops', heightScale: 1.4, widthScale: 1.2, jerseyType: 'none', shortsColor: '#8B4513', skinTone: '#f0d5be' },

        // NEW LEGENDS & CURRENT STARS
        { id: 'human_nash', animal: 'human', name: 'Captain Canada', cost: 35000, heightScale: 1.05, widthScale: 0.88, jerseyColor: '#1D1160', shortsColor: '#1D1160', sideStripesColor: '#E56020', number: '13', numberColor: '#E56020', skinTone: '#f0d5be', hairStyle: 'long', hairColor: '#6B4423', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_dream', animal: 'human', name: 'The Dream', cost: 40000, heightScale: 1.21, widthScale: 0.95, jerseyColor: '#CE1141', shortsColor: '#CE1141', trimColor: '#FDB927', number: '34', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_ewing', animal: 'human', name: 'Big Pat', cost: 35000, heightScale: 1.21, widthScale: 0.95, jerseyColor: '#006BB6', shortsColor: '#006BB6', trimColor: '#F58426', number: '33', numberColor: '#F58426', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_zeke', animal: 'human', name: 'Zeke', cost: 35000, heightScale: 1.02, widthScale: 0.85, jerseyColor: '#006BB6', shortsColor: '#006BB6', sideStripesColor: '#ED174C', number: '11', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_glide', animal: 'human', name: 'The Glide', cost: 35000, heightScale: 1.15, widthScale: 0.92, jerseyColor: '#CE1141', shortsColor: '#CE1141', trimColor: '#000', number: '22', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_truth', animal: 'human', name: 'The Truth', cost: 30000, heightScale: 1.15, widthScale: 1.0, jerseyColor: '#007A33', shortsColor: '#007A33', trimColor: '#000', number: '34', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'headband', hairColor: '#000', headbandColor: '#007A33', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_shuttlesworth', animal: 'human', name: 'Jesus', cost: 30000, heightScale: 1.13, widthScale: 0.9, jerseyColor: '#007A33', shortsColor: '#007A33', trimColor: '#FFF', number: '20', numberColor: '#FFF', skinTone: '#8d5524', hairStyle: 'bald', hairColor: '#000', sleeveLeft: '#007A33', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_klaw', animal: 'human', name: 'The Klaw', cost: 35000, heightScale: 1.15, widthScale: 1.0, jerseyColor: '#000', shortsColor: '#000', sideStripesColor: '#C4CED4', number: '2', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'cornrows', hairColor: '#000', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_wemby', animal: 'human', name: 'L\'Alien', cost: 35000, heightScale: 1.30, widthScale: 0.85, jerseyColor: '#000', shortsColor: '#000', sideStripesColor: '#C4CED4', number: '1', numberColor: '#FFF', skinTone: '#8d5524', hairStyle: 'short', hairColor: '#000', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_sga', animal: 'human', name: 'SGA', cost: 30000, heightScale: 1.14, widthScale: 0.9, jerseyColor: '#007AC1', shortsColor: '#007AC1', sideStripesColor: '#EF3B24', number: '2', numberColor: '#EF3B24', skinTone: '#5c3a21', hairStyle: 'cornrows', hairColor: '#000', headbandColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_brow', animal: 'human', name: 'The Brow', cost: 30000, heightScale: 1.21, widthScale: 0.95, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '3', numberColor: '#552583', skinTone: '#5c3a21', hairStyle: 'afro', hairColor: '#000', beard: true, socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_kyrie', animal: 'human', name: 'Uncle Drew', cost: 30000, heightScale: 1.04, widthScale: 0.9, jerseyColor: '#00538C', shortsColor: '#00538C', sideStripesColor: '#B8C4CA', number: '11', numberColor: '#FFF', skinTone: '#8d5524', hairStyle: 'short', hairColor: '#000', beard: true, socksColor: '#000', shoesColor: '#000' },
        { id: 'human_dame', animal: 'human', name: 'Dame Time', cost: 30000, heightScale: 1.04, widthScale: 0.95, jerseyColor: '#000', shortsColor: '#000', pinstripesColor: '#CE1141', number: '0', numberColor: '#CE1141', skinTone: '#5c3a21', hairStyle: 'short', hairColor: '#000', sleeveLeft: '#000', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_tatum', animal: 'human', name: 'Taco Jay', cost: 30000, heightScale: 1.18, widthScale: 0.95, jerseyColor: '#007A33', shortsColor: '#007A33', trimColor: '#FFF', number: '0', numberColor: '#FFF', skinTone: '#dcb98a', hairStyle: 'short', hairColor: '#000', beard: true, socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_process', animal: 'human', name: 'The Process', cost: 30000, heightScale: 1.25, widthScale: 1.1, jerseyColor: '#006BB6', shortsColor: '#006BB6', trimColor: '#ED174C', number: '21', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#000', beard: true, socksColor: '#FFF', shoesColor: '#000' },

        // FAKE VIDEO GAME CHARACTERS
        { id: 'fake_mario', animal: 'human', name: 'Plombier Rouge', cost: 10000, heightScale: 0.9, widthScale: 1.1, jerseyColor: '#F00', shortsColor: '#00F', number: 'M', numberColor: '#F00', skinTone: '#ffe0bd', hairStyle: 'hat', hairColor: '#3c2415', hatColor: '#F00', clothingDetail: 'overalls', beard: true, beardColor: '#3c2415', socksColor: '#FFF', shoesColor: '#3c2415' },
        { id: 'fake_luigi', animal: 'human', name: 'Plombier Vert', cost: 10000, heightScale: 1.1, widthScale: 0.9, jerseyColor: '#00A000', shortsColor: '#00F', number: 'L', numberColor: '#00A000', skinTone: '#ffe0bd', hairStyle: 'hat', hairColor: '#3c2415', hatColor: '#00A000', clothingDetail: 'overalls', beard: true, beardColor: '#3c2415', socksColor: '#FFF', shoesColor: '#3c2415' },
        { id: 'fake_link', animal: 'human', name: 'Elfe H√©ros', cost: 12000, heightScale: 1.0, widthScale: 0.95, jerseyColor: '#00A000', shortsColor: '#FFF', number: '', numberColor: '#000', skinTone: '#ffe0bd', hairStyle: 'long', hairColor: '#FFD700', headAccessory: 'wizard_hat', hatColor: '#00A000', socksColor: '#FFF', shoesColor: '#3c2415' },
        { id: 'fake_kratos', animal: 'human', name: 'Spartiate', cost: 15000, heightScale: 1.15, widthScale: 1.2, jerseyColor: '#B22222', shortsColor: '#333', number: '', numberColor: '#000', skinTone: '#FFF', hairStyle: 'beard', hairColor: '#333', beard: true, beardColor: '#333', pattern: 'tattoo_red', socksColor: '#333', shoesColor: '#333' },
        { id: 'fake_zeus', animal: 'human', name: 'Dieu Tonnerre', cost: 20000, heightScale: 1.2, widthScale: 1.1, jerseyColor: '#FFF', shortsColor: '#FFF', number: '', numberColor: '#FFD700', skinTone: '#dcb98a', hairStyle: 'curly_long', hairColor: '#FFF', beard: true, beardColor: '#FFF', headAccessory: 'bandana_neck', hatColor: '#FFD700', shoesColor: '#FFD700' },

        // MYTHICAL CREATURES (HYBRIDS)
        { id: 'hybrid_minotaur', animal: 'human', name: 'Minotaure', cost: 25000, headType: 'bull', heightScale: 1.3, widthScale: 1.2, jerseyType: 'none', shortsColor: '#5D4037', skinTone: '#8B4513', furColor: '#8B4513', tailType: 'bull' },
        { id: 'hybrid_gorgon', animal: 'human', name: 'Gorgone', cost: 25000, heightScale: 1.05, widthScale: 1.0, jerseyColor: '#228B22', shortsColor: '#333', skinTone: '#90EE90', hairStyle: 'snakes', hairColor: '#006400', tailType: 'snake' },
        { id: 'hybrid_anubis', animal: 'human', name: 'Anubis', cost: 30000, headType: 'jackal', heightScale: 1.2, widthScale: 0.95, jerseyType: 'none', shortsColor: '#FFF', skinTone: '#000', furColor: '#000', headAccessory: 'gold_bands' }
    ];

    var ANIMALS = ['rat', 'cat', 'dog', 'bear', 'rabbit', 'moose', 'fox', 'wolf', 'lion', 'tiger', 'pig', 'cow', 'monkey', 'penguin', 'human'];

    var SHOOTING_STYLES = [
        // KEPT
        { id: 'classic', name: 'Classique', cost: 0, desc: 'Style standard. √âquilibr√©.', modifiers: {} },
        { id: 'curry', name: 'Chef Curry', cost: 0, desc: 'Tir rapide et fluide.', modifiers: { timingWindow: 0.9 } },

        // NEW REALISTIC (NBA LEGENDS)
        { id: 'jordan', name: 'The GOAT', cost: 0, desc: 'Suspension parfaite, saut maximal.', modifiers: { jumpVelocity: 10.5, timingWindow: 0.85 } },
        { id: 'kobe', name: 'Black Mamba', cost: 0, desc: 'Fadeaway technique et pr√©cis.', modifiers: { timingWindow: 0.8, speed: 1.1 } },
        { id: 'lebron', name: 'King James', cost: 0, desc: 'Tir puissant, recul l√©ger.', modifiers: { jumpVelocity: 10.0, speed: 1.2 } },
        { id: 'kd', name: 'Slim Reaper', cost: 0, desc: 'Rel√¢chement tr√®s haut, impossible √† contrer.', modifiers: { speed: 0.9, timingWindow: 0.95 } },
        { id: 'ray', name: 'Jesus', cost: 0, desc: 'M√©canique robotique parfaite.', modifiers: { speed: 1.4, timingWindow: 0.9 } },
        { id: 'bird', name: 'Larry Legend', cost: 0, desc: 'Tir derri√®re la t√™te, tr√®s pr√©cis.', modifiers: { speed: 0.8, timingWindow: 1.2 } },
        { id: 'dirk', name: 'German Jesus', cost: 0, desc: 'Fadeaway sur une jambe.', modifiers: { timingWindow: 1.0, speed: 0.9 } },
        { id: 'kareem', name: 'Sky Hook', cost: 0, desc: 'Le bras roul√© inarr√™table. (Au sol)', modifiers: { jumpVelocity: 0, speed: 0.8 } },
        { id: 'shaq', name: 'Diesel', cost: 0, desc: 'Tir √† une main rigide.', modifiers: { jumpVelocity: 6, speed: 1.1, timingWindow: 0.7 } },
        { id: 'magic', name: 'Showtime', cost: 0, desc: 'Pouss√©e du ballon, vision de jeu.', modifiers: { speed: 1.0 } },
        { id: 'harden', name: 'The Beard', cost: 0, desc: 'Step-back et pause.', modifiers: { timingWindow: 1.1, speed: 0.9 } },
        { id: 'luka', name: 'Luka Magic', cost: 0, desc: 'Tir lent mais hypnotique.', modifiers: { speed: 0.85, timingWindow: 1.15 } },
        { id: 'klay', name: 'Game 6', cost: 0, desc: 'Forme pure, pas de saut inutile.', modifiers: { speed: 1.3, timingWindow: 0.95 } },
        { id: 'reggie', name: 'Knick Killer', cost: 0, desc: 'Extension compl√®te des bras.', modifiers: { speed: 1.2 } },
        { id: 'westbrook', name: 'Brodie', cost: 0, desc: 'Saut explosif, tir tendu.', modifiers: { jumpVelocity: 11.0, speed: 1.5, timingWindow: 0.6 } },
        { id: 'joker', name: 'Big Honey', cost: 0, desc: 'Tir derri√®re la t√™te. (Au sol)', modifiers: { jumpVelocity: 0, speed: 0.8 } },
        { id: 'trae', name: 'Ice Trae', cost: 0, desc: 'Pouss√©e rapide depuis la poitrine.', modifiers: { speed: 1.3, timingWindow: 0.9 } },
        { id: 'ai', name: 'The Answer', cost: 0, desc: 'Arm√© tr√®s haut derri√®re la t√™te.', modifiers: { speed: 1.4, jumpVelocity: 10.0 } },
        { id: 'melo', name: 'Hoodie Melo', cost: 0, desc: 'Le tir le plus pur.', modifiers: { speed: 1.0, timingWindow: 1.0 } },
        { id: 'haliburton', name: 'Hali', cost: 0, desc: 'Tir bizarre √† deux mains.', modifiers: { speed: 1.1, timingWindow: 0.8 } },
        { id: 'marion', name: 'The Matrix', cost: 0, desc: 'T-Rex shot. Tr√®s moche.', modifiers: { speed: 1.8, timingWindow: 0.7 } },
        { id: 'noah', name: 'Tornado', cost: 0, desc: 'La tornade √† deux mains.', modifiers: { speed: 0.9, jumpVelocity: 8.0 } },
        { id: 'bol', name: 'Manute', cost: 0, desc: 'La catapulte g√©ante.', modifiers: { speed: 0.7, jumpVelocity: 4.0 } },
        { id: 'sga', name: 'Timeline', cost: 0, desc: 'Lent et m√©thodique.', modifiers: { speed: 0.9, timingWindow: 1.1 } },

        // NEW SILLY / GROUNDED
        { id: 'granny', name: 'Rick Barry', cost: 0, desc: '√Ä la cuill√®re. (Au sol)', modifiers: { jumpVelocity: 0, speed: 0.7, timingWindow: 1.5 } },
        { id: 'bowling', name: 'Strike', cost: 0, desc: 'Lancer de bowling. (Au sol)', modifiers: { jumpVelocity: 0, speed: 0.6 } },
        { id: 'hadouken', name: 'Hadouken', cost: 0, desc: 'Boule de feu ! (Au sol)', modifiers: { jumpVelocity: 0, speed: 2.5, timingWindow: 0.5 } },
        { id: 'tpose', name: 'Le Glitch', cost: 0, desc: 'T-Pose mena√ßante. (Au sol)', modifiers: { jumpVelocity: 0, speed: 3.0, timingWindow: 0.3 } },
        { id: 'airbud', name: 'Le Museau', cost: 0, desc: 'Passe de la truffe.', modifiers: { speed: 1.2, jumpVelocity: 8.0 } },
        { id: 'telekinesis', name: 'Psychokin√©sie', cost: 0, desc: 'Par la pens√©e.', modifiers: { jumpVelocity: 0, speed: 2.0, timingWindow: 0.5 } },
        { id: 'peekaboo', name: 'Coucou !', cost: 0, desc: 'O√π est-il ?', modifiers: { jumpVelocity: 0, speed: 0.8 } }
    ];

    // Animation Keyframes (Optimized: Moved to global scope to avoid reallocation)
    const DEFAULT_IDLE = { la: Math.PI/2 - 0.2, ra: Math.PI/2 + 0.2, lfa: Math.PI/2 - 0.1, rfa: Math.PI/2 + 0.1, w: 0 };
    const ANIM_DATA = {
        // --- KEPT ---
        classic: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -2.2, ra: -2.2, lfa: -0.5, rfa: -0.8, w: 0 },
            release: { la: -2.0, ra: -Math.PI/2 - 0.2, lfa: -0.8, rfa: -Math.PI/2 - 0.1, w: 1.0 }
        },
        curry: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.8, rfa: -1.8, w: 0 },
            set: { la: -1.0, ra: -1.2, lfa: -2.5, rfa: -2.8, w: 0.5 },
            release: { la: -1.2, ra: -Math.PI/2 - 0.3, lfa: -2.2, rfa: -Math.PI/2, w: 1.5 }
        },

        // --- NEW REALISTIC ---
        jordan: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.3, ra: -2.5, lfa: -1.2, rfa: -1.6, w: 0 }, // High set
            release: { la: -2.0, ra: -Math.PI/2 - 0.4, lfa: -1.0, rfa: -Math.PI/2 - 0.2, w: 1.6 } // Perfect follow through
        },
        kobe: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.4, ra: -2.4, lfa: -1.5, rfa: -2.6, w: 0 }, // Fadeaway posture
            release: { la: -2.1, ra: -Math.PI/2 - 0.5, lfa: -1.8, rfa: -Math.PI/2 - 0.3, w: 1.7 } // High release
        },
        lebron: {
            ready: { la: 0.4, ra: 2.4, lfa: 1.4, rfa: -1.6, w: 0 },
            set: { la: -2.0, ra: -2.3, lfa: -2.0, rfa: -2.8, w: 0 }, // Power gather
            release: { la: -1.5, ra: -Math.PI/2 - 0.2, lfa: -2.2, rfa: -Math.PI/2, w: 1.5 }
        },
        kd: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -2.6, ra: -2.8, lfa: -2.0, rfa: -2.0, w: 0 }, // Starting high
            release: { la: -2.4, ra: -Math.PI/2 - 0.8, lfa: -1.5, rfa: -Math.PI/2 - 0.6, w: 1.8 } // Super high release point
        },
        ray: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.6, rfa: -1.9, w: 0 },
            set: { la: -2.2, ra: -2.2, lfa: -2.5, rfa: -2.9, w: 0 }, // 90 degree perfect
            release: { la: -2.0, ra: -Math.PI/2 - 0.3, lfa: -2.2, rfa: -Math.PI/2 - 0.1, w: 1.6 } // Snap
        },
        bird: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -2.8, ra: -3.0, lfa: -1.5, rfa: -1.5, w: 0.5 }, // Behind head
            release: { la: -2.5, ra: -Math.PI/2 - 0.1, lfa: -1.2, rfa: -Math.PI/2, w: 1.2 }
        },
        dirk: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -2.5, ra: -2.5, lfa: -1.5, rfa: -1.5, w: 0 }, // High hold
            release: { la: -2.3, ra: -Math.PI/2, lfa: -1.3, rfa: -Math.PI/2, w: 1.0 } // Soft touch
        },
        kareem: {
            ready: { la: 1.0, ra: 1.0, lfa: 1.5, rfa: 1.5, w: 0 },
            set: { la: 0.5, ra: 0.0, lfa: 2.0, rfa: -2.0, w: 0 }, // Side windup
            release: { la: 0.5, ra: -Math.PI + 0.5, lfa: 1.5, rfa: -Math.PI, w: 0.5 } // Hook extension
        },
        shaq: {
            ready: { la: 0.5, ra: 2.0, lfa: 1.5, rfa: -1.5, w: 0 },
            set: { la: -1.5, ra: -2.0, lfa: -0.5, rfa: -1.0, w: 0 }, // Bulky set
            release: { la: -1.0, ra: -Math.PI/2, lfa: -0.5, rfa: -1.0, w: 0.5 } // Push, no wrist flick
        },
        magic: {
            ready: { la: 0.5, ra: 2.4, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -1.8, ra: -1.8, lfa: -0.5, rfa: -0.5, w: 0 }, // Chest push start
            release: { la: -1.5, ra: -Math.PI/2 + 0.2, lfa: -0.8, rfa: -Math.PI/2 + 0.2, w: 1.0 }
        },
        harden: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -1.5, ra: -1.5, lfa: -2.5, rfa: -2.5, w: 0 }, // Low gather
            release: { la: -1.8, ra: -Math.PI/2 - 0.4, lfa: -2.0, rfa: -Math.PI/2 - 0.2, w: 1.5 }
        },
        luka: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.0, ra: -2.2, lfa: -1.0, rfa: -1.8, w: 0.2 }, // Slow windup
            release: { la: -1.8, ra: -Math.PI/2 - 0.3, lfa: -1.2, rfa: -Math.PI/2, w: 1.4 }
        },
        klay: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.1, ra: -2.1, lfa: -2.3, rfa: -2.6, w: 0 }, // Compact
            release: { la: -2.0, ra: -Math.PI/2 - 0.2, lfa: -2.1, rfa: -Math.PI/2, w: 1.5 }
        },
        reggie: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.2, ra: -2.2, lfa: -2.5, rfa: -2.9, w: 0 },
            release: { la: -1.5, ra: -Math.PI/2 - 0.2, lfa: -1.5, rfa: -Math.PI/2 - 0.4, w: 1.5 } // Arms cross slightly
        },
        westbrook: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.5, ra: -2.8, lfa: -2.0, rfa: -2.5, w: 0 }, // High jump point
            release: { la: -2.3, ra: -Math.PI/2 - 0.6, lfa: -2.2, rfa: -Math.PI/2 - 0.4, w: 2.0 } // Aggressive snap
        },
        joker: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -1.2, ra: -3.0, lfa: -2.3, rfa: -2.2, w: 0 }, // Deep behind head
            release: { la: -1.5, ra: -Math.PI/2 - 0.1, lfa: -2.0, rfa: -Math.PI/2, w: 0.8 } // Lazy flick
        },
        trae: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -1.2, ra: -1.2, lfa: -2.5, rfa: -2.5, w: 0.5 }, // Low push
            release: { la: -1.0, ra: -1.0, lfa: -2.2, rfa: -1.5, w: 1.0 } // Push forward
        },
        ai: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -1.4, ra: -3.0, lfa: -2.5, rfa: -2.5, w: 0 }, // Way back
            release: { la: -1.8, ra: -Math.PI/2 - 0.5, lfa: -2.2, rfa: -Math.PI/2 - 0.3, w: 1.8 } // Snap
        },
        melo: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.3, ra: -2.3, lfa: -2.0, rfa: -2.6, w: 0 }, // Textbook
            release: { la: -2.1, ra: -Math.PI/2 - 0.3, lfa: -1.8, rfa: -Math.PI/2 - 0.1, w: 1.5 }
        },
        haliburton: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -1.5, ra: -1.5, lfa: -1.5, rfa: -1.5, w: 0 }, // Both hands low
            release: { la: -1.5, ra: -1.2, lfa: -1.5, rfa: -1.2, w: 1.0 } // Push shot
        },
        marion: {
            ready: { la: 0.5, ra: 2.5, lfa: 2.0, rfa: -2.0, w: 0 },
            set: { la: -1.0, ra: -1.2, lfa: -2.8, rfa: -2.8, w: 0 }, // T-Rex
            release: { la: -0.8, ra: -0.8, lfa: -2.5, rfa: -0.5, w: 0.2 } // Tiny flick
        },
        noah: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -1.8, ra: -1.8, lfa: 0.5, rfa: -0.5, w: 1.0 }, // Tornado spin
            release: { la: -1.5, ra: -0.8, lfa: 0.2, rfa: -0.2, w: 0 }
        },
        bol: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.8, ra: -3.0, lfa: -1.5, rfa: -1.8, w: 0 }, // Far back
            release: { la: -2.5, ra: -1.5, lfa: -1.2, rfa: -1.2, w: 0.5 } // Catapult
        },
        sga: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -1.8, ra: -2.0, lfa: -1.5, rfa: -1.8, w: 0.2 }, // Slow methodical
            release: { la: -1.6, ra: -Math.PI/2 - 0.2, lfa: -1.2, rfa: -Math.PI/2, w: 1.2 }
        },

        // --- NEW SILLY / GROUNDED ---
        granny: {
            ready: { la: 0.8, ra: 0.8, lfa: 2.0, rfa: 2.0, w: 0 },
            set: { la: 1.0, ra: 1.2, lfa: 2.2, rfa: 2.2, w: 0 }, // Low between legs
            release: { la: -1.0, ra: -1.0, lfa: 0.5, rfa: 0.5, w: 0 } // Scoop up
        },
        bowling: {
            ready: { la: 0.2, ra: 1.5, lfa: 2.0, rfa: 1.0, w: 0 },
            set: { la: 0.2, ra: 2.8, lfa: 2.0, rfa: 2.9, w: 0 }, // Backswing
            release: { la: 0.2, ra: -1.8, lfa: 1.0, rfa: -0.2, w: 0 } // Roll forward
        },
        hadouken: {
            ready: { la: 1.5, ra: 1.5, lfa: 2.5, rfa: 0.5, w: 0 },
            set: { la: 1.8, ra: 1.8, lfa: 2.9, rfa: 0.4, w: 0 }, // Charge at hip
            release: { la: -1.5, ra: -1.6, lfa: -0.1, rfa: -0.1, w: 0 } // Thrust
        },
        tpose: {
            ready: { la: 0, ra: 0, lfa: 0, rfa: 0, w: 0 },
            set: { la: 0, ra: 0, lfa: 0, rfa: 0, w: 0 },
            release: { la: 0, ra: 0, lfa: 0, rfa: 0, w: 0 } // Dominance
        },
        airbud: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 }, // Holding ball (Classic Ready)
            set: { la: 1.3, ra: 1.8, lfa: 1.3, rfa: 1.8, w: 0 }, // Paws drop down (Tuck)
            release: { la: 1.5, ra: 1.6, lfa: 1.5, rfa: 1.6, w: 0 } // Stay down
        },
        telekinesis: {
            ready: { la: 1.5, ra: 1.6, lfa: 1.5, rfa: 1.6, w: 0 }, // Sides
            set: { la: -2.0, ra: -1.1, lfa: -0.5, rfa: -2.6, w: 0 }, // Temples
            release: { la: -0.5, ra: -2.6, lfa: -0.5, rfa: -2.6, w: 0 } // Fling Out
        },
        peekaboo: {
            ready: { la: -2.0, ra: -1.1, lfa: -0.5, rfa: -2.6, w: 0 }, // Hands on face
            set: { la: -2.0, ra: -1.1, lfa: -0.5, rfa: -2.6, w: 0 }, // Still on face
            release: { la: -0.5, ra: -2.6, lfa: -0.5, rfa: -2.6, w: 0 } // Fling Out
        }
    };

    // Center of screen is 1066/2 = 533.
    // Shift hoop to x=600 is fine (slightly right),
    // but we might want to center the "court path" a bit more.
    const HOOP_POS = { x: 733, y: 150, z: 130 }; // Moved +133 to account for +266 width
    const PIXELS_PER_FOOT = 4.2426;

    var decors = [];
    // Increased range to ~120,000 pixels (approx 28,000 feet) to cover late game
    // Increased count to 4000 to maintain density
    for(let i=0; i<4000; i++) {
        const dist = Math.random() * 120000;
        const pathX = 733 - (dist * 0.7);
        const pathY = 150 + (dist * 0.7);
        const scatter = (Math.random() - 0.5) * 1200;

        const dX = pathX + scatter;
        const dY = pathY + scatter;

        // Safety Corridor Check: Prevent objects between player (sum=600) and hoop (sum=750)
        // Player Width ~30 units. Safety = 1.5x (~45).
        // Corridor: [600 - 60, 750 + 60] -> [540, 810]
        const sum = dX + dY;
        if (sum > 540 && sum < 810) continue;

        const dDist = Math.sqrt(Math.pow(dX - HOOP_POS.x, 2) + Math.pow(dY - HOOP_POS.y, 2));

        // Convert Pixel Distance to Game Feet for Zone Lookup
        const feetDist = dDist / PIXELS_PER_FOOT;

        const decorZone = COURT_ZONES.find(z => feetDist < z.limit) || COURT_ZONES[COURT_ZONES.length-1];
        let variant = 'default';
        if(decorZone.type === 'tree') {
             variant = (decorZone.name.includes("FOR√äT") || decorZone.name.includes("MONT")) ? 'pine' : 'oak';
        }
        decors.push({ x: dX, y: dY, dist: dist, zoneType: decorZone.type, variant: variant, seed: Math.random() });
    }

    // TACO CAT: One per zone guaranteed
    for(let i=0; i<COURT_ZONES.length; i++) {
        const z = COURT_ZONES[i];
        const prevLimit = (i === 0) ? 0 : COURT_ZONES[i-1].limit;
        const range = Math.min(z.limit, prevLimit + 3000) - prevLimit; // Cap range slightly for large zones

        const dist = prevLimit + Math.random() * range; // This is FEET

        // Convert Feet to Pixels for Coordinate Calculation
        const pixelDist = dist * PIXELS_PER_FOOT;

        const pathX = 733 - (pixelDist * 0.7);
        const pathY = 150 + (pixelDist * 0.7);

        let dX, dY;
        let attempts = 0;
        do {
            const scatter = (Math.random() - 0.5) * 1000;
            dX = pathX + scatter;
            dY = pathY + scatter;
            attempts++;
        } while (attempts < 10 && (dX + dY > 540 && dX + dY < 810));

        decors.push({ x: dX, y: dY, dist: pixelDist, zoneType: 'tacocat', variant: 'default', seed: Math.random() });
    }

    // OPTIMIZATION: Sort decors by distance from hoop to allow early exit in render loop
    decors.sort((a, b) => a.dist - b.dist);

    var clouds = [];
    var mountainLayers = [];

    function initBackgroundElements() {
        // Clouds
        clouds = [];
        for(let i=0; i<8; i++) {
            let c = {
                x: Math.random() * 2000,
                y: Math.random() * 200,
                speed: 0.1 + Math.random() * 0.2,
                scale: 0.8 + Math.random() * 0.8,
                puffs: []
            };
            let numPuffs = 4 + Math.floor(Math.random() * 5);
            for(let j=0; j<numPuffs; j++) {
                c.puffs.push({
                    dx: (Math.random() - 0.5) * 60,
                    dy: (Math.random() - 0.5) * 30,
                    r: 25 + Math.random() * 25
                });
            }
            clouds.push(c);
        }

        // Mountain Layers
        mountainLayers = [];
        const colors = ['#2F4F4F', '#243b3b', '#162424'];
        const baseHeights = [250, 180, 120];
        const speeds = [0.02, 0.05, 0.1];

        for(let L=0; L<3; L++) {
            let points = [];
            let x = 0;
            let y = Math.random() * baseHeights[L];
            // Generate a looped path
            while(x <= 2200) { // Enough for screen width + shift
                 points.push({x: x, y: y});
                 x += 40 + Math.random() * 60;
                 y += (Math.random() - 0.5) * 100;
                 if(y < 50) y = 50; if(y > baseHeights[L] + 100) y = baseHeights[L] + 100;
            }
            // Smooth loop?
            points[points.length-1].y = points[0].y;
            mountainLayers.push({ points: points, color: colors[L], speed: speeds[L] });
        }
    }
    initBackgroundElements();

    var bgCache = null;

    // --- OPTIMIZATION: Render Object Pooling ---
    // Monomorphic class for V8 optimization
    class RenderItem {
        constructor() {
            this.type = null;
            this.depth = 0;
            this.proj = null;
            this.zoneType = null;
            this.variant = null;
            this.seed = 0;
            this.alpha = 0;
        }
    }

    const g_renderItemPool = [];
    const g_renderList = [];
    let g_poolIndex = 0;

    function getRenderItem() {
        let obj;
        if (g_poolIndex < g_renderItemPool.length) {
            obj = g_renderItemPool[g_poolIndex];
        } else {
            obj = new RenderItem();
            g_renderItemPool.push(obj);
        }
        g_poolIndex++;
        return obj;
    }

    // Pre-allocate some objects
    for(let i=0; i<1000; i++) {
        g_renderItemPool.push(new RenderItem());
    }

    // --- OPTIMIZATION: Fuzzy Noise Lookup Table ---
    const NOISE_LUT_SIZE = 4096;
    const g_noiseLUT = new Float32Array(NOISE_LUT_SIZE);
    for (let i = 0; i < NOISE_LUT_SIZE; i++) {
        g_noiseLUT[i] = Math.random();
    }

    // --- 2. GLOBAL VARIABLES ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Optimization: Pre-calculated Sun Gradient
    const sunGradient = ctx.createRadialGradient(700, 80, 0, 700, 80, 80);
    sunGradient.addColorStop(0, '#FFD700');
    sunGradient.addColorStop(0.5, '#FFD700'); // Solid core (r=40)
    sunGradient.addColorStop(0.6, 'rgba(255, 165, 0, 0.5)'); // Glow start
    sunGradient.addColorStop(1, 'rgba(255, 165, 0, 0)'); // Fade out

    const scoreEl = document.getElementById('scoreVal');
    const distEl = document.getElementById('distVal');
    const highScoreEl = document.getElementById('highScoreVal');
    const shopUI = document.getElementById('shopUI');
    const achUI = document.getElementById('achUI');
    const statsUI = document.getElementById('statsUI');
    const notif = document.getElementById('notification');
    const courtNameEl = document.getElementById('courtNameDisplay');
    const missValEl = document.getElementById('missVal');
    const container = document.getElementById('game-container');
    const contestUI = document.getElementById('contest-ui');
    const strikesEl = document.getElementById('strikes');
const contestTimeEl = document.getElementById('contestTime');
const contestScoreEl = document.getElementById('contestScore');
const contestRackEl = document.getElementById('contestRack');

    canvas.width = 1066;
    canvas.height = 600;

    let viewingAnimalIndex = 0;
    let viewingSkinIndex = 0;
    let viewingStyleIndex = 0;
    let currentGameMode = 'CLASSIC';
    let contestData = { timer: 60, score: 0, rack: 1, ballsInRack: 0, isActive: false };
let lastDisplayedContestTime = -1;
    let distanceLevel = 1;
    let state = 'IDLE';
    let feedback = "";
    let feedbackTimer = 0;
    let consecutiveMisses = 0;
    let currentStreak = 0;
    let spacePressed = false;
    let cameraZoom = 800;
    let cameraHeight = 300;
    let g_camCache = null; // Optimization: Per-frame camera cache
    let resetStage = 0;
    let isGroundedShot = false;
    let groundShotTimer = 0;

    // Physique
    const GRAVITY = 0.5;
    const DEBUG = false;
    // Shift player start position to match new center (300 -> 433)
    let player3D = { x: 433, y: 300, z: 0, vz: 0 };
    let ball = { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, active: false, isFire: false };
    let particles = [];

    // Expose for debugging
    if (DEBUG) {
        window.player3D = player3D;
        window.state = state;
    }

    const defaultData = {
        tacos: 0, level: 1, difficulty: 1.0, highScore: 10,
        stats: { income: 1, aim: 1, luck: 1, moonwalk: 1, extraLives: 0 },
        purchasedStats: { income: 1, aim: 1, luck: 1, moonwalk: 1, extraLives: 0 },
        lifetimeStats: { shots: 0, makes: 0, misses: 0, contests: 0 },
        unlockedSkins: ['rat_classic'], currentSkin: 'rat_classic', unlockedAchievements: [],
        unlockedStyles: ['classic'], currentStyle: 'classic', isLefty: false,
        mobileControls: false, platformChosen: false,
        meterEnabled: true, meterShape: 'arc'
    };

    let savedData = localStorage.getItem('tacoSaveData');
    let playerData = savedData ? JSON.parse(savedData) : JSON.parse(JSON.stringify(defaultData));

    // Migration logic to fix old saves
    if(!playerData.unlockedAchievements) playerData.unlockedAchievements = [];
    if(!playerData.stats.income) playerData.stats.income = 1;
    if(!playerData.stats.moonwalk) playerData.stats.moonwalk = 1;
    if(typeof playerData.stats.extraLives === 'undefined') playerData.stats.extraLives = 0;
    if(!playerData.lifetimeStats) playerData.lifetimeStats = { shots: 0, makes: 0, misses: 0, contests: 0 };
    if(!playerData.unlockedSkins) playerData.unlockedSkins = ['rat_classic'];
    if(!playerData.currentSkin) playerData.currentSkin = 'rat_classic';
    if(!playerData.unlockedStyles) playerData.unlockedStyles = ['classic'];
    if(!playerData.currentStyle) playerData.currentStyle = 'classic';
    if(typeof playerData.isLefty === 'undefined') playerData.isLefty = false;
    if(typeof playerData.platformChosen === 'undefined') playerData.platformChosen = false;
    if(typeof playerData.meterEnabled === 'undefined') playerData.meterEnabled = true;
    if(typeof playerData.meterShape === 'undefined') playerData.meterShape = 'arc';

    // Migration: purchasedStats
    if (!playerData.purchasedStats) {
        playerData.purchasedStats = {
            income: playerData.stats.income || 1,
            aim: playerData.stats.aim || 1,
            luck: playerData.stats.luck || 1,
            moonwalk: playerData.stats.moonwalk || 1,
            extraLives: (typeof playerData.stats.extraLives !== 'undefined') ? playerData.stats.extraLives : 0
        };
    }

    // Don't auto-set mobileControls here anymore, wait for choice if not chosen
    window.playerData = playerData;

    highScoreEl.innerText = playerData.highScore + " pi";

    // --- 3. HELPER FUNCTIONS ---
    function saveData() { localStorage.setItem('tacoSaveData', JSON.stringify(playerData)); }

    function calculateShotThreshold() {
        const styleId = playerData.currentStyle || 'classic';
        const style = SHOOTING_STYLES.find(s => s.id === styleId) || SHOOTING_STYLES[0];
        const mods = style.modifiers;

        let aimBonus = (playerData.stats.aim - 1);
        let baseDampener = 6.0;
        if (currentGameMode === 'CONTEST') { aimBonus *= 0.2; baseDampener = 4.5; }
        let dampener = baseDampener + aimBonus;

        if(mods.timingWindow) dampener *= mods.timingWindow;

        // Note: We do NOT apply the 1.2x 'no-meter' bonus here.
        // This function returns the standard physical threshold (meter visible difficulty).
        // The shooter function applies the bonus on top if the meter is actually disabled.

        if (dampener > 36.0) dampener = 36.0;

        const distPenalty = 1.0 + Math.pow(distanceLevel, 1.25) * 0.06;
        let finalDistPenalty = distPenalty;
        if(mods.rangeBonus) finalDistPenalty = 1.0 + (distPenalty - 1.0) * (1.0 - mods.rangeBonus);

        // accuracy = (timingError / dampener) * difficulty * finalDistPenalty
        // success condition: |accuracy| <= 0.25
        // |timingError| <= 0.25 * dampener / (difficulty * finalDistPenalty)

        return (0.25 * dampener) / (playerData.difficulty * finalDistPenalty);
    }

    function getCurrentVz() {
        if (isGroundedShot) {
            return 9 - (groundShotTimer * 0.5);
        }
        return player3D.vz;
    }

    function drawShotMeter(cx, cy, radius, s, progress, greenStart, shape) {
        // Shapes: 'arc', 'vertical', 'horizontal'
        ctx.lineCap = 'round';

        if (shape === 'vertical') {
            const h = radius * 3;
            const w = 15 * s;
            const x = cx + radius; // Offset to right
            const y = cy - h/2;

            // Background
            ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = w;
            ctx.moveTo(x, y + h); ctx.lineTo(x, y); ctx.stroke();

            // Green Zone
            ctx.beginPath(); ctx.strokeStyle = 'rgba(0,255,0,0.4)'; ctx.lineWidth = w;
            ctx.moveTo(x, y + h * (1-greenStart)); ctx.lineTo(x, y); ctx.stroke();

            // Actual Bar
            let color = '#FF4500';
            if (progress > greenStart) color = '#00FF00'; else if (progress > 0.6) color = '#FFFF00';

            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = w * 0.8;
            ctx.moveTo(x, y + h); ctx.lineTo(x, y + h * (1-progress)); ctx.stroke();

        } else if (shape === 'horizontal') {
            const w = radius * 3;
            const h = 15 * s;
            const x = cx - w/2;
            const y = cy + radius; // Offset below

            // Background
            ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = h;
            ctx.moveTo(x, y); ctx.lineTo(x + w, y); ctx.stroke();

            // Green Zone
            ctx.beginPath(); ctx.strokeStyle = 'rgba(0,255,0,0.4)'; ctx.lineWidth = h;
            ctx.moveTo(x + w * greenStart, y); ctx.lineTo(x + w, y); ctx.stroke();

            // Actual Bar
            let color = '#FF4500';
            if (progress > greenStart) color = '#00FF00'; else if (progress > 0.6) color = '#FFFF00';

            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = h * 0.8;
            ctx.moveTo(x, y); ctx.lineTo(x + w * progress, y); ctx.stroke();

        } else {
            // ARC (Default)
            ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 10*s;
            ctx.arc(cx, cy, radius, 0, -Math.PI / 2, true); ctx.stroke();

            ctx.beginPath(); ctx.strokeStyle = 'rgba(0,255,0,0.4)'; ctx.lineWidth = 10*s;
            ctx.arc(cx, cy, radius, -Math.PI/2 * Math.max(0, greenStart), -Math.PI/2, true); ctx.stroke();

            let color = '#FF4500';
            if (progress > greenStart) color = '#00FF00'; else if (progress > 0.6) color = '#FFFF00';

            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 8*s;
            ctx.arc(cx, cy, radius, 0, -Math.PI/2 * progress, true); ctx.stroke();
        }
    }

    function getScaleObject(dist) { return SCALE_OBJECTS.find(o => dist < o.limit) || SCALE_OBJECTS[SCALE_OBJECTS.length-1]; }
    function getCourtDetails(dist) { return COURT_ZONES.find(z => dist < z.limit) || COURT_ZONES[COURT_ZONES.length-1]; }
    function getJoint(x, y, length, angle) { return { x: x + Math.cos(angle) * length, y: y + Math.sin(angle) * length }; }
    function invalidateBackgroundCache() { bgCache = null; }

    function resizeGame() {
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        // Target 16:9 ratio (1066x600)
        // If we want NO gap, we should cover. But "filling up" often implies "contain" without bars if ratio matches.
        // The user said "16:9 equivalent ... no distortion ... filling up screen".
        // Since most phones are wider than 16:9, we should stick to CONTAIN logic (Math.min) to ensure everything is visible.
        // However, removing the 0.95 margin (done previously) is key.
        const scale = Math.min(winW / 1066, winH / 600);
        container.style.transform = `translate(-50%, -50%) scale(${scale})`;
        invalidateBackgroundCache();
    }
    window.addEventListener('resize', resizeGame);

    function project(x, y, z, cache) {
        let rotation, sinRot, cosRot;

        if (cache) {
            rotation = cache.rotation;
            sinRot = cache.sinRot;
            cosRot = cache.cosRot;
            cameraZoom = cache.cameraZoom;
            cameraHeight = cache.cameraHeight;
        } else if (g_camCache) {
            rotation = g_camCache.rotation;
            sinRot = g_camCache.sinRot;
            cosRot = g_camCache.cosRot;
            cameraZoom = g_camCache.cameraZoom;
            cameraHeight = g_camCache.cameraHeight;
        } else {
            const dxToHoop = HOOP_POS.x - player3D.x;
            const dyToHoop = HOOP_POS.y - player3D.y;
            cameraZoom = 698;
            cameraHeight = 84000 / cameraZoom;
            const angleToHoop = Math.atan2(dyToHoop, dxToHoop);
            rotation = -angleToHoop - Math.PI/2;
            sinRot = Math.sin(rotation);
            cosRot = Math.cos(rotation);
        }

        const dx = x - player3D.x; const dy = y - player3D.y;
        const rx = dx * cosRot - dy * sinRot;
        const ry = dx * sinRot + dy * cosRot;
        const cameraOffset = 400; const depth = cameraOffset - ry;
        if (depth <= 0) return null;
        const scale = cameraZoom / depth;
        const screenX = canvas.width / 2 + (rx * scale);
        const horizonY = (canvas.height - 120) * 0.5;
        const screenY = horizonY + (cameraHeight - z) * scale;
        return { x: screenX, y: screenY, scale: scale, depth: depth };
    }

    // --- 4. DRAWING FUNCTIONS ---
    function drawFlightTracker() {
        const h = 120;
        const y = canvas.height - h;
        ctx.fillStyle = '#111'; ctx.fillRect(0, y, canvas.width, h);
        ctx.fillStyle = '#222'; ctx.fillRect(0, y + h/2, canvas.width, h/2);
        const dist = 10 + (distanceLevel * 5);
        const scaleObj = getScaleObject(dist);
        ctx.font = "bold 20px 'Segoe UI'"; ctx.fillStyle = "#FFD700"; ctx.textAlign = "center";
        if (currentGameMode === 'CLASSIC') {
            ctx.fillText(`Distance: ${dist} pi`, canvas.width/2, y + 30);
            ctx.font = "italic 16px 'Segoe UI'"; ctx.fillStyle = "#aaa";
            ctx.fillText(`(√âquivalent: ${scaleObj.name})`, canvas.width/2, y + 55);
        } else {
             ctx.fillText(`CONCOURS 3 POINTS`, canvas.width/2, y + 30);
        }
        const margin = 100; const lineY = y + 80; const lineLen = canvas.width - (margin * 2);
        ctx.strokeStyle = '#555'; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(margin, lineY); ctx.lineTo(margin + lineLen, lineY); ctx.stroke();
        ctx.font = "30px Arial"; ctx.textAlign="center";
        ctx.fillText("‚õπÔ∏è", margin, lineY + 10); ctx.fillText("üèÄ", margin + lineLen, lineY + 10);
        if (currentGameMode === 'CLASSIC') { ctx.globalAlpha = 0.3; ctx.font = "60px Arial"; ctx.fillText(scaleObj.icon, canvas.width/2, lineY); ctx.globalAlpha = 1.0; }
        if(state === 'SHOOTING' && ball.active) {
            const dx = HOOP_POS.x - player3D.x; const dy = HOOP_POS.y - player3D.y;
            const totalDist = Math.sqrt(dx*dx + dy*dy);
            const ballDx = ball.x - player3D.x; const ballDy = ball.y - player3D.y;
            const currentDist = Math.sqrt(ballDx*ballDx + ballDy*ballDy);
            let progress = currentDist / totalDist;
            const zFactor = ball.z / 300;
            const ballX = margin + (progress * lineLen);
            const ballY = lineY - (zFactor * 50);
            ctx.fillStyle = ball.isFire ? '#FF4500' : '#ff6600';
            ctx.beginPath(); ctx.arc(ballX, ballY, 5, 0, Math.PI*2); ctx.fill();
        }
    }

    function drawBallSprite(x, y, scale, isFire = false) {
        let color1 = '#ff6600'; let color2 = '#cc5500';
        let key = 'ball_default';

        if(currentGameMode === 'CONTEST' && contestData.ballsInRack === 4) {
            color1 = '#FFFFFF'; color2 = '#0000FF'; key = 'ball_money';
        } else if (isFire) {
            color1 = '#FFFF00'; color2 = '#FF0000'; key = 'ball_fire';
        }

        const fillStyle = getCachedPattern(key, (gradCtx, size) => {
            const r = size / 2;
            const grad = gradCtx.createRadialGradient(r*0.8, r*0.8, 1, r, r, r);
            grad.addColorStop(0, color1);
            grad.addColorStop(1, color2);
            gradCtx.fillStyle = grad;
            gradCtx.fillRect(0, 0, size, size);
        });

        ctx.fillStyle = fillStyle;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1 * scale;

        ctx.beginPath(); ctx.arc(x, y, 8 * scale, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.beginPath(); ctx.arc(x, y, 8 * scale, 0, Math.PI*2); ctx.stroke();

        if(currentGameMode === 'CONTEST' && contestData.ballsInRack === 4) { ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 2 * scale; }
        else if (isFire) { ctx.strokeStyle = '#FFFF00'; ctx.lineWidth = 2 * scale; }

        ctx.beginPath(); ctx.moveTo(x - 8*scale, y); ctx.quadraticCurveTo(x, y + 4*scale, x + 8*scale, y); ctx.stroke();
    }

    function drawBall(p) {
        if (!p) return;
        drawBallSprite(p.x, p.y, p.scale, ball.isFire);
    }

    function drawDetachedBall(p, s, torsoY, bodyH, headY) {
         const isDetachedStyle = ['airbud', 'telekinesis'].includes(playerData.currentStyle);
         if (isDetachedStyle && state !== 'SHOOTING' && state !== 'GAMEOVER') {
             let bx = p.x;
             let by = torsoY + bodyH * 0.5;

             let lift = 0;
             if (state === 'JUMPING') {
                 const sId = playerData.currentStyle || 'classic';
                 const sObj = SHOOTING_STYLES.find(x => x.id === sId) || SHOOTING_STYLES[0];
                 const maxVz = (sObj.modifiers.jumpVelocity !== undefined) ? sObj.modifiers.jumpVelocity : 9;
                 const div = (maxVz < 1) ? 9 : maxVz;
                 lift = Math.min(1.0, Math.max(0, (div - getCurrentVz()) / div));
             }

             if (playerData.currentStyle === 'airbud') {
                 const startX = p.x + (playerData.isLefty ? -10*s : 10*s);
                 const startY = torsoY + bodyH * 0.5;
                 const endX = p.x;
                 const endY = headY - 4*s;

                 bx = startX + (endX - startX) * lift;
                 by = startY + (endY - startY) * lift;
                 by -= Math.sin(lift * Math.PI) * 15 * s;
             }
             else if (playerData.currentStyle === 'telekinesis') {
                 const startY = torsoY + bodyH * 0.2;
                 const endY = headY - 45*s;
                 bx = p.x;
                 by = startY + (endY - startY) * lift;
                 if (lift > 0.8) {
                     bx += (Math.random() - 0.5) * 4 * s;
                     by += (Math.random() - 0.5) * 4 * s;
                 }
             }

             drawBallSprite(bx, by, s, (currentStreak >= 5));
         }
    }

    function drawSmoke(p, alpha) {
        const s = p.scale;
        ctx.fillStyle = `rgba(220, 220, 220, ${alpha * 0.6})`;
        ctx.beginPath(); ctx.arc(p.x, p.y, 15 * s, 0, Math.PI*2); ctx.fill();
    }

    // --- FUR & ANATOMY HELPERS ---
    function drawFuzzyPath(points, color, scale, close = true, seed = 1, justPath = false) {
        if(points.length < 2) return;
        ctx.beginPath();
        const fuzz = 3 * scale;

        for (let i = 0; i < points.length; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % points.length];
            if (!close && i === points.length - 1) break;

            const dist = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
            const segments = Math.max(2, Math.floor(dist / (4 * scale)));

            if(i===0) ctx.moveTo(p1.x, p1.y);

            // Using LUT for performance optimization
            let idxX = (seed + i * 100) & (NOISE_LUT_SIZE - 1);
            let idxY = (seed + i * 100 + 5000) & (NOISE_LUT_SIZE - 1);

            for(let j=1; j<=segments; j++) {
                const t = j / segments;
                const tx = p1.x + (p2.x - p1.x) * t;
                const ty = p1.y + (p2.y - p1.y) * t;

                // Advance LUT indices
                idxX = (idxX + 1) & (NOISE_LUT_SIZE - 1);
                idxY = (idxY + 1) & (NOISE_LUT_SIZE - 1);

                const noiseX = (g_noiseLUT[idxX] - 0.5) * fuzz;
                const noiseY = (g_noiseLUT[idxY] - 0.5) * fuzz;
                ctx.lineTo(tx + noiseX, ty + noiseY);
            }
        }
        if(close) ctx.closePath();

        if (justPath) return;

        ctx.fillStyle = color;
        ctx.fill();
        // Add texture
        ctx.save();
        ctx.clip();
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.lineWidth = 1 * scale;
        const b = getBounds(points);
        const area = (b.maxX - b.minX) * (b.maxY - b.minY);
        const dens = Math.floor(area / (100 * scale * scale)); // Approximate density
        ctx.beginPath();

        const rangeX = b.maxX - b.minX;
        const rangeY = b.maxY - b.minY;

        // LUT indices for texture
        let lutIdx1 = (seed + 200) & (NOISE_LUT_SIZE - 1);
        let lutIdx2 = (seed + 300) & (NOISE_LUT_SIZE - 1);
        let lutIdx3 = (seed + 400) & (NOISE_LUT_SIZE - 1);

        for(let k=0; k<dens; k++) {
            const r1 = g_noiseLUT[lutIdx1];
            const r2 = g_noiseLUT[lutIdx2];

            // Prime steps to avoid sync
            lutIdx1 = (lutIdx1 + 13) & (NOISE_LUT_SIZE - 1);
            lutIdx2 = (lutIdx2 + 17) & (NOISE_LUT_SIZE - 1);

            const rx = b.minX + r1 * rangeX;
            const ry = b.minY + r2 * rangeY;

            ctx.moveTo(rx, ry);
            const r3 = g_noiseLUT[lutIdx3];
            lutIdx3 = (lutIdx3 + 19) & (NOISE_LUT_SIZE - 1);
            ctx.lineTo(rx + (r3-0.5)*5*scale, ry + 5*scale);
        }
        ctx.stroke();
        ctx.restore();
    }

    function getBounds(points) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        points.forEach(p => { if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; });
        return {minX, minY, maxX, maxY};
    }

    // --- OPTIMIZATION: Render Pools ---
    const CIRCLE_SEGS = 16;
    const g_circlePoints = [];
    for(let i=0; i<CIRCLE_SEGS; i++) { g_circlePoints.push({x: 0, y: 0}); }

    const g_limbPoints = [{x:0,y:0}, {x:0,y:0}, {x:0,y:0}, {x:0,y:0}];

    const drawFuzzyCircle = (cx, cy, r, c, seed = 50, scale = 1.0, furry = true) => {
        if(!furry) { ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fillStyle = c; ctx.fill(); return; }

        for(let i=0; i<CIRCLE_SEGS; i++) {
            const a = (i/CIRCLE_SEGS)*Math.PI*2;
            const p = g_circlePoints[i];
            p.x = cx + Math.cos(a)*r;
            p.y = cy + Math.sin(a)*r;
        }
        drawFuzzyPath(g_circlePoints, c, scale, true, seed);
    };

    function drawFuzzyLimb(x1, y1, x2, y2, width, color, scale, isFurry, seed = 1) {
        if(!isFurry) {
            drawLimb(x1, y1, x2, y2, width, color);
            return;
        }
        // Construct polygon for limb
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const dx = Math.sin(angle) * (width / 2);
        const dy = Math.cos(angle) * (width / 2);

        // Use Pool
        const p1 = g_limbPoints[0]; p1.x = x1 - dx; p1.y = y1 + dy;
        const p2 = g_limbPoints[1]; p2.x = x2 - dx; p2.y = y2 + dy;
        const p3 = g_limbPoints[2]; p3.x = x2 + dx; p3.y = y2 - dy;
        const p4 = g_limbPoints[3]; p4.x = x1 + dx; p4.y = y1 - dy;

        drawFuzzyPath(g_limbPoints, color, scale, true, seed);

        // Add shadow gradient overlay for depth
        ctx.save();
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y); ctx.closePath();
        ctx.clip();
        const grad = ctx.createLinearGradient(x1, y1, x2, y2);
        grad.addColorStop(0, 'rgba(0,0,0,0)'); grad.addColorStop(1, 'rgba(0,0,0,0.3)');
        ctx.fillStyle = grad; ctx.fill();
        ctx.restore();
    }

    function drawAnatomicBody(cx, topY, w, h, scale, color, isFurry, seed = 1, options = {}) {
        const waistScale = options.waistScale || 0.85;
        const roundness = options.roundness || 0;

        // Hourglass / Tapered shape
        // Shoulders
        const sW = w * 1.1;
        const hW = w * 1.0; // Hips
        const wW = w * waistScale; // Waist

        const shoulderY = topY;
        const waistY = topY + h * 0.55;
        const hipY = topY + h;

        let points = [
            {x: cx - sW/2, y: shoulderY},     // 0: Top Left
            {x: cx + sW/2, y: shoulderY},     // 1: Top Right
            {x: cx + wW/2, y: waistY},        // 2: Waist Right
            {x: cx + hW/2, y: hipY},          // 3: Hip Right
            {x: cx - hW/2, y: hipY},          // 4: Hip Left
            {x: cx - wW/2, y: waistY}         // 5: Waist Left
        ];

        // For furry rendering, inject intermediate points to simulate curves if roundness > 0
        if (isFurry && roundness > 0) {
             const rOffset = w * roundness;
             const midR1 = { x: cx + wW/2 + rOffset, y: (shoulderY + waistY)/2 };
             const midR2 = { x: cx + hW/2 + rOffset*0.5, y: (waistY + hipY)/2 };
             const midL1 = { x: cx - hW/2 - rOffset*0.5, y: (waistY + hipY)/2 };
             const midL2 = { x: cx - wW/2 - rOffset, y: (shoulderY + waistY)/2 };

             points = [
                 points[0], points[1],
                 midR1, points[2], midR2, points[3],
                 points[4],
                 midL1, points[5], midL2
             ];
        }

        if (isFurry) {
            drawFuzzyPath(points, color, scale, true, seed);
        } else {
            ctx.beginPath();
            ctx.moveTo(points[0].x + 10*scale, points[0].y); // Round corner start
            ctx.lineTo(points[1].x - 10*scale, points[1].y);
            ctx.quadraticCurveTo(points[1].x, points[1].y, points[1].x, points[1].y + 10*scale);

            // Right Side
            if (roundness > 0) {
                const rOffset = w * roundness;
                ctx.quadraticCurveTo(cx + wW/2 + rOffset, (shoulderY + waistY)/2, points[2].x, points[2].y);
                ctx.quadraticCurveTo(cx + hW/2 + rOffset*0.5, (waistY + hipY)/2, points[3].x, points[3].y - 10*scale);
            } else {
                ctx.lineTo(points[2].x, points[2].y);
                ctx.lineTo(points[3].x, points[3].y - 10*scale);
            }

            ctx.quadraticCurveTo(points[3].x, points[3].y, points[3].x - 10*scale, points[3].y);
            ctx.lineTo(points[4].x + 10*scale, points[4].y);
            ctx.quadraticCurveTo(points[4].x, points[4].y, points[4].x, points[4].y - 10*scale);

            // Left Side
            if (roundness > 0) {
                const rOffset = w * roundness;
                ctx.quadraticCurveTo(cx - hW/2 - rOffset*0.5, (waistY + hipY)/2, points[5].x, points[5].y);
                ctx.quadraticCurveTo(cx - wW/2 - rOffset, (shoulderY + waistY)/2, points[0].x, points[0].y + 10*scale);
            } else {
                ctx.lineTo(points[5].x, points[5].y);
                ctx.lineTo(points[0].x, points[0].y + 10*scale);
            }

            ctx.quadraticCurveTo(points[0].x, points[0].y, points[0].x + 10*scale, points[0].y);
            ctx.closePath();

            const cacheKey = `anatomic_body_${color}`;
            const fillStyle = getCachedPattern(cacheKey, (gradCtx, size) => {
                gradCtx.fillStyle = color;
                gradCtx.fillRect(0, 0, size, size);
                const grad = gradCtx.createRadialGradient(size/2, size/2, 5, size/2, size/2, size/2);
                grad.addColorStop(0, 'rgba(255,255,255,0.1)');
                grad.addColorStop(1, 'rgba(0,0,0,0.3)');
                gradCtx.fillStyle = grad;
                gradCtx.fillRect(0, 0, size, size);
            });

            ctx.fillStyle = fillStyle;
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        if (options.chestStripeColor) {
            ctx.save();
            if (isFurry) {
                drawFuzzyPath(points, null, scale, true, seed, true);
            } else {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                if (roundness > 0) {
                    const rOffset = w * roundness;
                    ctx.quadraticCurveTo(cx + wW/2 + rOffset, (shoulderY + waistY)/2, points[2].x, points[2].y);
                    ctx.quadraticCurveTo(cx + hW/2 + rOffset*0.5, (waistY + hipY)/2, points[3].x, points[3].y);
                    ctx.lineTo(points[4].x, points[4].y);
                    ctx.quadraticCurveTo(cx - hW/2 - rOffset*0.5, (waistY + hipY)/2, points[5].x, points[5].y);
                    ctx.quadraticCurveTo(cx - wW/2 - rOffset, (shoulderY + waistY)/2, points[0].x, points[0].y);
                } else {
                    points.forEach((p, i) => { if(i>0) ctx.lineTo(p.x, p.y); });
                }
                ctx.closePath();
            }
            ctx.clip();
            ctx.fillStyle = options.chestStripeColor;
            ctx.fillRect(cx - w*2, topY, w*4, h * 0.25);
            ctx.restore();
        }
    }

    function drawLimb(x1, y1, x2, y2, width, color) {
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const dx = Math.sin(angle) * (width / 2); const dy = Math.cos(angle) * (width / 2);

        const cacheKey = `limb_${color}`;
        const fillStyle = getCachedPattern(cacheKey, (gradCtx, size) => {
            gradCtx.fillStyle = color;
            gradCtx.fillRect(0, 0, size, size);
            const grad = gradCtx.createLinearGradient(0, 0, 0, size);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(1, 'rgba(0,0,0,0.3)');
            gradCtx.fillStyle = grad;
            gradCtx.fillRect(0, 0, size, size);
        });

        ctx.beginPath();
        ctx.moveTo(x1 - dx, y1 + dy);
        ctx.lineTo(x2 - dx, y2 + dy);
        ctx.arc(x2, y2, width/2, angle + Math.PI/2, angle - Math.PI/2);
        ctx.lineTo(x1 + dx, y1 - dy);
        ctx.arc(x1, y1, width/2, angle - Math.PI/2, angle + Math.PI/2);
        ctx.closePath();

        ctx.fillStyle = fillStyle;
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    function drawRoundedRect(x, y, w, h, r, color) {
        const cacheKey = `rounded_rect_${color}`;
        const fillStyle = getCachedPattern(cacheKey, (gradCtx, size) => {
            gradCtx.fillStyle = color;
            gradCtx.fillRect(0, 0, size, size);
            const grad = gradCtx.createRadialGradient(size/2, size/2, 5, size/2, size/2, size/2);
            grad.addColorStop(0, 'rgba(255,255,255,0.2)');
            grad.addColorStop(1, 'rgba(0,0,0,0.3)');
            gradCtx.fillStyle = grad;
            gradCtx.fillRect(0, 0, size, size);
        });

        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.arcTo(x+w, y, x+w, y+h, r);
        ctx.arcTo(x+w, y+h, x, y+h, r);
        ctx.arcTo(x, y+h, x, y, r);
        ctx.arcTo(x, y, x+w, y, r);
        ctx.closePath();

        ctx.fillStyle = fillStyle;
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    function drawDecor(p, type, variant, seed) {
        if (!p) return;
        const s = p.scale;
        if(type === 'grass') {
             // Realistic Grass Tuft
             // Base Shadow
             ctx.fillStyle = 'rgba(0,0,0,0.2)';
             ctx.beginPath(); ctx.ellipse(p.x, p.y, 15*s, 5*s, 0, 0, Math.PI*2); ctx.fill();

             // Blades
             ctx.strokeStyle = '#32CD32';
             ctx.lineWidth = 2 * s;
             ctx.lineCap = 'round';
             ctx.beginPath();
             for(let i=0; i<5; i++) {
                 const angle = -Math.PI/2 + (i-2)*0.3;
                 const len = 15 * s + Math.random() * 10 * s;
                 const bx = p.x + (i-2)*3*s;
                 const by = p.y;
                 ctx.moveTo(bx, by);
                 ctx.quadraticCurveTo(bx + Math.cos(angle)*5*s, by - len*0.5, bx + Math.cos(angle)*len, by - len);
             }
             ctx.stroke();

             // Small Flower
             if (seed > 0.7) {
                 ctx.fillStyle = '#FFF';
                 ctx.beginPath(); ctx.arc(p.x, p.y - 15*s, 3*s, 0, Math.PI*2); ctx.fill();
                 ctx.fillStyle = '#FFD700';
                 ctx.beginPath(); ctx.arc(p.x, p.y - 15*s, 1.5*s, 0, Math.PI*2); ctx.fill();
             }
        }
        else if(type === 'tree') {
            if (variant === 'pine') {
                // Realistic Pine
                ctx.fillStyle = '#3E2723'; // Trunk
                ctx.fillRect(p.x - 4*s, p.y, 8*s, -20*s);

                const drawLayer = (yBase, w, h, color) => {
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(p.x - w, yBase);
                    ctx.lineTo(p.x, yBase - h);
                    ctx.lineTo(p.x + w, yBase);
                    // Jagged bottom
                    for(let i=1; i<=4; i++) {
                        ctx.lineTo(p.x + w - (2*w*(i/4)), yBase - (i%2==0 ? 0 : 5*s));
                    }
                    ctx.closePath();
                    ctx.fill();
                };

                drawLayer(p.y - 15*s, 30*s, 60*s, '#1B5E20'); // Bottom
                drawLayer(p.y - 45*s, 25*s, 50*s, '#2E7D32'); // Mid
                drawLayer(p.y - 70*s, 15*s, 40*s, '#4CAF50'); // Top
            } else {
                // Realistic Oak
                ctx.fillStyle = '#5D4037'; // Trunk
                ctx.beginPath();
                ctx.moveTo(p.x - 6*s, p.y);
                ctx.lineTo(p.x - 6*s, p.y - 30*s);
                ctx.lineTo(p.x + 6*s, p.y - 30*s);
                ctx.lineTo(p.x + 6*s, p.y);
                ctx.fill();

                // Roots
                ctx.beginPath(); ctx.moveTo(p.x - 6*s, p.y); ctx.lineTo(p.x - 10*s, p.y + 5*s); ctx.lineTo(p.x, p.y); ctx.fill();
                ctx.beginPath(); ctx.moveTo(p.x + 6*s, p.y); ctx.lineTo(p.x + 10*s, p.y + 5*s); ctx.lineTo(p.x, p.y); ctx.fill();

                // Canopy (Clustered)
                const drawLeafCircle = (dx, dy, r, color) => {
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.arc(p.x + dx*s, p.y - 30*s + dy*s, r*s, 0, Math.PI*2); ctx.fill();
                    // Shadow arc
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 2*s;
                    ctx.beginPath(); ctx.arc(p.x + dx*s, p.y - 30*s + dy*s, r*s, 0.5, 2.5); ctx.stroke();
                };

                drawLeafCircle(-20, -10, 25, '#228B22');
                drawLeafCircle(20, -10, 25, '#228B22');
                drawLeafCircle(0, -40, 30, '#32CD32');
                drawLeafCircle(0, -10, 25, '#2E8B57'); // Front center
            }
        }
        else if (type === 'water') {
             ctx.fillStyle = '#1E90FF';
             ctx.beginPath();
             const r = 20 * s;
             ctx.moveTo(p.x + r, p.y);
             for(let i=1; i<8; i++) {
                 const angle = (i/8) * Math.PI * 2;
                 const varR = r * (0.8 + 0.4 * Math.sin(seed * 10 + i * 132));
                 ctx.lineTo(p.x + Math.cos(angle)*varR, p.y + Math.sin(angle)*varR * 0.3);
             }
             ctx.closePath();
             ctx.fill();
             ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 2*s;
             ctx.beginPath(); ctx.moveTo(p.x - 10*s, p.y - 2*s); ctx.lineTo(p.x - 5*s, p.y - 2*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x + 2*s, p.y + 2*s); ctx.lineTo(p.x + 8*s, p.y + 2*s); ctx.stroke();
        }
        else if (type === 'castle') {
            const w = 40 * s; const h = 60 * s;
            ctx.fillStyle = '#808080';
            ctx.fillRect(p.x - w/2, p.y - h, w, h);
            ctx.fillStyle = '#696969';
            ctx.fillRect(p.x - w/2 - 10*s, p.y - h*0.8, 10*s, h*0.8);
            ctx.fillRect(p.x + w/2, p.y - h*0.8, 10*s, h*0.8);
            ctx.fillStyle = '#808080';
            const bW = w/3;
            ctx.fillRect(p.x - w/2, p.y - h - 5*s, bW*0.6, 5*s);
            ctx.fillRect(p.x - w/2 + bW, p.y - h - 5*s, bW*0.6, 5*s);
            ctx.fillRect(p.x - w/2 + bW*2, p.y - h - 5*s, bW*0.6, 5*s);
            ctx.fillStyle = '#8B0000';
            ctx.beginPath(); ctx.moveTo(p.x - w/2 - 12*s, p.y - h*0.8); ctx.lineTo(p.x - w/2 - 5*s, p.y - h*1.1); ctx.lineTo(p.x - w/2 + 2*s, p.y - h*0.8); ctx.fill();
            ctx.beginPath(); ctx.moveTo(p.x + w/2 - 2*s, p.y - h*0.8); ctx.lineTo(p.x + w/2 + 5*s, p.y - h*1.1); ctx.lineTo(p.x + w/2 + 12*s, p.y - h*0.8); ctx.fill();
            ctx.fillStyle = '#222';
            ctx.beginPath(); ctx.arc(p.x, p.y, 10*s, Math.PI, 0); ctx.fill();
        }
        else if (type === 'mountain') {
            ctx.fillStyle = '#757575';
            ctx.beginPath();
            ctx.moveTo(p.x - 25*s, p.y);
            ctx.lineTo(p.x - 15*s, p.y - 40*s);
            ctx.lineTo(p.x, p.y - 60*s);
            ctx.lineTo(p.x + 20*s, p.y - 30*s);
            ctx.lineTo(p.x + 30*s, p.y);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.moveTo(p.x - 11*s, p.y - 50*s);
            ctx.lineTo(p.x, p.y - 60*s);
            ctx.lineTo(p.x + 7*s, p.y - 50*s);
            ctx.lineTo(p.x, p.y - 45*s);
            ctx.fill();
        }
        else if (type === 'space') {
            // Grounded objects (Rocks & Craters) replacing floating planets
            if (seed > 0.6) {
                // Craters
                ctx.fillStyle = '#333'; // Inner dark hole
                ctx.beginPath();
                ctx.ellipse(p.x, p.y, 25*s, 6*s, 0, 0, Math.PI*2);
                ctx.fill();

                // Rim
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2*s;
                ctx.stroke();

            } else {
                // Space Rocks (Grounded)
                const isRed = (seed > 0.3 && seed < 0.45);
                ctx.fillStyle = isRed ? '#8B4513' : '#696969'; // Mars-ish or Grey

                ctx.beginPath();
                const r = 20 * s;
                const segments = 7;
                // Draw a jagged dome sitting on the ground (p.y)
                for(let i=0; i<=segments; i++) {
                    const theta = Math.PI + (i/segments) * Math.PI; // PI (Left) to 2PI (Right)
                    const noise = 0.8 + 0.4 * Math.sin(seed * 50 + i * 13);
                    const d = r * noise;

                    const px = p.x + Math.cos(theta) * d;
                    const py = p.y + Math.sin(theta) * d * 0.7; // Flattened y-axis

                    if(i===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath(); // Closes bottom flat
                ctx.fill();

                // Shadow/Texture detail
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.arc(p.x - 5*s, p.y - 8*s, 5*s, 0, Math.PI*2);
                ctx.fill();
            }
        }
        else if (type === 'tacocat') {
             const s = p.scale;
             // Taco Shell
             ctx.fillStyle = '#F4C430';
             ctx.beginPath(); ctx.arc(p.x, p.y - 10*s, 25*s, 0, Math.PI, true); ctx.fill(); // Shell
             ctx.strokeStyle = '#D4A017'; ctx.lineWidth = 2*s; ctx.stroke();

             // Cat Head (Peeking out)
             const hy = p.y - 25*s;
             ctx.fillStyle = '#808080';
             ctx.beginPath(); ctx.arc(p.x, hy, 12*s, 0, Math.PI*2); ctx.fill();
             // Ears
             ctx.beginPath(); ctx.moveTo(p.x-10*s, hy-5*s); ctx.lineTo(p.x-15*s, hy-18*s); ctx.lineTo(p.x-4*s, hy-10*s); ctx.fill();
             ctx.beginPath(); ctx.moveTo(p.x+10*s, hy-5*s); ctx.lineTo(p.x+15*s, hy-18*s); ctx.lineTo(p.x+4*s, hy-10*s); ctx.fill();
             // Face
             ctx.fillStyle = '#FFF';
             ctx.beginPath(); ctx.arc(p.x-4*s, hy-2*s, 3*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x+4*s, hy-2*s, 3*s, 0, Math.PI*2); ctx.fill();
             ctx.fillStyle = '#000';
             ctx.beginPath(); ctx.arc(p.x-4*s, hy-2*s, 1.5*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x+4*s, hy-2*s, 1.5*s, 0, Math.PI*2); ctx.fill();

             // Fillings (Foreground)
             ctx.fillStyle = '#8B4513'; ctx.beginPath(); ctx.ellipse(p.x, p.y - 10*s, 20*s, 6*s, 0, 0, Math.PI*2); ctx.fill();
             ctx.fillStyle = '#32CD32';
             ctx.beginPath(); ctx.arc(p.x-10*s, p.y-12*s, 6*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x+10*s, p.y-12*s, 6*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x, p.y-14*s, 6*s, 0, Math.PI*2); ctx.fill();
        }
    }

    function drawShadow(p) { if(!p) return; ctx.fillStyle='rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(p.x, p.y, 25*p.scale, 8*p.scale, 0, 0, Math.PI*2); ctx.fill(); }

    function drawHoop(p) {
        if (!p) return;
        const s = p.scale;
        const baseP = project(HOOP_POS.x, HOOP_POS.y, 0);
        if(baseP) { ctx.fillStyle = '#444'; ctx.fillRect(p.x - 2*s, p.y, 4*s, baseP.y - p.y); }
        const bbW = 60 * s; const bbH = 40 * s; const bbX = p.x - bbW/2; const bbY = p.y - bbH - 10*s;
        ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(bbX, bbY, bbW, bbH);
        ctx.strokeStyle = '#333'; ctx.lineWidth = 2*s; ctx.strokeRect(bbX, bbY, bbW, bbH);
        ctx.fillStyle = '#CE1126'; ctx.fillRect(bbX + bbW*0.35, bbY + bbH*0.6, bbW*0.3, bbH*0.3);
        ctx.beginPath(); ctx.ellipse(p.x, p.y, 18 * s, 5 * s, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'none'; ctx.strokeStyle = 'orange'; ctx.lineWidth = 4 * s; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(p.x - 15*s, p.y); ctx.lineTo(p.x - 10*s, p.y + 20*s); ctx.lineTo(p.x + 10*s, p.y + 20*s); ctx.lineTo(p.x + 15*s, p.y);
        ctx.strokeStyle = 'white'; ctx.lineWidth = 1*s; ctx.stroke();
    }

    function drawMuscleLimb(x1, y1, x2, y2, width, color, type, s) {
        // type: 'thigh' or 'calf' or 'standard'
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const len = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
        
        ctx.save();
        ctx.translate(x1, y1);
        ctx.rotate(angle);
        
        ctx.beginPath();
        const w = width / 2;
        
        if (type === 'thigh') {
            // Thigh: Wide at top (0,0), taper to knee (len, 0)
            ctx.moveTo(0, -w);
            ctx.lineTo(len, -w * 0.7); // Knee is thinner
            ctx.lineTo(len, w * 0.7);
            ctx.lineTo(0, w);
        } else if (type === 'calf') {
            // Calf: Knee (0,0), Bulge at 1/3, Ankle (len, 0)
            ctx.moveTo(0, -w * 0.7);
            ctx.quadraticCurveTo(len * 0.3, -w * 1.4, len, -w * 0.5); // Outer bulge
            ctx.lineTo(len, w * 0.5);
            ctx.quadraticCurveTo(len * 0.3, w * 1.4, 0, w * 0.7); // Inner bulge
        } else {
            // Standard
            ctx.moveTo(0, -w);
            ctx.lineTo(len, -w);
            ctx.lineTo(len, w);
            ctx.lineTo(0, w);
        }
        
        ctx.closePath();
        
        const cacheKey = `muscle_limb_${color}`;
        const fillStyle = getCachedPattern(cacheKey, (gradCtx, size) => {
            gradCtx.fillStyle = color;
            gradCtx.fillRect(0, 0, size, size);
            const grad = gradCtx.createLinearGradient(0, 0, 0, size);
            grad.addColorStop(0, 'rgba(255,255,255,0.1)');
            grad.addColorStop(1, 'rgba(0,0,0,0.3)');
            gradCtx.fillStyle = grad;
            gradCtx.fillRect(0, 0, size, size);
        });

        ctx.fillStyle = fillStyle;
        ctx.fill();
        
        // Muscle Definition highlight
        if (type === 'calf') {
             ctx.fillStyle = 'rgba(255,255,255,0.1)';
             ctx.beginPath();
             ctx.ellipse(len*0.3, 0, len*0.15, w*0.5, 0, 0, Math.PI*2);
             ctx.fill();
        }
        
        ctx.restore();
    }

    function drawRealisticShoe(x, y, w, h, color, isRight) {
        // Detailed sneaker
        // Sole
        ctx.fillStyle = '#DDD'; 
        ctx.beginPath();
        ctx.ellipse(x, y + h*0.2, w, h*0.4, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#999'; ctx.lineWidth=1; ctx.stroke();
        
        // Upper
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y - h*0.2, w*0.9, 0, Math.PI*2); // Main foot
        ctx.fill();
        
        // Detail lines (laces area)
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.moveTo(x - w*0.5, y - h*0.5); ctx.lineTo(x + w*0.5, y - h*0.5); ctx.stroke();
    }

    // --- OPTIMIZATION: Gradient Caching ---
    const GRAD_CANVAS_SIZE = 64; // Power of 2 for performance
    const g_gradientCache = {};

    function getCachedPattern(key, generator) {
        if (g_gradientCache[key]) {
            return g_gradientCache[key];
        }

        const gradCanvas = document.createElement('canvas');
        gradCanvas.width = GRAD_CANVAS_SIZE;
        gradCanvas.height = GRAD_CANVAS_SIZE;
        const gradCtx = gradCanvas.getContext('2d');

        generator(gradCtx, GRAD_CANVAS_SIZE);

        const pattern = ctx.createPattern(gradCanvas, 'repeat');
        g_gradientCache[key] = pattern;
        return pattern;
    }

    function drawJersey(cx, topY, w, h, scale, skinObj) {
        // V-Taper Jersey
        const color = skinObj.jerseyColor || '#FFF';
        const shoulderW = w * 1.6;
        const waistW = w * 0.9;
        
        const shoulderY = topY;
        const armpitY = topY + h * 0.4;
        const bottomY = topY + h;
        
        ctx.beginPath();
        ctx.moveTo(cx - shoulderW/2, shoulderY); 
        ctx.lineTo(cx + shoulderW/2, shoulderY);
        
        // Right side
        ctx.lineTo(cx + shoulderW/2, armpitY);
        ctx.quadraticCurveTo(cx + waistW*0.6, (armpitY+bottomY)/2, cx + waistW/2, bottomY);
        
        // Bottom curve (Tuck)
        ctx.quadraticCurveTo(cx, bottomY + 3*scale, cx - waistW/2, bottomY);
        
        // Left side
        ctx.quadraticCurveTo(cx - waistW*0.6, (armpitY+bottomY)/2, cx - shoulderW/2, armpitY);
        ctx.lineTo(cx - shoulderW/2, shoulderY);
        
        ctx.closePath();
        
        // Fill
        const grad = ctx.createLinearGradient(cx - shoulderW/2, topY, cx + shoulderW/2, topY);
        grad.addColorStop(0, color); 
        grad.addColorStop(0.5, 'rgba(255,255,255,0.05)');
        grad.addColorStop(1, color); 
        
        ctx.fillStyle = color;
        ctx.fill();
        ctx.fillStyle = grad; 
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fill();

        // --- PATTERNS ---
        // Pinstripes
        if(skinObj.pinstripesColor) {
            ctx.strokeStyle = skinObj.pinstripesColor;
            ctx.lineWidth = 1 * scale;
            const step = 4 * scale;
            for(let dx = -shoulderW/2; dx <= shoulderW/2; dx += step) {
                if(Math.abs(dx) < 2*scale) continue; // Skip spine
                ctx.beginPath();
                ctx.moveTo(cx + dx, shoulderY);
                ctx.lineTo(cx + dx * 0.7, bottomY); // Taper in
                ctx.stroke();
            }
        }

        // Side Panels
        if(skinObj.sideStripesColor) {
            ctx.fillStyle = skinObj.sideStripesColor;
            const stripeW = 3 * scale;

            // Left Panel
            ctx.beginPath();
            ctx.moveTo(cx - shoulderW/2, armpitY);
            ctx.quadraticCurveTo(cx - waistW*0.6, (armpitY+bottomY)/2, cx - waistW/2, bottomY);
            ctx.lineTo(cx - waistW/2 + stripeW, bottomY);
            ctx.quadraticCurveTo(cx - waistW*0.6 + stripeW, (armpitY+bottomY)/2, cx - shoulderW/2 + stripeW, armpitY);
            ctx.fill();

            // Right Panel
            ctx.beginPath();
            ctx.moveTo(cx + shoulderW/2, armpitY);
            ctx.quadraticCurveTo(cx + waistW*0.6, (armpitY+bottomY)/2, cx + waistW/2, bottomY);
            ctx.lineTo(cx + waistW/2 - stripeW, bottomY);
            ctx.quadraticCurveTo(cx + waistW*0.6 - stripeW, (armpitY+bottomY)/2, cx + shoulderW/2 - stripeW, armpitY);
            ctx.fill();
        }

        ctx.globalCompositeOperation = 'source-over';

        // Spine/Back Detail
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.beginPath();
        ctx.moveTo(cx, topY + h*0.2);
        ctx.lineTo(cx + 1*scale, topY + h*0.7);
        ctx.lineTo(cx - 1*scale, topY + h*0.7);
        ctx.fill();
        
        // Mesh Texture
        ctx.save();
        ctx.clip();
        ctx.fillStyle = 'rgba(0,0,0,0.05)';
        for(let i=0; i<h; i+=4*scale) {
            if (i%8===0) ctx.fillRect(cx - shoulderW, topY + i, shoulderW*2, 1*scale);
        }
        ctx.restore();

        // --- TRIM (Over Texture) ---
        if(skinObj.trimColor) {
            ctx.strokeStyle = skinObj.trimColor;
            ctx.lineWidth = 2 * scale;
            // Neck
            ctx.beginPath();
            ctx.moveTo(cx - shoulderW/2, shoulderY);
            ctx.lineTo(cx + shoulderW/2, shoulderY);
            ctx.stroke();
            // Armholes
            ctx.beginPath();
            ctx.moveTo(cx - shoulderW/2, shoulderY);
            ctx.lineTo(cx - shoulderW/2, armpitY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cx + shoulderW/2, shoulderY);
            ctx.lineTo(cx + shoulderW/2, armpitY);
            ctx.stroke();
        }
        
        // Tuck Shadow at bottom
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.moveTo(cx - waistW/2, bottomY);
        ctx.quadraticCurveTo(cx, bottomY + 3*scale, cx + waistW/2, bottomY);
        ctx.lineTo(cx + waistW/2, bottomY - 4*scale);
        ctx.quadraticCurveTo(cx, bottomY - 1*scale, cx - waistW/2, bottomY - 4*scale);
        ctx.fill();
    }

    function drawShorts(cx, waistY, w, h, scale, skinObj) {
        // Baggy Shorts
        const color = skinObj.shortsColor || '#FFF';
        const waistW = w * 1.0; 
        const hipW = w * 1.3;
        const legW = w * 0.6; // Width of one leg hole

        const bottomY = waistY + h;
        const crotchY = waistY + h * 0.45;

        // --- Get Base Pattern (Color + Shading) ---
        const cacheKey = `shorts_base_${color}`;
        let fillStyle = getCachedPattern(cacheKey, (gradCtx, size) => {
            // Base Color
            gradCtx.fillStyle = color;
            gradCtx.fillRect(0, 0, size, size);
            // Gradient Overlay
            const grad = gradCtx.createLinearGradient(0, 0, size, 0);
            grad.addColorStop(0, 'rgba(0,0,0,0.1)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.05)');
            grad.addColorStop(1, 'rgba(0,0,0,0.1)');
            gradCtx.fillStyle = grad;
            gradCtx.fillRect(0, 0, size, size);
        });
        if (!fillStyle) fillStyle = color;

        // --- Draw Main Shape ---
        ctx.beginPath();
        ctx.moveTo(cx - waistW/2, waistY); ctx.lineTo(cx + waistW/2, waistY);
        ctx.quadraticCurveTo(cx + hipW/2, waistY + h*0.2, cx + hipW/2, bottomY);
        ctx.lineTo(cx + hipW/2 - legW, bottomY);
        ctx.quadraticCurveTo(cx, crotchY + h*0.2, cx, crotchY);
        ctx.quadraticCurveTo(cx, crotchY + h*0.2, cx - hipW/2 + legW, bottomY);
        ctx.lineTo(cx - hipW/2, bottomY);
        ctx.quadraticCurveTo(cx - hipW/2, waistY + h*0.2, cx - waistW/2, waistY);
        ctx.closePath();
        
        ctx.fillStyle = fillStyle;
        ctx.fill();

        // --- Draw Stripes Dynamically (to preserve curves) ---
        if(skinObj.sideStripesColor) {
            ctx.save();
            ctx.clip(); // Clip to the shorts path just drawn

            ctx.fillStyle = skinObj.sideStripesColor;
            const stripeW = 4 * scale;

            // Left Stripe Path
            ctx.beginPath();
            ctx.moveTo(cx - hipW/2, waistY);
            ctx.quadraticCurveTo(cx - hipW/2, waistY + h*0.5, cx - hipW/2, bottomY);
            ctx.lineTo(cx - hipW/2 + stripeW, bottomY);
            ctx.quadraticCurveTo(cx - hipW/2 + stripeW, waistY + h*0.5, cx - hipW/2 + stripeW, waistY);
            ctx.closePath();
            ctx.fill();

            // Right Stripe Path
            ctx.beginPath();
            ctx.moveTo(cx + hipW/2, waistY);
            ctx.quadraticCurveTo(cx + hipW/2, waistY + h*0.5, cx + hipW/2, bottomY);
            ctx.lineTo(cx + hipW/2 - stripeW, bottomY);
            ctx.quadraticCurveTo(cx + hipW/2 - stripeW, waistY + h*0.5, cx + hipW/2 - stripeW, waistY);
            ctx.closePath();
            ctx.fill();

            ctx.restore(); // Remove clipping mask
        }

        // --- Details (on top of everything) ---
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(cx - waistW/2, waistY, waistW, 5*scale);
        
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 1*scale;
        ctx.beginPath(); ctx.moveTo(cx - hipW/2, waistY); ctx.quadraticCurveTo(cx - hipW/2, waistY + h*0.5, cx - hipW/2, bottomY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx + hipW/2, waistY); ctx.quadraticCurveTo(cx + hipW/2, waistY + h*0.5, cx + hipW/2, bottomY); ctx.stroke();

        if(skinObj.trimColor) {
            ctx.strokeStyle = skinObj.trimColor;
            ctx.lineWidth = 2 * scale;
            ctx.beginPath(); ctx.moveTo(cx - hipW/2, bottomY); ctx.lineTo(cx - hipW/2 + legW, bottomY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx + hipW/2 - legW, bottomY); ctx.lineTo(cx + hipW/2, bottomY); ctx.stroke();
        }
    }

    function drawHybridHead(p, headY, headRadius, s, type, skinObj) {
        const skinTone = skinObj.skinTone || skinObj.furColor || '#8d5524';
        const furColor = skinObj.furColor || skinTone;

        if (type === 'bull') {
            drawFuzzyCircle(p.x, headY, headRadius * 1.2, furColor, 200, s, true);
            ctx.fillStyle = '#3E2723';
            ctx.beginPath(); ctx.ellipse(p.x, headY + 5*s, 8*s, 6*s, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.beginPath(); ctx.moveTo(p.x - 10*s, headY - 5*s); ctx.quadraticCurveTo(p.x - 20*s, headY - 10*s, p.x - 15*s, headY - 25*s); ctx.lineTo(p.x - 12*s, headY - 5*s); ctx.fill();
            ctx.beginPath(); ctx.moveTo(p.x + 10*s, headY - 5*s); ctx.quadraticCurveTo(p.x + 20*s, headY - 10*s, p.x + 15*s, headY - 25*s); ctx.lineTo(p.x + 12*s, headY - 5*s); ctx.fill();
            ctx.fillStyle = furColor;
            ctx.beginPath(); ctx.ellipse(p.x - 15*s, headY, 6*s, 3*s, 0.2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(p.x + 15*s, headY, 6*s, 3*s, -0.2, 0, Math.PI*2); ctx.fill();
        }
        else if (type === 'jackal') {
            ctx.fillStyle = furColor;
            ctx.beginPath(); ctx.moveTo(p.x - 5*s, headY - 10*s); ctx.lineTo(p.x - 15*s, headY - 25*s); ctx.lineTo(p.x - 15*s, headY - 5*s); ctx.fill();
            ctx.beginPath(); ctx.moveTo(p.x + 5*s, headY - 10*s); ctx.lineTo(p.x + 15*s, headY - 25*s); ctx.lineTo(p.x + 15*s, headY - 5*s); ctx.fill();
            drawFuzzyCircle(p.x, headY, headRadius, furColor, 201, s, true);
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.x, headY + 5*s, 4*s, 0, Math.PI*2); ctx.fill();
        }
        else if (type === 'bandicoot') {
            ctx.fillStyle = furColor;
            ctx.beginPath(); ctx.moveTo(p.x - 5*s, headY - 10*s); ctx.lineTo(p.x - 12*s, headY - 20*s); ctx.lineTo(p.x - 10*s, headY); ctx.fill();
            ctx.beginPath(); ctx.moveTo(p.x + 5*s, headY - 10*s); ctx.lineTo(p.x + 12*s, headY - 20*s); ctx.lineTo(p.x + 10*s, headY); ctx.fill();
            drawFuzzyCircle(p.x, headY - 2*s, headRadius, furColor, 202, s, true);
            ctx.fillStyle = '#FF00FF';
            for(let i=0; i<4; i++) {
                ctx.beginPath(); ctx.arc(p.x, headY - 15*s - i*5*s, 5*s, 0, Math.PI*2); ctx.fill();
            }
        }
        else if (type === 'yeti') {
            drawFuzzyCircle(p.x, headY, headRadius * 1.3, '#FFF', 203, s, true);
            ctx.fillStyle = '#ADD8E6';
            ctx.beginPath(); ctx.arc(p.x, headY, 8*s, 0, Math.PI*2); ctx.fill();
        }
        else if (type === 'cyclops') {
            ctx.fillStyle = skinTone;
            ctx.beginPath(); ctx.arc(p.x, headY, headRadius * 1.2, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#333';
            ctx.fillRect(p.x - 15*s, headY - 5*s, 30*s, 5*s);
        }
    }

    function drawRealisticHuman(p, s, skinObj) {
        // Base Setup
        const sizeMod = {
            w: skinObj.widthScale || 0.9,
            h: skinObj.heightScale || 1.1,
            head: 0.9
        };
        const skinTone = skinObj.skinTone || '#8d5524';
        
        // Body Dimensions
        const bodyW = 20 * s * sizeMod.w; 
        const bodyH = 40 * s * sizeMod.h;
        const legLen = 30 * s * sizeMod.h;
        const torsoY = p.y - legLen - bodyH;
        const headY = torsoY - (10 * s * sizeMod.head);
        const headRadius = 12 * s * sizeMod.head;

        // 0. Calculate Arm Configuration EARLY (needed for Ball Placement)
        const currentStyle = playerData.currentStyle || 'classic';
        const anim = ANIM_DATA[currentStyle] || ANIM_DATA['classic'];
        const idle = DEFAULT_IDLE;
        
        let r_la, r_ra, r_lfa, r_rfa, r_w;
        if (state === 'SHOOTING') {
            r_la = anim.release.la; r_ra = anim.release.ra;
            r_lfa = anim.release.lfa; r_rfa = anim.release.rfa;
            r_w = anim.release.w;
        } else if (state === 'JUMPING') {
            let lift = Math.max(0, (9 - getCurrentVz()) / 9);
            lift = Math.min(1.0, lift);
            const startPose = anim.ready || idle;
            const lerpAngle = (a, b, t) => {
                if (Math.abs(b - a) > Math.PI) { if (b > a) a += 2 * Math.PI; else b += 2 * Math.PI; }
                return a + (b - a) * t;
            };
            const lerp = (a, b, t) => a + (b - a) * t;
            r_la = lerpAngle(startPose.la, anim.set.la, lift);
            r_ra = lerpAngle(startPose.ra, anim.set.ra, lift);
            r_lfa = lerpAngle(startPose.lfa, anim.set.lfa, lift);
            r_rfa = lerpAngle(startPose.rfa, anim.set.rfa, lift);
            r_w = lerp(startPose.w, anim.set.w, lift);
        } else {
            r_la = idle.la; r_ra = idle.ra;
            r_lfa = idle.lfa; r_rfa = idle.rfa;
            r_w = idle.w;
        }

        let leftArmAngle, rightArmAngle, leftForeArmAngle, rightForeArmAngle, wristAngle;
        if (playerData.isLefty) {
            leftArmAngle = Math.PI - r_ra; rightArmAngle = Math.PI - r_la;
            leftForeArmAngle = Math.PI - r_rfa; rightForeArmAngle = Math.PI - r_lfa;
            wristAngle = -r_w;
        } else {
            leftArmAngle = r_la; rightArmAngle = r_ra;
            leftForeArmAngle = r_lfa; rightForeArmAngle = r_rfa;
            wristAngle = r_w;
        }

        let shoulderY = torsoY + (5*s);
        let leftShoulderX = p.x - 16*s; let rightShoulderX = p.x + 16*s; // Move arms out
        const upperArmLen = 20 * s * sizeMod.h * 1.05;
        const foreArmLen = 20 * s * sizeMod.h * 1.05;

        // 0b. Detached Ball Rendering
        drawDetachedBall(p, s, torsoY, bodyH, headY);

        // 0c. HELD BALL RENDERING (Layer 0 - Before Body)
        const isDetachedStyle = ['airbud', 'telekinesis'].includes(playerData.currentStyle);
        if (!isDetachedStyle && state !== 'SHOOTING' && state !== 'GAMEOVER') {
            const isRightHand = !playerData.isLefty;
            const shootUAngle = isRightHand ? rightArmAngle : leftArmAngle;
            const shootFAngle = isRightHand ? rightForeArmAngle : leftForeArmAngle;
            const shootSX = isRightHand ? rightShoulderX : leftShoulderX;
            const shootWristAngle = isRightHand ? wristAngle : -wristAngle; // Fix for lefty check? wristAngle is already adjusted above

            // Wait, wristAngle calculation above:
            // Lefty: wristAngle = -r_w
            // Righty: wristAngle = r_w
            // So 'wristAngle' IS the shooting hand's wrist angle relative to forearm.
            // But we need to apply it correctly.

            let elbow = getJoint(shootSX, shoulderY, upperArmLen, shootUAngle);
            let wrist = getJoint(elbow.x, elbow.y, foreArmLen, shootFAngle);

            // Calculate Ball Position based on wrist transform
            // In drawHumanArm: ctx.rotate(angle2 + (isShootingSide ? wristAngle : 0));
            // Ball is at (0, 5*s)
            let theta = shootFAngle + wristAngle;
            let ballX = wrist.x + Math.cos(theta) * 0 - Math.sin(theta) * 5 * s;
            let ballY = wrist.y + Math.sin(theta) * 0 + Math.cos(theta) * 5 * s;

            drawBallSprite(ballX, ballY, s, (currentStreak >= 5));
        }

        // 1. Colors
        const jerseyColor = skinObj.jerseyColor || '#FFF';
        const shortsColor = skinObj.shortsColor || '#FFF';
        const sleeveRight = skinObj.sleeveRight;
        const sleeveLeft = skinObj.sleeveLeft || skinObj.sleeveColor;
        const socksColor = skinObj.socksColor;
        const shoesColor = skinObj.shoesColor;

        // 2. Legs (Base implementation)
        const baseKneeY = p.y - (legLen * 0.5);
        let lKneeX = p.x - 9*s, lKneeY = baseKneeY;
        let rKneeX = p.x + 9*s, rKneeY = baseKneeY;
        let lFootX = p.x - 10*s, lFootY = p.y;
        let rFootX = p.x + 10*s, rFootY = p.y;

        // Dirk Kick Logic
        if (state === 'JUMPING' && playerData.currentStyle === 'dirk') {
            const lift = Math.min(1.0, Math.max(0, (9 - getCurrentVz()) / 9));
            const kickH = 20 * s * lift;
            const kickW = 15 * s * lift;
            if (playerData.isLefty) {
                 lKneeY -= kickH; lKneeX -= kickW; lFootX -= kickW; lFootY -= kickH*0.8;
            } else {
                 rKneeY -= kickH; rKneeX += kickW; rFootX += kickW; rFootY -= kickH*0.8;
            }
        }

        // Draw Thighs (Skin tone - under shorts)
        drawMuscleLimb(p.x - 7*s, p.y - legLen, lKneeX, lKneeY, 8*s*sizeMod.w, skinTone, 'thigh', s);
        drawMuscleLimb(p.x + 7*s, p.y - legLen, rKneeX, rKneeY, 8*s*sizeMod.w, skinTone, 'thigh', s);

        const drawHumanArm = (sx, sy, isRight, angle1, angle2) => {
            const isShootingSide = (playerData.isLefty && !isRight) || (!playerData.isLefty && isRight);
            let uColor = skinTone, fColor = skinTone;
            
            if (skinObj.jerseyType === 'tshirt') uColor = jerseyColor;
            if (isRight && sleeveRight) { uColor = sleeveRight; fColor = sleeveRight; }
            if (!isRight && sleeveLeft) { uColor = sleeveLeft; fColor = sleeveLeft; }

            let elbow = getJoint(sx, sy, upperArmLen, angle1);
            // Upper Arm (Deltoid to Elbow)
            drawMuscleLimb(sx, sy, elbow.x, elbow.y, 8*s*sizeMod.w, uColor, 'thigh', s);
            
            let wrist = getJoint(elbow.x, elbow.y, foreArmLen, angle2);
            // Forearm (Elbow to Wrist)
            drawMuscleLimb(elbow.x, elbow.y, wrist.x, wrist.y, 6*s*sizeMod.w, fColor, 'thigh', s);

            // Elbow Joint Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.beginPath(); ctx.arc(elbow.x, elbow.y, 3*s, 0, Math.PI*2); ctx.fill();

            // Hand
            ctx.save(); ctx.translate(wrist.x, wrist.y); ctx.rotate(angle2 + (isShootingSide ? wristAngle : 0));
            
            // Hand (Realistic)
            ctx.fillStyle = fColor; 
            ctx.beginPath();
            ctx.moveTo(-2*s, 0); ctx.lineTo(2*s, 0); ctx.lineTo(2.5*s, 6*s); ctx.lineTo(-2.5*s, 6*s); 
            ctx.fill();
            
            if (isShootingSide && state !== 'SHOOTING' && state !== 'GAMEOVER' && !isDetachedStyle) {
                // Ball is drawn in Layer 0 now. Just draw Fingers.
                // Fingers over ball
                ctx.fillStyle = fColor;
                ctx.beginPath(); ctx.arc(-2*s, 6*s, 1.5*s, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(2*s, 6*s, 1.5*s, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        };

        // 4. Torso & Shorts Layer (Moved BEFORE Arms so Arms appear on top of Shorts/Body side)
        const jerseyH = bodyH * 0.85;
        const reducedBodyW = bodyW * 0.9;
        const waistY = torsoY + bodyH * 0.85;
        let shortsLen = (0.5 * legLen) + (0.15 * bodyH) + 2*s;
        if (skinObj.shortsLength === 'short') { shortsLen = (0.25 * legLen) + (0.1 * bodyH); }

        // Shorts First (Layer 2)
        drawShorts(p.x, waistY, reducedBodyW * 1.05, shortsLen, s, skinObj);

        // Arms Next (Layer 3) - Fixes "Arms behind legs" issue
        drawHumanArm(leftShoulderX, shoulderY, false, leftArmAngle, leftForeArmAngle);
        drawHumanArm(rightShoulderX, shoulderY, true, rightArmAngle, rightForeArmAngle);

        // Torso Last (Layer 4) - Covers top of arms (Shoulders) and top of shorts
        if (skinObj.jerseyType === 'none') {
             // Bare Torso
             drawAnatomicBody(p.x, torsoY, reducedBodyW, jerseyH, s, skinTone, false, 0, { chestStripeColor: null });
             // Muscle Detail (Spine/Pecs)
             ctx.fillStyle = 'rgba(0,0,0,0.1)';
             ctx.beginPath(); ctx.moveTo(p.x, torsoY + 10*s); ctx.lineTo(p.x, torsoY + jerseyH*0.8); ctx.lineTo(p.x + 2*s, torsoY + jerseyH*0.8); ctx.lineTo(p.x + 2*s, torsoY + 10*s); ctx.fill();
        } else {
             drawJersey(p.x, torsoY, reducedBodyW, jerseyH, s, skinObj);
        }

        if (skinObj.clothingDetail === 'overalls') {
             const bibColor = skinObj.shortsColor || '#000080';
             ctx.fillStyle = bibColor;
             // Bib
             ctx.fillRect(p.x - reducedBodyW*0.35, torsoY + 15*s, reducedBodyW*0.7, jerseyH - 15*s);
             // Straps
             ctx.fillRect(p.x - reducedBodyW*0.35, torsoY, 4*s, 20*s);
             ctx.fillRect(p.x + reducedBodyW*0.35 - 4*s, torsoY, 4*s, 20*s);
             // Buttons
             ctx.fillStyle = '#FFD700';
             ctx.beginPath(); ctx.arc(p.x - reducedBodyW*0.35 + 2*s, torsoY + 18*s, 2*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x + reducedBodyW*0.35 - 2*s, torsoY + 18*s, 2*s, 0, Math.PI*2); ctx.fill();
        }

        // Draw Calves/Shoes
        const drawLowerLeg = (xTop, yTop, xBot, yBot, isRight) => {
             drawMuscleLimb(xTop, yTop, xBot, yBot, 7*s*sizeMod.w, skinTone, 'calf', s);
             // Socks
             if(socksColor) {
                 const sockH = 7 * s;
                 const sockY = yBot - 5*s - sockH;
                 const t = (sockY - yTop) / (yBot - yTop);
                 const sockTopX = xTop + (xBot - xTop) * t;
                 const ankleY = yBot - 5*s;
                 const t2 = (ankleY - yTop) / (yBot - yTop);
                 const ankleX = xTop + (xBot - xTop) * t2;
                 drawMuscleLimb(sockTopX, sockY, ankleX, ankleY, 6.5*s*sizeMod.w, socksColor, 'standard', s);
                 // Ribs
                 ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 1;
                 for(let i=0; i<3; i++) {
                     const ly = sockY + (i*2*s);
                     ctx.beginPath(); ctx.moveTo(sockTopX - 3*s, ly); ctx.lineTo(sockTopX + 3*s, ly); ctx.stroke();
                 }
             }
             // Shoes
             if(shoesColor) {
                 drawRealisticShoe(xBot, yBot, 5.5*s, 5.5*s, shoesColor, isRight);
             }
        };
        drawLowerLeg(lKneeX, lKneeY, lFootX, lFootY, false);
        drawLowerLeg(rKneeX, rKneeY, rFootX, rFootY, true);

        // NECK
        const neckW = 10 * s * sizeMod.w;
        const neckH = 10 * s;
        ctx.fillStyle = skinTone;
        ctx.beginPath();
        // Traps/Neck Base
        ctx.moveTo(p.x - neckW, torsoY + 2*s);
        ctx.quadraticCurveTo(p.x - neckW*0.6, torsoY - neckH*0.8, p.x - neckW*0.4, torsoY - neckH);
        ctx.lineTo(p.x + neckW*0.4, torsoY - neckH);
        ctx.quadraticCurveTo(p.x + neckW*0.6, torsoY - neckH*0.8, p.x + neckW, torsoY + 2*s);
        ctx.fill();
        
        // Neck Spine Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.beginPath(); ctx.rect(p.x - 1*s, torsoY - neckH + 2*s, 2*s, neckH); ctx.fill();

        // 5. Tail (Hybrids)
        if (skinObj.tailType) {
            const tx = p.x;
            const ty = waistY + 5*s; // Tail bone area
            const tailColor = skinObj.furColor || skinTone;
            const tW = 4*s;

            if (skinObj.tailType === 'bull') {
                 ctx.beginPath(); ctx.strokeStyle = tailColor; ctx.lineWidth = tW;
                 ctx.moveTo(tx, ty);
                 ctx.quadraticCurveTo(tx + 15*s, ty + 10*s, tx + 20*s, ty + 20*s); ctx.stroke();
                 // Tuft
                 drawFuzzyPath([{x: tx+20*s, y: ty+20*s}, {x: tx+28*s, y: ty+32*s}, {x: tx+12*s, y: ty+32*s}], '#3E2723', s, true, 901);
            }
            else if (skinObj.tailType === 'snake') {
                 ctx.beginPath(); ctx.strokeStyle = '#2E8B57'; ctx.lineWidth = 6*s;
                 ctx.moveTo(tx, ty);
                 ctx.quadraticCurveTo(tx - 15*s, ty + 10*s, tx - 25*s, ty + 5*s); ctx.stroke();
            }
            else if (skinObj.tailType === 'devil') {
                ctx.strokeStyle = '#8B0000'; ctx.lineWidth = 4 * s;
                ctx.beginPath(); ctx.moveTo(tx, ty);
                ctx.quadraticCurveTo(tx + 15*s, ty + 5*s, tx + 25*s, ty - 20*s); ctx.stroke();
                // Triangle Tip
                ctx.fillStyle = '#8B0000'; ctx.beginPath();
                const ttx = tx + 25*s, tty = ty - 20*s;
                ctx.moveTo(ttx, tty); ctx.lineTo(ttx - 5*s, tty + 10*s); ctx.lineTo(ttx + 5*s, tty + 10*s); ctx.fill();
            }
        }

        // 6. Head
        if (skinObj.headType && skinObj.headType !== 'human') {
            drawHybridHead(p, headY, headRadius, s, skinObj.headType, skinObj);
        } else {
            // Standard Human Head
            // Ears
            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.ellipse(p.x - headRadius*0.9, headY, 3*s, 5*s, -0.1, 0, Math.PI*2);
            ctx.ellipse(p.x + headRadius*0.9, headY, 3*s, 5*s, 0.1, 0, Math.PI*2);
            ctx.fill();
            if(skinObj.ears === 'elf') { // Elf Ears
                 ctx.beginPath(); ctx.moveTo(p.x - headRadius*0.9, headY-5*s); ctx.lineTo(p.x - headRadius*1.5, headY-8*s); ctx.lineTo(p.x - headRadius*0.9, headY+5*s); ctx.fill();
                 ctx.beginPath(); ctx.moveTo(p.x + headRadius*0.9, headY-5*s); ctx.lineTo(p.x + headRadius*1.5, headY-8*s); ctx.lineTo(p.x + headRadius*0.9, headY+5*s); ctx.fill();
            }
        
        // Skull
        ctx.beginPath(); 
        ctx.ellipse(p.x, headY - 1*s, headRadius * 0.95, headRadius * 1.05, 0, 0, Math.PI*2); 
        ctx.fill();
        
        // Occipital Shadow (Base of skull)
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.beginPath(); ctx.arc(p.x, headY + headRadius*0.5, 4*s, 0, Math.PI*2); ctx.fill();
        
        // Hair
        if(skinObj.hairStyle === 'afro') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             ctx.beginPath(); ctx.arc(p.x, headY - 2*s, headRadius * 1.5, 0, Math.PI*2); ctx.fill();
        }
        else if(skinObj.hairStyle === 'short') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             ctx.beginPath(); ctx.arc(p.x, headY - 1*s, headRadius * 1.02, 0, Math.PI*2); ctx.fill();
        }
        else if(skinObj.hairStyle === 'bald') {
             ctx.fillStyle = 'rgba(255,255,255,0.2)';
             ctx.beginPath(); ctx.arc(p.x + 5*s, headY - 5*s, 3*s, 0, Math.PI*2); ctx.fill();
        }
        else if(skinObj.hairStyle === 'cornrows') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             ctx.beginPath(); ctx.arc(p.x, headY - 2*s, headRadius, Math.PI, 0); ctx.fill();
             ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1.5*s;
             for(let i=1; i<=3; i++) {
                 ctx.beginPath(); ctx.moveTo(p.x - (i*4*s), headY); ctx.lineTo(p.x - (i*2*s), headY - 12*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(p.x + (i*4*s), headY); ctx.lineTo(p.x + (i*2*s), headY - 12*s); ctx.stroke();
             }
             ctx.beginPath(); ctx.moveTo(p.x, headY); ctx.lineTo(p.x, headY - 12*s); ctx.stroke();
        }
        else if(skinObj.hairStyle === 'mohawk') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             ctx.beginPath(); ctx.ellipse(p.x, headY - 12*s, 4*s, 10*s, 0, 0, Math.PI*2); ctx.fill();
             for(let i=0; i<3; i++) { ctx.beginPath(); ctx.arc(p.x, headY - 15*s - (i*5*s), (4-i)*s, 0, Math.PI*2); ctx.fill(); }
        }
        else if(skinObj.hairStyle === 'long') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             ctx.beginPath(); ctx.moveTo(p.x - 12*s, headY - 5*s); ctx.lineTo(p.x - 15*s, headY + 15*s); ctx.lineTo(p.x + 15*s, headY + 15*s); ctx.lineTo(p.x + 12*s, headY - 5*s); ctx.arc(p.x, headY - 5*s, 12*s, 0, Math.PI, true); ctx.fill();
        }
        else if(skinObj.hairStyle === 'curly_long') {
             ctx.fillStyle = skinObj.hairColor || '#dcb98a';

             // Static Lion-like Mane
             const maneRadius = headRadius * 2.0;

             // Draw Mane (Static seed = 500)
             drawFuzzyCircle(p.x, headY + 5*s, maneRadius, ctx.fillStyle, 500, s, true);

             // Top/Forehead volume (Static seed = 501)
             drawFuzzyCircle(p.x, headY - headRadius * 0.5, headRadius * 1.2, ctx.fillStyle, 501, s, true);
        }
        else if(skinObj.hairStyle === 'spikes') {
             ctx.fillStyle = skinObj.hairColor || '#0000FF';
             ctx.beginPath(); ctx.arc(p.x, headY - 1*s, headRadius * 1.3, 0, Math.PI*2); ctx.fill();
             const numSpikes = 7;
             for(let i=0; i<numSpikes; i++) {
                 const angle = Math.PI + (i / (numSpikes-1)) * Math.PI; // Semicircle
                 const sx = p.x + Math.cos(angle) * 10*s;
                 const sy = (headY - 2*s) + Math.sin(angle) * 10*s;
                 const ex = p.x + Math.cos(angle) * 25*s;
                 const ey = (headY - 2*s) + Math.sin(angle) * 25*s;

                 ctx.beginPath();
                 ctx.moveTo(sx + Math.cos(angle+1.5)*6*s, sy + Math.sin(angle+1.5)*6*s);
                 ctx.lineTo(ex, ey);
                 ctx.lineTo(sx + Math.cos(angle-1.5)*6*s, sy + Math.sin(angle-1.5)*6*s);
                 ctx.fill();
             }
        }
        else if(skinObj.hairStyle === 'snakes') {
             ctx.strokeStyle = skinObj.hairColor || '#006400';
             ctx.lineWidth = 3*s;
             ctx.lineCap = 'round';
             const numSnakes = 8;
             for(let i=0; i<numSnakes; i++) {
                 const angle = Math.PI + (i / (numSnakes-1)) * Math.PI;
                 const sx = p.x + Math.cos(angle) * 8*s;
                 const sy = (headY - 5*s) + Math.sin(angle) * 8*s;

                 ctx.beginPath();
                 ctx.moveTo(sx, sy);
                 // Wavy snake
                 const cp1x = sx + Math.cos(angle) * 10*s + Math.random()*5*s;
                 const cp1y = sy + Math.sin(angle) * 10*s;
                 const cp2x = sx + Math.cos(angle) * 20*s - Math.random()*5*s;
                 const cp2y = sy + Math.sin(angle) * 20*s;
                 const ex = sx + Math.cos(angle) * 25*s;
                 const ey = sy + Math.sin(angle) * 25*s;

                 ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
                 ctx.stroke();

                 // Snake Head
                 ctx.fillStyle = skinObj.hairColor || '#006400';
                 ctx.beginPath(); ctx.arc(ex, ey, 2.5*s, 0, Math.PI*2); ctx.fill();
             }
        }

        if(skinObj.beard) {
             ctx.fillStyle = skinObj.beardColor || '#000';
             ctx.beginPath(); ctx.arc(p.x, headY, 12*s, 0.2, Math.PI - 0.2); ctx.lineTo(p.x, headY + 15*s); ctx.closePath(); ctx.fill();
        }

        // Headband
        if(skinObj.hairStyle === 'headband') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             ctx.beginPath(); ctx.arc(p.x, headY - 2*s, headRadius, Math.PI, 0); ctx.fill();
             ctx.strokeStyle = skinObj.headbandColor || '#FFF'; ctx.lineWidth = 4*s;
             ctx.beginPath(); ctx.moveTo(p.x-11*s, headY-5*s); ctx.lineTo(p.x+11*s, headY-5*s); ctx.stroke();
        }

        } // End of Standard Human Specifics (Ears, Hair)

        // 7. Shared Head Accessories
        if (skinObj.headAccessory === 'sombrero') {
            ctx.fillStyle = skinObj.hatColor || '#1a1a1a';
            ctx.beginPath(); ctx.ellipse(p.x, headY - 5*s, 30*s, 8*s, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(p.x, headY - 15*s, 10*s, Math.PI, 0); ctx.fill();
        }
        else if (skinObj.headAccessory === 'crown') {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath(); ctx.moveTo(p.x-8*s, headY-10*s); ctx.lineTo(p.x-4*s, headY-18*s); ctx.lineTo(p.x, headY-10*s);
            ctx.lineTo(p.x+4*s, headY-18*s); ctx.lineTo(p.x+8*s, headY-10*s); ctx.lineTo(p.x+8*s, headY-5*s); ctx.lineTo(p.x-8*s, headY-5*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'wizard_hat') {
            ctx.fillStyle = skinObj.hatColor || '#000080';
            ctx.beginPath(); ctx.moveTo(p.x-10*s, headY-5*s); ctx.lineTo(p.x+10*s, headY-5*s); ctx.lineTo(p.x, headY-30*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'chef_hat') {
             ctx.fillStyle = '#FFF'; ctx.fillRect(p.x-8*s, headY-25*s, 16*s, 15*s);
        }
        else if (skinObj.headAccessory === 'hat') {
             ctx.fillStyle = skinObj.hatColor || '#5D4037';
             ctx.beginPath(); ctx.ellipse(p.x, headY - 5*s, headRadius * 1.8, 4*s, 0, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x, headY - 10*s, headRadius * 0.9, Math.PI, 0); ctx.fill();
        }
        else if (skinObj.headAccessory === 'helmet') {
             ctx.fillStyle = skinObj.hatColor || '#87CEEB';
             ctx.beginPath(); ctx.arc(p.x, headY, headRadius + 1*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'horns') {
             ctx.fillStyle = 'red';
             ctx.beginPath(); ctx.moveTo(p.x-5*s, headY-10*s); ctx.lineTo(p.x-8*s, headY-18*s); ctx.lineTo(p.x-2*s, headY-10*s); ctx.fill();
             ctx.beginPath(); ctx.moveTo(p.x+5*s, headY-10*s); ctx.lineTo(p.x+8*s, headY-18*s); ctx.lineTo(p.x+2*s, headY-10*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'halo') {
             ctx.strokeStyle='#FFD700'; ctx.lineWidth=2*s; ctx.beginPath(); ctx.ellipse(p.x, headY-15*s, 8*s, 3*s, 0, 0, Math.PI*2); ctx.stroke();
        }
        else if (skinObj.headAccessory === 'beanie') {
             ctx.fillStyle = skinObj.hatColor || '#FF0000'; ctx.fillRect(p.x-10*s, headY-12*s, 20*s, 6*s);
        }
        else if (skinObj.headAccessory === 'red_nose') {
             ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(p.x, headY, 3*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'eyepatch') {
             ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(p.x+3*s, headY-2*s, 3*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'laurel') {
            ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2*s;
            ctx.beginPath(); ctx.arc(p.x, headY - 5*s, headRadius * 1.1, Math.PI, 0); ctx.stroke();
        }
        else if (skinObj.headAccessory === 'gold_bands') {
             ctx.fillStyle = '#FFD700';
             ctx.fillRect(p.x - 10*s, headY - 10*s, 20*s, 5*s);
             ctx.fillStyle = '#000080';
             ctx.fillRect(p.x - 10*s, headY - 10*s, 5*s, 5*s);
             ctx.fillRect(p.x + 5*s, headY - 10*s, 5*s, 5*s);
        }

        if (skinObj.headDetail === 'tattoo_stripe') {
             ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 3*s;
             ctx.beginPath(); ctx.moveTo(p.x - 2*s, headY - 12*s); ctx.lineTo(p.x - 4*s, headY + 10*s); ctx.stroke();
        }

        if (skinObj.headDetail === 'visor') {
             ctx.fillStyle = '#FFD700';
             ctx.fillRect(p.x - 10*s, headY - 5*s, 20*s, 6*s);
        }

        // Back Props (Cape, Wings, etc.)
        if (skinObj.backAccessory === 'cape') {
            ctx.fillStyle = skinObj.backColor || '#000';
            ctx.fillRect(p.x - bodyW/1.5, torsoY + 5*s, bodyW*1.3, bodyH*0.8);
        }
        if (skinObj.backAccessory === 'wings') {
            ctx.fillStyle = skinObj.backColor || '#FFF';
            ctx.beginPath(); ctx.ellipse(p.x - 20*s, torsoY + 10*s, 10*s, 20*s, -0.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(p.x + 20*s, torsoY + 10*s, 10*s, 20*s, 0.5, 0, Math.PI*2); ctx.fill();
        }
        if (skinObj.backAccessory === 'backpack') {
             ctx.fillStyle = skinObj.backColor || '#555';
             ctx.fillRect(p.x - bodyW/2, torsoY + 10*s, bodyW, bodyH*0.6);
             // Straps
             ctx.fillStyle = '#5D4037';
             ctx.fillRect(p.x - bodyW/2, torsoY + 15*s, bodyW, 5*s);
        }

        if (skinObj.backProp === 'quiver') {
             ctx.fillStyle = '#8B4513';
             ctx.beginPath(); ctx.moveTo(p.x + 5*s, torsoY); ctx.lineTo(p.x - 10*s, torsoY + 30*s); ctx.lineTo(p.x - 5*s, torsoY + 30*s); ctx.lineTo(p.x + 10*s, torsoY); ctx.fill();
             // Arrows
             ctx.fillStyle = '#FFF';
             ctx.beginPath(); ctx.arc(p.x + 8*s, torsoY - 5*s, 2*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x + 5*s, torsoY - 8*s, 2*s, 0, Math.PI*2); ctx.fill();
        }
        if (skinObj.backProp === 'spartan_gear') {
             // Shield on back? Or just shoulder pad? Let's do a shoulder pad/strap
             ctx.fillStyle = '#8B4513'; // Leather strap
             ctx.beginPath(); ctx.moveTo(p.x + bodyW/2, torsoY); ctx.lineTo(p.x - bodyW/2, torsoY + bodyH); ctx.lineTo(p.x - bodyW/2 + 5*s, torsoY + bodyH); ctx.lineTo(p.x + bodyW/2 + 5*s, torsoY); ctx.fill();
        }

        // New Props
        if (skinObj.backProp) {
             const bp = skinObj.backProp;
             const centerX = p.x;
             const centerY = torsoY + bodyH * 0.4;

             if (bp === 'axe') {
                 ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 4*s;
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 ctx.fillStyle = '#AAA';
                 ctx.beginPath();
                 ctx.moveTo(centerX - 15*s, centerY - 15*s);
                 ctx.lineTo(centerX - 20*s, centerY - 20*s);
                 ctx.quadraticCurveTo(centerX - 10*s, centerY - 25*s, centerX - 5*s, centerY - 15*s);
                 ctx.fill();
             }
             if (bp === 'guitar') {
                 ctx.fillStyle = '#8B4513';
                 ctx.beginPath();
                 ctx.ellipse(centerX, centerY, 12*s, 18*s, -0.2, 0, Math.PI*2);
                 ctx.fill();
                 ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(centerX, centerY, 5*s, 0, Math.PI*2); ctx.fill();
                 ctx.fillStyle = '#5D4037';
                 ctx.fillRect(centerX - 3*s, centerY - 30*s, 6*s, 20*s);
             }
             if (bp === 'oxygen_tank') {
                 ctx.fillStyle = '#FFF'; ctx.strokeStyle = '#AAA'; ctx.lineWidth = 1*s;
                 ctx.fillRect(centerX - 12*s, centerY - 15*s, 24*s, 35*s);
                 ctx.strokeRect(centerX - 12*s, centerY - 15*s, 24*s, 35*s);
                 ctx.strokeStyle = '#CCC'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX, centerY - 15*s); ctx.quadraticCurveTo(centerX, centerY - 25*s, centerX - 10*s, centerY - 20*s); ctx.stroke();
             }
             if (bp === 'katanas') {
                 ctx.strokeStyle = '#333'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX + 15*s, centerY - 15*s); ctx.lineTo(centerX - 15*s, centerY + 15*s); ctx.stroke();
                 ctx.fillStyle = '#000';
                 ctx.fillRect(centerX - 18*s, centerY - 18*s, 5*s, 5*s);
                 ctx.fillRect(centerX + 13*s, centerY - 18*s, 5*s, 5*s);
             }
             if (bp === 'sword') {
                 ctx.strokeStyle = '#555'; ctx.lineWidth = 4*s;
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(centerX - 15*s, centerY - 15*s, 5*s, 0, Math.PI*2); ctx.fill();
             }
             if (bp === 'hockey_sticks') {
                 ctx.strokeStyle = '#D2B48C'; ctx.lineWidth = 3*s; 
                 ctx.beginPath(); ctx.moveTo(centerX - 10*s, centerY - 20*s); ctx.lineTo(centerX + 10*s, centerY + 20*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX + 10*s, centerY - 20*s); ctx.lineTo(centerX - 10*s, centerY + 20*s); ctx.stroke();
                 ctx.fillStyle = '#000'; 
                 ctx.fillRect(centerX + 8*s, centerY + 18*s, 8*s, 4*s);
                 ctx.fillRect(centerX - 16*s, centerY + 18*s, 8*s, 4*s);
             }
             if (bp === 'staff') {
                 ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX + 15*s, centerY - 30*s); ctx.lineTo(centerX - 15*s, centerY + 30*s); ctx.stroke();
                 // Orb (Optimized)
                 const orbX = centerX + 15*s;
                 const orbY = centerY - 30*s;
                 const orbR = 5*s;
                 const glowR = orbR + 15;
                 const orbGrad = ctx.createRadialGradient(orbX, orbY, 0, orbX, orbY, glowR);
                 orbGrad.addColorStop(0, '#00FFFF');
                 orbGrad.addColorStop(orbR/glowR, '#00FFFF');
                 orbGrad.addColorStop(1, 'rgba(0, 255, 255, 0)');
                 ctx.fillStyle = orbGrad;
                 ctx.beginPath(); ctx.arc(orbX, orbY, glowR, 0, Math.PI*2); ctx.fill();
             }
             if (bp === 'windup_key') {
                 ctx.strokeStyle = '#C0C0C0'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(centerX, centerY + 10*s); ctx.stroke();
                 ctx.lineWidth = 2*s;
                 ctx.beginPath(); ctx.arc(centerX - 5*s, centerY, 5*s, 0, Math.PI*2); ctx.stroke();
                 ctx.beginPath(); ctx.arc(centerX + 5*s, centerY, 5*s, 0, Math.PI*2); ctx.stroke();
             }
             if (bp === 'barrel') {
                 ctx.fillStyle = '#8B4513'; ctx.strokeStyle = '#000'; ctx.lineWidth = 2*s;
                 ctx.fillRect(centerX - 12*s, centerY - 15*s, 24*s, 30*s);
                 ctx.strokeRect(centerX - 12*s, centerY - 15*s, 24*s, 30*s);
                 ctx.beginPath(); ctx.moveTo(centerX - 12*s, centerY - 5*s); ctx.lineTo(centerX + 12*s, centerY - 5*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX - 12*s, centerY + 5*s); ctx.lineTo(centerX + 12*s, centerY + 5*s); ctx.stroke();
             }
             if (bp === 'basket') {
                 ctx.fillStyle = '#D2B48C';
                 // Woven texture hint
                 ctx.fillRect(centerX - 10*s, centerY - 10*s, 20*s, 20*s);
                 ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 1*s;
                 ctx.strokeRect(centerX - 10*s, centerY - 10*s, 20*s, 20*s);
                 ctx.beginPath(); ctx.moveTo(centerX, centerY-10*s); ctx.lineTo(centerX, centerY+10*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX-10*s, centerY); ctx.lineTo(centerX+10*s, centerY); ctx.stroke();
                 // Eggs?
                 ctx.fillStyle = '#FFC0CB'; ctx.beginPath(); ctx.arc(centerX - 5*s, centerY - 12*s, 4*s, 0, Math.PI*2); ctx.fill();
                 ctx.fillStyle = '#00FFFF'; ctx.beginPath(); ctx.arc(centerX + 5*s, centerY - 12*s, 4*s, 0, Math.PI*2); ctx.fill();
             }
        }

        // Number
        if (skinObj.number) {
            ctx.fillStyle = skinObj.numberColor || "#FFF";
            ctx.font = `bold ${12 * s}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText(skinObj.number, p.x, torsoY + bodyH * 0.6);
        }

        // Shot Meter
        if (state === 'JUMPING') {
            const maxVz = 9; const curVz = Math.abs(getCurrentVz());
            let progress = 1.0 - (curVz / maxVz); progress = Math.max(0, Math.min(1, progress));
            const groundY = p.y + (player3D.z * s);
            const meterY = groundY - (130 * s * sizeMod.h);
            const cx = p.x + (60 * s); const radius = 50 * s;

            const thresh = calculateShotThreshold();
            const greenStart = 1.0 - (thresh / maxVz);

            if (playerData.meterEnabled) {
                drawShotMeter(cx, meterY, radius, s, progress, greenStart, playerData.meterShape || 'arc');
            }
        }
    }

    let g_cachedSkinId = null;
    let g_cachedSkinObj = null;

    function drawPlayer(p) {
        if (!p) return;
        const s = p.scale;
        const skin = playerData.currentSkin;

        let skinObj;
        if (skin === g_cachedSkinId && g_cachedSkinObj) {
            skinObj = g_cachedSkinObj;
        } else {
            skinObj = SKINS_DB.find(x => x.id === skin);
            if(!skinObj) skinObj = SKINS_DB[0];
            g_cachedSkinId = skin;
            g_cachedSkinObj = skinObj;
        }

        const currentAnimal = skinObj.animal;
        
        if (currentAnimal === 'human') {
            drawRealisticHuman(p, s, skinObj);
            return;
        }

        let sizeMod = { w: 1, h: 1, head: 1 };
        switch(currentAnimal) {
            case 'rat': sizeMod = { w: 0.7, h: 0.7, head: 0.8 }; break;
            case 'cat': sizeMod = { w: 0.8, h: 0.8, head: 0.9 }; break;
            case 'rabbit': sizeMod = { w: 0.8, h: 0.8, head: 0.9 }; break;
            case 'dog': sizeMod = { w: 1.0, h: 1.0, head: 1.0 }; break;
            case 'moose': sizeMod = { w: 1.2, h: 1.3, head: 1.1 }; break;
            case 'bear': sizeMod = { w: 1.4, h: 1.1, head: 1.2 }; break;
            case 'human': sizeMod = { w: 0.9, h: 1.1, head: 0.9 }; break;
            case 'fox': sizeMod = { w: 0.9, h: 0.9, head: 0.95 }; break;
            case 'wolf': sizeMod = { w: 1.1, h: 1.1, head: 1.1 }; break;
            case 'lion': sizeMod = { w: 1.3, h: 1.2, head: 1.25 }; break;
            case 'tiger': sizeMod = { w: 1.3, h: 1.2, head: 1.2 }; break;
            case 'pig': sizeMod = { w: 1.1, h: 0.9, head: 1.0 }; break;
            case 'cow': sizeMod = { w: 1.3, h: 1.3, head: 1.2 }; break;
            case 'monkey': sizeMod = { w: 0.85, h: 0.9, head: 0.9 }; break;
            case 'penguin': sizeMod = { w: 1.0, h: 0.8, head: 0.9 }; break;
        }

        // Determine if Furry
        let isFurry = !skin.includes('robot') && !skin.includes('astronaut') && !skin.includes('alien') && !skin.includes('ninja');
        if (currentAnimal === 'human') isFurry = false;
        if (currentAnimal === 'penguin') isFurry = false; // Smooth feathers

        // 0. Calculate Arm Config EARLY
        const currentStyle = playerData.currentStyle || 'classic';
        const anim = ANIM_DATA[currentStyle] || ANIM_DATA['classic'];
        const idle = DEFAULT_IDLE;
        const lerp = (a, b, t) => a + (b - a) * t;

        // Calculate generic (Right-Handed) angles first
        let r_la, r_ra, r_lfa, r_rfa, r_w;

        if (state === 'SHOOTING') {
            r_la = anim.release.la; r_ra = anim.release.ra;
            r_lfa = anim.release.lfa; r_rfa = anim.release.rfa;
            r_w = anim.release.w;
        } else if (state === 'JUMPING') {
            let lift = Math.max(0, (9 - getCurrentVz()) / 9);
            lift = Math.min(1.0, lift); // Clamp
            const startPose = anim.ready || idle;
            const lerpAngle = (a, b, t) => {
                if (Math.abs(b - a) > Math.PI) {
                    if (b > a) a += 2 * Math.PI;
                    else b += 2 * Math.PI;
                }
                return a + (b - a) * t;
            };
            r_la = lerpAngle(startPose.la, anim.set.la, lift);
            r_ra = lerpAngle(startPose.ra, anim.set.ra, lift);
            r_lfa = lerpAngle(startPose.lfa, anim.set.lfa, lift);
            r_rfa = lerpAngle(startPose.rfa, anim.set.rfa, lift);
            r_w = lerp(startPose.w, anim.set.w, lift);
        } else {
            r_la = idle.la; r_ra = idle.ra;
            r_lfa = idle.lfa; r_rfa = idle.rfa;
            r_w = idle.w;
        }

        let leftArmAngle, rightArmAngle, leftForeArmAngle, rightForeArmAngle, wristAngle;
        const isLefty = playerData.isLefty;
        if (isLefty) {
            leftArmAngle = Math.PI - r_ra; rightArmAngle = Math.PI - r_la;
            leftForeArmAngle = Math.PI - r_rfa; rightForeArmAngle = Math.PI - r_lfa;
            wristAngle = -r_w;
        } else {
            leftArmAngle = r_la; rightArmAngle = r_ra;
            leftForeArmAngle = r_lfa; rightForeArmAngle = r_rfa;
            wristAngle = r_w;
        }

        let bodyW = 20 * s * sizeMod.w; let bodyH = 40 * s * sizeMod.h;
        if(currentAnimal === 'bear') bodyW = 30 * s * sizeMod.w;
        let legLen = 30 * s * sizeMod.h;
        let torsoY = p.y - legLen - bodyH;
        let headY = torsoY - (10 * s * sizeMod.head);
        let headRadius = 12 * s * sizeMod.head;

        let shoulderY = torsoY + (5*s);
        let leftShoulderX = p.x - 12*s; let rightShoulderX = p.x + 12*s;
        let upperArmLen = 20 * s * sizeMod.h * 1.05; let foreArmLen = 20 * s * sizeMod.h * 1.05;

        // 0b. Detached Ball Rendering
        drawDetachedBall(p, s, torsoY, bodyH, headY);

        // 0c. HELD BALL RENDERING (Layer 0)
        const isDetachedStyle = ['airbud', 'telekinesis'].includes(playerData.currentStyle);
        if (!isDetachedStyle && state !== 'SHOOTING' && state !== 'GAMEOVER') {
             const isRightHand = !isLefty;
             const shootUAngle = isRightHand ? rightArmAngle : leftArmAngle;
             const shootFAngle = isRightHand ? rightForeArmAngle : leftForeArmAngle;
             const shootSX = isRightHand ? rightShoulderX : leftShoulderX;

             let elbow = getJoint(shootSX, shoulderY, upperArmLen, shootUAngle);
             let wrist = getJoint(elbow.x, elbow.y, foreArmLen, shootFAngle);

             let theta = shootFAngle + wristAngle;
             let ballX = wrist.x + Math.cos(theta) * 0 - Math.sin(theta) * 5 * s;
             let ballY = wrist.y + Math.sin(theta) * 0 + Math.cos(theta) * 5 * s;

             drawBallSprite(ballX, ballY, s, (currentStreak >= 5));
        }

        // 1. Setup Base Colors
        let furColor = '#555', tailColor = '#FFC0CB', torsoColor = '#555', legColor = '#555', armColor = '#555';
        let thighColor = '#555', calfColor = '#555';
        let bellyColor = null, hasSpots = false, hasBlackEars = false;

        if (skin === 'bear_panda') hasBlackEars = true;

        if(currentAnimal === 'rat') { furColor = '#696969'; tailColor = '#FFC0CB'; }
        else if(currentAnimal === 'cat') { furColor = '#808080'; tailColor = '#808080'; }
        else if(currentAnimal === 'dog') { furColor = '#8B4513'; tailColor = '#8B4513'; }
        else if(currentAnimal === 'bear') { furColor = '#4B3621'; tailColor = '#4B3621'; }
        else if(currentAnimal === 'rabbit') { furColor = '#fff'; tailColor = '#fff'; }
        else if(currentAnimal === 'moose') { furColor = '#5D4037'; tailColor = '#5D4037'; }
        else if(currentAnimal === 'fox') { furColor = '#D2691E'; tailColor = '#D2691E'; }
        else if(currentAnimal === 'wolf') { furColor = '#808080'; tailColor = '#808080'; }
        else if(currentAnimal === 'lion') { furColor = '#DAA520'; tailColor = '#DAA520'; }
        else if(currentAnimal === 'tiger') { furColor = '#FFA500'; tailColor = '#FFA500'; }
        else if(currentAnimal === 'pig') { furColor = '#FFC0CB'; tailColor = '#FFC0CB'; }
        else if(currentAnimal === 'cow') { furColor = '#FFF'; tailColor = '#FFF'; }
        else if(currentAnimal === 'monkey') { furColor = '#8B4513'; tailColor = '#8B4513'; }
        else if(currentAnimal === 'penguin') { furColor = '#000'; tailColor = '#000'; }
        else if(currentAnimal === 'human') {
            furColor = skinObj.skinTone || '#8d5524';
            tailColor = 'transparent';
        }

        // 2. Apply Skin Overrides (Data Driven)
        // Biological overrides first
        if (skinObj.furColor) { furColor = skinObj.furColor; tailColor = skinObj.furColor; }
        if (skinObj.hasSpots) hasSpots = true;

        if (skin.includes('alien')) { furColor = '#32CD32'; tailColor = '#32CD32'; }
        if (skin.includes('zombie')) { furColor = '#98FB98'; }
        if (skin.includes('robot')) { furColor = '#C0C0C0'; }

        // Default clothes to fur color (naked)
        torsoColor = furColor; legColor = furColor; armColor = furColor;
        thighColor = legColor; calfColor = legColor;

        // Clothing overrides
        torsoColor = skinObj.jerseyColor || furColor;
        thighColor = skinObj.shortsColor || furColor;
        calfColor = furColor; // Default exposed calf

        // Arms: Default to fur, check for sleeves
        armColor = furColor;
        if (skinObj.sleeveColor) armColor = skinObj.sleeveColor;

        // Legs: If "trousers" (long pants), calf follows thigh color
        if (skinObj.legType === 'pants') calfColor = thighColor;

        // Panda Logic (Black limbs)
        if (skinObj.legType === 'panda_limbs') {
            legColor = '#000'; thighColor = '#000'; calfColor = '#000'; armColor = '#000';
        }

        // 2. Legs (Base implementation)
        const baseKneeY = p.y - (legLen * 0.5);
        let lKneeX = p.x - 9*s, lKneeY = baseKneeY;
        let rKneeX = p.x + 9*s, rKneeY = baseKneeY;
        let lFootX = p.x - 10*s, lFootY = p.y;
        let rFootX = p.x + 10*s, rFootY = p.y;

        // Dirk Kick Logic
        if (state === 'JUMPING' && playerData.currentStyle === 'dirk') {
            const lift = Math.min(1.0, Math.max(0, (9 - getCurrentVz()) / 9));
            const kickH = 20 * s * lift;
            const kickW = 15 * s * lift;
            if (playerData.isLefty) {
                 lKneeY -= kickH; lKneeX -= kickW; lFootX -= kickW; lFootY -= kickH*0.8;
            } else {
                 rKneeY -= kickH; rKneeX += kickW; rFootX += kickW; rFootY -= kickH*0.8;
            }
        }

        const legFurry = isFurry && (legColor === furColor);
        drawFuzzyLimb(p.x - 8*s, p.y - legLen, lKneeX, lKneeY, 7*s*sizeMod.w, thighColor, s, legFurry, 1); // Left Thigh
        drawFuzzyLimb(p.x + 8*s, p.y - legLen, rKneeX, rKneeY, 7*s*sizeMod.w, thighColor, s, legFurry, 3); // Right Thigh

        // Calves & Socks/Shoes
        const drawLowerLeg = (xTop, yTop, xBot, yBot, isRight) => {
             const calfBaseColor = calfColor;
             // Draw Base Calf
             drawFuzzyLimb(xTop, yTop, xBot, yBot, 6*s*sizeMod.w, calfBaseColor, s, legFurry, isRight?4:2);

             // Socks & Shoes Overlay
             if(skinObj.socksColor || skinObj.shoesColor) {
                 const shoeH = 5 * s; const sockH = 7 * s;
                 // Calculate local Y relative to the foot Y
                 const ankleY = yBot - shoeH; const sockY = ankleY - sockH;

                 // Interpolate X/Y
                 const getXAtY = (y) => {
                     const t = (y - yTop) / (yBot - yTop);
                     return xTop + (xBot - xTop) * t;
                 };

                 if(skinObj.socksColor) {
                     const sockTopX = getXAtY(sockY);
                     const ankleX = getXAtY(ankleY);
                     drawFuzzyLimb(sockTopX, sockY, ankleX, ankleY, 5.8*s*sizeMod.w, skinObj.socksColor, s, false, 0);
                 }
                 if(skinObj.shoesColor) {
                     const ankleX = getXAtY(ankleY);
                     drawFuzzyLimb(ankleX, ankleY, xBot, yBot, 6*s*sizeMod.w, skinObj.shoesColor, s, false, 0);
                     // Shoe Foot
                     ctx.fillStyle = skinObj.shoesColor;
                     ctx.beginPath(); ctx.ellipse(xBot, yBot + 1*s, 4.5*s, 2.5*s, 0, 0, Math.PI*2); ctx.fill();
                 }
             }
        };

        drawLowerLeg(lKneeX, lKneeY, lFootX, lFootY, false); // Left
        drawLowerLeg(rKneeX, rKneeY, rFootX, rFootY, true); // Right

        const drawSegmentedArm = (sx, sy, isRight, angle1, angle2) => {
            const armFurry = isFurry && (armColor === furColor);
            const seedBase = isRight ? 10 : 20;
            const isShootingSide = (isLefty && !isRight) || (!isLefty && isRight);

            let thisUpperColor = armColor;
            let thisForeColor = armColor;

            // T-Shirt Logic
            if(skinObj.jerseyType === 'tshirt') {
                thisUpperColor = torsoColor;
            }

            // Sleeve Logic (Physical side based)
            if(isRight && skinObj.sleeveRight) {
                thisUpperColor = skinObj.sleeveRight;
                thisForeColor = skinObj.sleeveRight;
            }
            if(!isRight && skinObj.sleeveLeft) {
                thisUpperColor = skinObj.sleeveLeft;
                thisForeColor = skinObj.sleeveLeft;
            }

            let elbow = getJoint(sx, sy, upperArmLen, angle1);
            drawFuzzyLimb(sx, sy, elbow.x, elbow.y, 6*s*sizeMod.w, thisUpperColor, s, armFurry, seedBase);
            let wrist = getJoint(elbow.x, elbow.y, foreArmLen, angle2);
            drawFuzzyLimb(elbow.x, elbow.y, wrist.x, wrist.y, 5*s*sizeMod.w, thisForeColor, s, armFurry, seedBase + 1);

            ctx.save(); ctx.translate(wrist.x, wrist.y); ctx.rotate(angle2 + (isShootingSide ? wristAngle : 0));
            ctx.fillStyle = thisForeColor; ctx.beginPath(); ctx.arc(0, 0, 5*s, 0, Math.PI*2); ctx.fill();
            if (wristAngle > 0.5 && isShootingSide) {
                 if(skin.includes('hockey')) { ctx.strokeStyle='#8B4513'; ctx.lineWidth=3*s; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, 40*s); ctx.lineTo(10*s, 45*s); ctx.stroke(); }
            }

            // Ball removed (drawn earlier)
            ctx.restore();
        };

        drawSegmentedArm(leftShoulderX, shoulderY, false, leftArmAngle, leftForeArmAngle);
        drawSegmentedArm(rightShoulderX, shoulderY, true, rightArmAngle, rightForeArmAngle);

        // 6. Draw Body (Layer 2)
        const bodyFurry = isFurry && (torsoColor === furColor);
        let bodyOptions = {};
        if (currentAnimal === 'bear') { bodyOptions.waistScale = 1.35; bodyOptions.roundness = 0.25; }
        if (currentAnimal === 'pig' || currentAnimal === 'cow') { bodyOptions.waistScale = 1.1; bodyOptions.roundness = 0.15; }
        if (skin === 'bear_panda') bodyOptions.chestStripeColor = '#000';
        drawAnatomicBody(p.x, torsoY, bodyW, bodyH, s, torsoColor, bodyFurry, 40, bodyOptions);

        if(currentAnimal === 'penguin' && torsoColor === furColor) {
             ctx.fillStyle = '#FFF';
             ctx.beginPath(); ctx.ellipse(p.x, torsoY + bodyH * 0.55, bodyW * 0.7, bodyH * 0.4, 0, 0, Math.PI*2); ctx.fill();
        }
        if(skinObj.pattern === 'tiger_stripes') {
             ctx.strokeStyle = '#000'; ctx.lineWidth = 2*s;
             // Body stripes
             ctx.beginPath(); ctx.moveTo(p.x - bodyW/2, torsoY + 10*s); ctx.lineTo(p.x - bodyW/4, torsoY + 15*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x + bodyW/2, torsoY + 10*s); ctx.lineTo(p.x + bodyW/4, torsoY + 15*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x - bodyW/2, torsoY + 25*s); ctx.lineTo(p.x - bodyW/4, torsoY + 30*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x + bodyW/2, torsoY + 25*s); ctx.lineTo(p.x + bodyW/4, torsoY + 30*s); ctx.stroke();
        }
        if(skinObj.pattern === 'cow_spots') {
             ctx.fillStyle = (skin === 'cow_strawberry') ? '#FF69B4' : '#000';
             ctx.beginPath(); ctx.arc(p.x - 5*s, torsoY + 10*s, 6*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x + 8*s, torsoY + 25*s, 5*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x - 2*s, torsoY + 30*s, 4*s, 0, Math.PI*2); ctx.fill();
        }

        if(hasSpots) { ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.x, torsoY + 20*s, 4*s, 0, Math.PI*2); ctx.fill(); }
        if(skin.includes('tabby')) { ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 2*s; ctx.beginPath(); ctx.moveTo(p.x-5*s, torsoY+10*s); ctx.lineTo(p.x+5*s, torsoY+10*s); ctx.stroke(); }
        // Pattern Rendering
        if(skinObj.pattern === 'plaid') {
             ctx.strokeStyle = '#000'; ctx.lineWidth = 1*s;
             ctx.beginPath(); ctx.moveTo(p.x-bodyW/2, torsoY+10*s); ctx.lineTo(p.x+bodyW/2, torsoY+10*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x-bodyW/2, torsoY+20*s); ctx.lineTo(p.x+bodyW/2, torsoY+20*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x-bodyW/2, torsoY+30*s); ctx.lineTo(p.x+bodyW/2, torsoY+30*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x, torsoY); ctx.lineTo(p.x, torsoY+bodyH); ctx.stroke();
        }
        else if(skinObj.pattern === 'stripes') { // Referee or Bandit
             ctx.fillStyle = '#000';
             ctx.fillRect(p.x-5*s, torsoY, 10*s, bodyH); // Center stripe
             ctx.fillRect(p.x-15*s, torsoY, 5*s, bodyH); // Left stripe
             ctx.fillRect(p.x+10*s, torsoY, 5*s, bodyH); // Right stripe
        }
        else if(skinObj.pattern === 'suit') { // Tuxedo button
             ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.x, torsoY + 15*s, 2*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x, torsoY + 25*s, 2*s, 0, Math.PI*2); ctx.fill();
             // Bowtie
             ctx.fillStyle = 'red';
             ctx.beginPath(); ctx.moveTo(p.x, torsoY+5*s); ctx.lineTo(p.x-5*s, torsoY+2*s); ctx.lineTo(p.x-5*s, torsoY+8*s); ctx.fill();
             ctx.beginPath(); ctx.moveTo(p.x, torsoY+5*s); ctx.lineTo(p.x+5*s, torsoY+2*s); ctx.lineTo(p.x+5*s, torsoY+8*s); ctx.fill();
        }

        // Clothing Details (New Layer)
        if(skinObj.clothingDetail === 'suspenders') {
             ctx.fillStyle = '#1a1a1a'; // Dark suspenders
             // Left
             ctx.fillRect(p.x - bodyW/2 + 2*s, torsoY, 3*s, bodyH);
             // Right
             ctx.fillRect(p.x + bodyW/2 - 5*s, torsoY, 3*s, bodyH);
        }
        if(skinObj.clothingDetail === 'apron_ties') {
             ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2*s;
             ctx.beginPath();
             ctx.moveTo(p.x, torsoY + bodyH*0.6);
             ctx.lineTo(p.x - 10*s, torsoY + bodyH*0.6 + 5*s); // Left hanging
             ctx.moveTo(p.x, torsoY + bodyH*0.6);
             ctx.lineTo(p.x + 10*s, torsoY + bodyH*0.6 + 5*s); // Right hanging
             // Knot
             ctx.fillStyle='#FFF'; ctx.beginPath(); ctx.arc(p.x, torsoY+bodyH*0.6, 3*s, 0, Math.PI*2); ctx.fill();
             ctx.stroke();
        }
        if(skinObj.clothingDetail === 'overalls') {
             ctx.fillStyle = skinObj.shortsColor || '#000080';
             // Bib
             ctx.fillRect(p.x - bodyW*0.3, torsoY + bodyH*0.3, bodyW*0.6, bodyH*0.4);
             // Straps
             ctx.fillRect(p.x - bodyW*0.3, torsoY, bodyW*0.1, bodyH*0.3);
             ctx.fillRect(p.x + bodyW*0.2, torsoY, bodyW*0.1, bodyH*0.3);
        }
        if(skinObj.clothingDetail === 'stitches') {
             ctx.strokeStyle = '#000'; ctx.lineWidth = 1*s;
             // Random stitches
             ctx.beginPath(); ctx.moveTo(p.x-5*s, torsoY+10*s); ctx.lineTo(p.x-5*s, torsoY+15*s); ctx.moveTo(p.x-8*s, torsoY+12*s); ctx.lineTo(p.x-2*s, torsoY+12*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x+5*s, torsoY+25*s); ctx.lineTo(p.x+5*s, torsoY+30*s); ctx.moveTo(p.x+2*s, torsoY+27*s); ctx.lineTo(p.x+8*s, torsoY+27*s); ctx.stroke();
             // Head stitch
             ctx.beginPath(); ctx.moveTo(p.x, headY-headRadius); ctx.lineTo(p.x, headY-headRadius+5*s); ctx.moveTo(p.x-3*s, headY-headRadius+2*s); ctx.lineTo(p.x+3*s, headY-headRadius+2*s); ctx.stroke();
        }

        // 7. Draw Tail (Layer 3)
        if(currentAnimal !== 'bear' && currentAnimal !== 'human' && !skin.includes('astronaut') && !skin.includes('robot')) {
            const tx = p.x; const ty = p.y - legLen - 5*s;
            if (skinObj.tailType === 'devil') {
                ctx.strokeStyle = '#8B0000'; ctx.lineWidth = 4 * s;
                ctx.beginPath(); ctx.moveTo(tx, ty);
                ctx.quadraticCurveTo(tx + 15*s, ty + 5*s, tx + 25*s, ty - 20*s); ctx.stroke();
                // Triangle Tip
                ctx.fillStyle = '#8B0000'; ctx.beginPath();
                const ttx = tx + 25*s, tty = ty - 20*s;
                ctx.moveTo(ttx, tty); ctx.lineTo(ttx - 5*s, tty + 10*s); ctx.lineTo(ttx + 5*s, tty + 10*s); ctx.fill();
            }
            else if (currentAnimal === 'fox' || currentAnimal === 'wolf' || skinObj.tailType === 'multi') {
                // Bushy Tail
                const tailPoints = [
                    {x: tx, y: ty},
                    {x: tx + 15*s, y: ty + 5*s},
                    {x: tx + 30*s, y: ty - 10*s}, // Tip
                    {x: tx + 15*s, y: ty - 15*s}
                ];
                let tColor = tailColor;
                if(skinObj.tailType === 'multi') { // Kitsune
                    for(let k=0; k<3; k++) {
                        const off = (k-1)*10*s;
                        drawFuzzyPath([{x:tx,y:ty},{x:tx+15*s+off,y:ty+5*s},{x:tx+30*s+off,y:ty-10*s},{x:tx+15*s+off,y:ty-15*s}], '#FFD700', s, true, 100+k);
                    }
                } else {
                    drawFuzzyPath(tailPoints, tColor, s, true, 99);
                    // White tip for classic fox
                    if(currentAnimal === 'fox' && skin === 'fox_classic') {
                        const tipPoints = [{x: tx + 20*s, y: ty - 5*s}, {x: tx + 30*s, y: ty - 10*s}, {x: tx + 20*s, y: ty - 12*s}];
                        drawFuzzyPath(tipPoints, '#FFF', s, true, 100);
                    }
                }
            }
            else if (currentAnimal === 'pig') {
                // Curly Tail
                ctx.beginPath(); ctx.strokeStyle = tailColor; ctx.lineWidth = 3 * s;
                ctx.moveTo(tx, ty);
                ctx.bezierCurveTo(tx + 10*s, ty - 5*s, tx + 10*s, ty + 10*s, tx + 20*s, ty);
                ctx.stroke();
            }
            else if (currentAnimal === 'lion' || currentAnimal === 'cow') {
                // Tufted Tail
                ctx.beginPath(); ctx.strokeStyle = tailColor; ctx.lineWidth = 3 * s;
                ctx.moveTo(tx, ty);
                ctx.quadraticCurveTo(tx + 15*s, ty + 10*s, tx + 25*s, ty + 5*s); ctx.stroke();
                // Tuft
                const tuftColor = (currentAnimal === 'lion') ? '#8B4513' : '#000';
                if(currentAnimal === 'cow' && skinObj.furColor === '#8B0000') tuftColor = '#8B0000'; // Highland
                drawFuzzyPath([{x: tx+25*s, y: ty+5*s}, {x: tx+35*s, y: ty+8*s}, {x: tx+35*s, y: ty+2*s}], tuftColor, s, true, 101);
            }
            else if (currentAnimal === 'penguin') {
                // Stubby Tail
                ctx.fillStyle = tailColor;
                ctx.beginPath(); ctx.moveTo(tx, ty); ctx.lineTo(tx + 10*s, ty + 5*s); ctx.lineTo(tx + 5*s, ty + 10*s); ctx.fill();
            }
            else {
                // Standard Thin Tail
                ctx.beginPath(); ctx.strokeStyle = tailColor; ctx.lineWidth = 4 * s;
                ctx.lineCap = 'round'; ctx.moveTo(tx, ty);
                ctx.quadraticCurveTo(tx + 15*s, ty + 5*s, tx + 20*s, ty - 10*s); ctx.stroke();
                if(currentAnimal === 'tiger' || skinObj.pattern === 'tiger_stripes') {
                    // Stripes on tail
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 2*s;
                    ctx.beginPath(); ctx.moveTo(tx+5*s, ty); ctx.lineTo(tx+5*s, ty+3*s); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(tx+10*s, ty); ctx.lineTo(tx+10*s, ty+3*s); ctx.stroke();
                }
            }
        }

        // 8. Draw Head & Ears (Layer 4)
        ctx.fillStyle = (hasBlackEars) ? '#000' : furColor;
        if(skin.includes('alien')) ctx.fillStyle = '#32CD32';

        // EARS & HORNS
        if(currentAnimal === 'rat') {
            drawFuzzyCircle(p.x - 12*s, headY - 5*s, 7*s, ctx.fillStyle, 51, s, isFurry);
            drawFuzzyCircle(p.x + 12*s, headY - 5*s, 7*s, ctx.fillStyle, 52, s, isFurry);
        } else if (currentAnimal === 'cat') {
            const earL = [{x: p.x-5*s, y: headY-8*s}, {x: p.x-15*s, y: headY-20*s}, {x: p.x-15*s, y: headY}];
            const earR = [{x: p.x+5*s, y: headY-8*s}, {x: p.x+15*s, y: headY-20*s}, {x: p.x+15*s, y: headY}];
            drawFuzzyPath(earL, ctx.fillStyle, s, true, 53);
            drawFuzzyPath(earR, ctx.fillStyle, s, true, 54);
        } else if (currentAnimal === 'fox' || currentAnimal === 'wolf') {
            // Pointy Ears
            const h = (currentAnimal === 'wolf') ? 18*s : 22*s;
            const w = (currentAnimal === 'wolf') ? 10*s : 12*s;
            const earL = [{x: p.x-5*s, y: headY-8*s}, {x: p.x-12*s, y: headY-h}, {x: p.x-w-5*s, y: headY-5*s}];
            const earR = [{x: p.x+5*s, y: headY-8*s}, {x: p.x+12*s, y: headY-h}, {x: p.x+w+5*s, y: headY-5*s}];
            drawFuzzyPath(earL, ctx.fillStyle, s, true, 53);
            drawFuzzyPath(earR, ctx.fillStyle, s, true, 54);
            // Inner Ear (White/Pink)
            ctx.fillStyle = (currentAnimal === 'wolf') ? '#AAA' : '#FFF';
            ctx.beginPath(); ctx.moveTo(p.x-8*s, headY-10*s); ctx.lineTo(p.x-12*s, headY-h+5*s); ctx.lineTo(p.x-15*s, headY-10*s); ctx.fill();
            ctx.beginPath(); ctx.moveTo(p.x+8*s, headY-10*s); ctx.lineTo(p.x+12*s, headY-h+5*s); ctx.lineTo(p.x+15*s, headY-10*s); ctx.fill();
        } else if (currentAnimal === 'rabbit') {
             ctx.beginPath(); ctx.ellipse(p.x-8*s, headY-20*s, 5*s, 15*s, -0.2, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.ellipse(p.x+8*s, headY-20*s, 5*s, 15*s, 0.2, 0, Math.PI*2); ctx.fill();
        } else if (currentAnimal === 'bear' || currentAnimal === 'dog' || currentAnimal === 'lion' || currentAnimal === 'tiger' || currentAnimal === 'monkey') {
            let earY = headY - 8*s; let earX = 10*s; let earR = 5*s;
            if(currentAnimal === 'monkey') { earY = headY; earX = 14*s; earR = 4*s; }
            if(currentAnimal === 'lion' || currentAnimal === 'tiger') { earX = 12*s; earR = 6*s; }
            drawFuzzyCircle(p.x - earX, earY, earR, ctx.fillStyle, 55, s, isFurry);
            drawFuzzyCircle(p.x + earX, earY, earR, ctx.fillStyle, 56, s, isFurry);
        } else if (currentAnimal === 'pig' || currentAnimal === 'cow') {
            const earColor = ctx.fillStyle;
            ctx.beginPath(); ctx.ellipse(p.x - 14*s, headY - 2*s, 6*s, 4*s, 0.2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(p.x + 14*s, headY - 2*s, 6*s, 4*s, -0.2, 0, Math.PI*2); ctx.fill();
        } else if (currentAnimal === 'human') {
            // Human Ears
            ctx.fillStyle = furColor;
            ctx.beginPath(); ctx.ellipse(p.x - 12*s, headY, 3*s, 6*s, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(p.x + 12*s, headY, 3*s, 6*s, 0, 0, Math.PI*2); ctx.fill();
            if(skinObj.hairStyle === 'afro') {
                 ctx.fillStyle = skinObj.hairColor || '#000';
                 ctx.beginPath(); ctx.arc(p.x, headY - 2*s, headRadius * 1.5, 0, Math.PI*2); ctx.fill();
            }
        }
        if(currentAnimal === 'moose') {
            ctx.strokeStyle = '#5D4037'; ctx.lineWidth = 4*s;
            ctx.beginPath(); ctx.moveTo(p.x-10*s, headY-10*s); ctx.lineTo(p.x-30*s, headY-25*s); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(p.x+10*s, headY-10*s); ctx.lineTo(p.x+30*s, headY-25*s); ctx.stroke();
        }
        if(currentAnimal === 'cow') {
            ctx.fillStyle = '#EEE';
            ctx.beginPath(); ctx.moveTo(p.x-5*s, headY-10*s); ctx.quadraticCurveTo(p.x-15*s, headY-20*s, p.x-12*s, headY-25*s); ctx.lineTo(p.x-8*s, headY-15*s); ctx.fill();
            ctx.beginPath(); ctx.moveTo(p.x+5*s, headY-10*s); ctx.quadraticCurveTo(p.x+15*s, headY-20*s, p.x+12*s, headY-25*s); ctx.lineTo(p.x+8*s, headY-15*s); ctx.fill();
        }

        // MANE (Lion)
        if(currentAnimal === 'lion' && skin !== 'lion_scar') {
             ctx.fillStyle = '#8B4513';
             if(skin === 'lion_white') ctx.fillStyle = '#EEE';
             if(skin === 'lion_classic') ctx.fillStyle = '#A0522D';
             drawFuzzyCircle(p.x, headY, headRadius * 1.6, ctx.fillStyle, 61, s, isFurry);
        }

        // Head Circle
        let headColor = furColor;
        if(skin.includes('alien')) headColor = '#32CD32';
        if(currentAnimal === 'penguin') headColor = '#000';
        if(currentAnimal === 'lion' && skin !== 'lion_scar') {
             if(skin === 'lion_white') headColor = '#EEE';
             else if(skin === 'lion_classic') headColor = '#A0522D';
             else headColor = '#8B4513';
        }

        drawFuzzyCircle(p.x, headY, headRadius, headColor, 60, s, isFurry);

        // FOREHEAD MANE (Lion) - Fix baldness
        if(currentAnimal === 'lion' && skin !== 'lion_scar') {
             ctx.fillStyle = '#8B4513';
             if(skin === 'lion_white') ctx.fillStyle = '#EEE';
             if(skin === 'lion_classic') ctx.fillStyle = '#A0522D';
             // Draw a smaller fuzzy circle slightly higher to cover the "bald" spot
             drawFuzzyCircle(p.x, headY - headRadius * 0.5, headRadius * 0.8, ctx.fillStyle, 62, s, isFurry);
        }

        // FACE DETAILS REMOVED - Back View Only

        if(skinObj.pattern === 'tiger_stripes') {
             ctx.strokeStyle = '#000'; ctx.lineWidth = 1*s;
             ctx.beginPath(); ctx.moveTo(p.x, headY - 10*s); ctx.lineTo(p.x, headY - 5*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x - 5*s, headY - 8*s); ctx.lineTo(p.x - 2*s, headY - 4*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x + 5*s, headY - 8*s); ctx.lineTo(p.x + 2*s, headY - 4*s); ctx.stroke();
        }

        // Head Details
        if(skinObj.headDetail === 'antenna') {
             ctx.strokeStyle = '#C0C0C0'; ctx.lineWidth = 2*s;
             ctx.beginPath(); ctx.moveTo(p.x, headY - headRadius); ctx.lineTo(p.x, headY - headRadius - 15*s); ctx.stroke();
             ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(p.x, headY - headRadius - 15*s, 3*s, 0, Math.PI*2); ctx.fill();
        }
        if(skinObj.headDetail === 'bandana_ties') {
             ctx.fillStyle = 'red';
             ctx.beginPath(); ctx.moveTo(p.x + headRadius, headY);
             ctx.lineTo(p.x + headRadius + 10*s, headY + 5*s);
             ctx.lineTo(p.x + headRadius + 12*s, headY + 15*s);
             ctx.lineTo(p.x + headRadius, headY + 5*s);
             ctx.fill();
        }


        // Head Accessories
        if (skinObj.headAccessory === 'sombrero') {
            ctx.fillStyle = skinObj.hatColor || '#1a1a1a';
            ctx.beginPath(); ctx.ellipse(p.x, headY - 5*s, 30*s, 8*s, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(p.x, headY - 15*s, 10*s, Math.PI, 0); ctx.fill();
        }
        else if (skinObj.headAccessory === 'crown') {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath(); ctx.moveTo(p.x-8*s, headY-10*s); ctx.lineTo(p.x-4*s, headY-18*s); ctx.lineTo(p.x, headY-10*s);
            ctx.lineTo(p.x+4*s, headY-18*s); ctx.lineTo(p.x+8*s, headY-10*s); ctx.lineTo(p.x+8*s, headY-5*s); ctx.lineTo(p.x-8*s, headY-5*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'wizard_hat') {
            ctx.fillStyle = skinObj.hatColor || '#000080';
            ctx.beginPath(); ctx.moveTo(p.x-10*s, headY-5*s); ctx.lineTo(p.x+10*s, headY-5*s); ctx.lineTo(p.x, headY-30*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'chef_hat') {
             ctx.fillStyle = '#FFF'; ctx.fillRect(p.x-8*s, headY-25*s, 16*s, 15*s);
        }
        else if (skinObj.headAccessory === 'helmet') {
             ctx.strokeStyle = skinObj.hatColor || '#87CEEB'; ctx.lineWidth=2*s;
             ctx.beginPath(); ctx.arc(p.x, headY, headRadius-2*s, 0, Math.PI*2); ctx.stroke();
             if(skinObj.hatColor === '#FFF') { // Hockey mask fill
                 ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.fill();
             }
        }
        else if (skinObj.headAccessory === 'horns') {
             ctx.fillStyle = 'red';
             ctx.beginPath(); ctx.moveTo(p.x-5*s, headY-10*s); ctx.lineTo(p.x-8*s, headY-18*s); ctx.lineTo(p.x-2*s, headY-10*s); ctx.fill();
             ctx.beginPath(); ctx.moveTo(p.x+5*s, headY-10*s); ctx.lineTo(p.x+8*s, headY-18*s); ctx.lineTo(p.x+2*s, headY-10*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'halo') {
             ctx.strokeStyle='#FFD700'; ctx.lineWidth=2*s; ctx.beginPath(); ctx.ellipse(p.x, headY-15*s, 8*s, 3*s, 0, 0, Math.PI*2); ctx.stroke();
        }
        else if (skinObj.headAccessory === 'beanie') {
             ctx.fillStyle = skinObj.hatColor || '#FF0000'; ctx.fillRect(p.x-10*s, headY-12*s, 20*s, 6*s);
        }
        else if (skinObj.headAccessory === 'red_nose') {
             ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(p.x, headY, 3*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'ear_muffs') {
             const col = skinObj.hatColor || '#FFF';
             ctx.fillStyle = col;
             ctx.beginPath(); ctx.arc(p.x - headRadius - 2*s, headY, 6*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x + headRadius + 2*s, headY, 6*s, 0, Math.PI*2); ctx.fill();
             ctx.strokeStyle = col; ctx.lineWidth = 3*s;
             ctx.beginPath(); ctx.arc(p.x, headY, headRadius + 4*s, Math.PI, 0); ctx.stroke();
        }
        else if (skinObj.headAccessory === 'collar') {
             ctx.fillStyle = skinObj.hatColor || '#FF0000';
             ctx.fillRect(p.x - headRadius, headY + headRadius - 2*s, headRadius * 2, 4*s);
             ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(p.x, headY + headRadius, 3*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'scarf') {
             ctx.strokeStyle = skinObj.hatColor || '#00008B'; ctx.lineWidth = 6*s;
             ctx.beginPath(); ctx.arc(p.x, headY + headRadius, 6*s, 0, Math.PI, false); ctx.stroke();
             // Dangling part
             ctx.fillStyle = skinObj.hatColor || '#00008B';
             ctx.fillRect(p.x + 4*s, headY + headRadius, 6*s, 15*s);
        }
        else if (skinObj.headAccessory === 'fez') {
             ctx.fillStyle = '#8B0000';
             ctx.beginPath(); ctx.moveTo(p.x - 6*s, headY - 8*s); ctx.lineTo(p.x + 6*s, headY - 8*s); ctx.lineTo(p.x + 4*s, headY - 18*s); ctx.lineTo(p.x - 4*s, headY - 18*s); ctx.fill();
             ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 1*s; ctx.beginPath(); ctx.moveTo(p.x, headY - 18*s); ctx.lineTo(p.x + 2*s, headY - 12*s); ctx.stroke();
        }
        else if (skinObj.headAccessory === 'bow') {
             ctx.fillStyle = skinObj.hatColor || '#FFC0CB';
             ctx.beginPath();
             ctx.ellipse(p.x - 6*s, headY - 8*s, 6*s, 4*s, -0.2, 0, Math.PI*2); ctx.fill();
             ctx.beginPath();
             ctx.ellipse(p.x + 6*s, headY - 8*s, 6*s, 4*s, 0.2, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x, headY - 8*s, 2*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'flower') {
             ctx.fillStyle = '#FF69B4';
             const fx = p.x + headRadius; const fy = headY - 5*s;
             for(let i=0; i<5; i++) {
                 const a = (i/5)*Math.PI*2;
                 ctx.beginPath(); ctx.arc(fx + Math.cos(a)*4*s, fy + Math.sin(a)*4*s, 3*s, 0, Math.PI*2); ctx.fill();
             }
             ctx.fillStyle = '#FFFF00'; ctx.beginPath(); ctx.arc(fx, fy, 2*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'algae') {
             ctx.fillStyle = '#2E8B57';
             drawFuzzyPath([{x:p.x-5*s,y:headY-10*s},{x:p.x+5*s,y:headY-12*s},{x:p.x+8*s,y:headY-5*s},{x:p.x-8*s,y:headY-4*s}], '#2E8B57', s, true, 200);
        }
        else if (skinObj.headAccessory === 'hat') {
             ctx.fillStyle = skinObj.hatColor || '#5D4037';
             // Brim
             ctx.beginPath(); ctx.ellipse(p.x, headY - 5*s, headRadius * 1.8, 4*s, 0, 0, Math.PI*2); ctx.fill();
             // Top
             ctx.beginPath(); ctx.arc(p.x, headY - 10*s, headRadius * 0.9, Math.PI, 0); ctx.fill();
        }
        else if (skinObj.headAccessory === 'top_hat') {
             ctx.fillStyle = '#111';
             // Brim
             ctx.beginPath(); ctx.ellipse(p.x, headY - 5*s, headRadius * 1.5, 3*s, 0, 0, Math.PI*2); ctx.fill();
             // Cylinder
             ctx.fillRect(p.x - headRadius * 0.8, headY - 25*s, headRadius * 1.6, 20*s);
        }
        else if (skinObj.headAccessory === 'headband') {
             ctx.fillStyle = skinObj.hatColor || '#FF0000'; // Default red
             if(skinObj.hatColor === '#FFF' && skin.includes('tiger_white')) ctx.fillStyle = '#000'; // Contrast for white tiger
             ctx.fillRect(p.x - headRadius, headY - 8*s, headRadius * 2, 6*s);
             // Knot/Tails
             ctx.beginPath(); ctx.moveTo(p.x + headRadius, headY - 5*s); ctx.lineTo(p.x + headRadius + 10*s, headY + 5*s); ctx.lineTo(p.x + headRadius + 10*s, headY - 5*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'bandana_neck') {
             ctx.fillStyle = '#FF0000';
             ctx.beginPath(); ctx.moveTo(p.x - 10*s, headY + 5*s); ctx.lineTo(p.x, headY + 15*s); ctx.lineTo(p.x + 10*s, headY + 5*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'feathers') {
             ctx.fillStyle = '#FFF';
             ctx.beginPath(); ctx.ellipse(p.x, headY - 15*s, 4*s, 10*s, 0, 0, Math.PI*2); ctx.fill();
             ctx.strokeStyle = '#000'; ctx.lineWidth = 1*s; ctx.stroke();
             ctx.fillStyle = '#FF0000';
             ctx.beginPath(); ctx.ellipse(p.x, headY - 15*s, 2*s, 5*s, 0, 0, Math.PI*2); ctx.fill();
        }

        // Head Details that act like accessories
        if(skinObj.headDetail === 'mohawk') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             for(let i=0; i<5; i++) {
                 ctx.beginPath(); ctx.arc(p.x, headY - 10*s - (i*4*s), (5-i)*s + 2*s, 0, Math.PI*2); ctx.fill();
             }
        }
        if(skinObj.headDetail === 'visor') {
             ctx.fillStyle = '#FF0000'; ctx.shadowBlur = 5; ctx.shadowColor = '#FF0000';
             ctx.fillRect(p.x - 8*s, headY - 5*s, 16*s, 4*s);
             ctx.shadowBlur = 0;
        }
        if(skinObj.headDetail === 'yellow_neck') {
             ctx.fillStyle = '#FFD700';
             ctx.beginPath(); ctx.arc(p.x, headY + 5*s, 8*s, 0, Math.PI, false); ctx.fill();
        }

        // 11. Back Props (New Layer - Drawn on top of body for Back View)
        // Existing Back Accessories moved here
        if (skinObj.backAccessory === 'cape') {
            ctx.fillStyle = skinObj.backColor || '#000';
            ctx.fillRect(p.x - bodyW/1.5, torsoY + 5*s, bodyW*1.3, bodyH*0.8);
        }
        if (skinObj.backAccessory === 'wings') {
            ctx.fillStyle = skinObj.backColor || '#FFF';
            ctx.beginPath(); ctx.ellipse(p.x - 20*s, torsoY + 10*s, 10*s, 20*s, -0.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(p.x + 20*s, torsoY + 10*s, 10*s, 20*s, 0.5, 0, Math.PI*2); ctx.fill();
        }
        if (skinObj.backAccessory === 'backpack') {
             ctx.fillStyle = skinObj.backColor || '#555';
             ctx.fillRect(p.x - bodyW/2, torsoY + 10*s, bodyW, bodyH*0.6);
        }

        // New Props
        if (skinObj.backProp) {
             const bp = skinObj.backProp;
             const centerX = p.x;
             const centerY = torsoY + bodyH * 0.4;

             if (bp === 'axe') {
                 // Axe handle diagonal
                 ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 4*s;
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 // Axe head
                 ctx.fillStyle = '#AAA';
                 ctx.beginPath();
                 ctx.moveTo(centerX - 15*s, centerY - 15*s);
                 ctx.lineTo(centerX - 20*s, centerY - 20*s);
                 ctx.quadraticCurveTo(centerX - 10*s, centerY - 25*s, centerX - 5*s, centerY - 15*s);
                 ctx.fill();
             }
             if (bp === 'guitar') {
                 // Guitar Body
                 ctx.fillStyle = '#8B4513';
                 ctx.beginPath();
                 ctx.ellipse(centerX, centerY, 12*s, 18*s, -0.2, 0, Math.PI*2);
                 ctx.fill();
                 ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(centerX, centerY, 5*s, 0, Math.PI*2); ctx.fill();
                 // Neck
                 ctx.fillStyle = '#5D4037';
                 ctx.fillRect(centerX - 3*s, centerY - 30*s, 6*s, 20*s);
             }
             if (bp === 'oxygen_tank') {
                 ctx.fillStyle = '#FFF'; ctx.strokeStyle = '#AAA'; ctx.lineWidth = 1*s;
                 ctx.fillRect(centerX - 12*s, centerY - 15*s, 24*s, 35*s);
                 ctx.strokeRect(centerX - 12*s, centerY - 15*s, 24*s, 35*s);
                 // Tubes
                 ctx.strokeStyle = '#CCC'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX, centerY - 15*s); ctx.quadraticCurveTo(centerX, centerY - 25*s, centerX - 10*s, centerY - 20*s); ctx.stroke();
             }
             if (bp === 'katanas') {
                 ctx.strokeStyle = '#333'; ctx.lineWidth = 3*s;
                 // X shape
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX + 15*s, centerY - 15*s); ctx.lineTo(centerX - 15*s, centerY + 15*s); ctx.stroke();
                 // Hilts
                 ctx.fillStyle = '#000';
                 ctx.fillRect(centerX - 18*s, centerY - 18*s, 5*s, 5*s);
                 ctx.fillRect(centerX + 13*s, centerY - 18*s, 5*s, 5*s);
             }
             if (bp === 'sword') {
                 ctx.strokeStyle = '#555'; ctx.lineWidth = 4*s;
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 // Hilt (Basket)
                 ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(centerX - 15*s, centerY - 15*s, 5*s, 0, Math.PI*2); ctx.fill();
             }
             if (bp === 'hockey_sticks') {
                 ctx.strokeStyle = '#D2B48C'; ctx.lineWidth = 3*s; // Wood
                 // Crossed
                 ctx.beginPath(); ctx.moveTo(centerX - 10*s, centerY - 20*s); ctx.lineTo(centerX + 10*s, centerY + 20*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX + 10*s, centerY - 20*s); ctx.lineTo(centerX - 10*s, centerY + 20*s); ctx.stroke();
                 // Blades at bottom
                 ctx.fillStyle = '#000'; // Tape
                 ctx.fillRect(centerX + 8*s, centerY + 18*s, 8*s, 4*s);
                 ctx.fillRect(centerX - 16*s, centerY + 18*s, 8*s, 4*s);
             }
             if (bp === 'staff') {
                 ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX + 15*s, centerY - 30*s); ctx.lineTo(centerX - 15*s, centerY + 30*s); ctx.stroke();
                 // Orb (Optimized)
                 const orbX = centerX + 15*s;
                 const orbY = centerY - 30*s;
                 const orbR = 5*s;
                 const glowR = orbR + 15;
                 const orbGrad = ctx.createRadialGradient(orbX, orbY, 0, orbX, orbY, glowR);
                 orbGrad.addColorStop(0, '#00FFFF');
                 orbGrad.addColorStop(orbR/glowR, '#00FFFF');
                 orbGrad.addColorStop(1, 'rgba(0, 255, 255, 0)');
                 ctx.fillStyle = orbGrad;
                 ctx.beginPath(); ctx.arc(orbX, orbY, glowR, 0, Math.PI*2); ctx.fill();
             }
             if (bp === 'windup_key') {
                 ctx.strokeStyle = '#C0C0C0'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(centerX, centerY + 10*s); ctx.stroke();
                 // Handle
                 ctx.lineWidth = 2*s;
                 ctx.beginPath(); ctx.arc(centerX - 5*s, centerY, 5*s, 0, Math.PI*2); ctx.stroke();
                 ctx.beginPath(); ctx.arc(centerX + 5*s, centerY, 5*s, 0, Math.PI*2); ctx.stroke();
             }
        }

        // 9. Jersey Number (Layer 5)
        if(!skin.includes('alien') && !skin.includes('robot') && skinObj.number) {
            ctx.fillStyle = skinObj.numberColor || "#FFF";
            ctx.font = `bold ${12 * s}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText(skinObj.number, p.x, torsoY + bodyH * 0.6);
        }

        // 10. Shot Meter (Layer 6)
        if (state === 'JUMPING') {
            const maxVz = 9; const curVz = Math.abs(getCurrentVz());
            let progress = 1.0 - (curVz / maxVz); progress = Math.max(0, Math.min(1, progress));
            const groundY = p.y + (player3D.z * s);
            const meterY = groundY - (130 * s * sizeMod.h);
            const cx = p.x + (60 * s); const radius = 50 * s;

            const thresh = calculateShotThreshold();
            const greenStart = 1.0 - (thresh / maxVz);

            if (playerData.meterEnabled) {
                drawShotMeter(cx, meterY, radius, s, progress, greenStart, playerData.meterShape || 'arc');
            }
        }
    }
    function getProjectedY(gDist, currentDist, horizonY) {
        if (gDist <= 0) { const p = project(HOOP_POS.x, HOOP_POS.y, 0); return p ? p.y : horizonY; }
        const ratio = gDist / currentDist;
        const wx = HOOP_POS.x + (player3D.x - HOOP_POS.x) * ratio; const wy = HOOP_POS.y + (player3D.y - HOOP_POS.y) * ratio;
        const p = project(wx, wy, 0); return p ? p.y : canvas.height;
    }

    function drawMountainLayer(layer, horizonY, dx) {
        ctx.fillStyle = layer.color;
        ctx.beginPath();
        ctx.moveTo(layer.points[0].x + dx, horizonY);
        layer.points.forEach(p => { ctx.lineTo(p.x + dx, horizonY - p.y); });
        ctx.lineTo(layer.points[layer.points.length-1].x + dx, horizonY);
        ctx.fill();
    }

    function drawBackground() {
        // Optimization: Per-frame camera calculation
        const dxToHoop = HOOP_POS.x - player3D.x;
        const dyToHoop = HOOP_POS.y - player3D.y;
        const angleToHoop = Math.atan2(dyToHoop, dxToHoop);
        const camRotation = -angleToHoop - Math.PI / 2;
        const camSin = Math.sin(camRotation);
        const camCos = Math.cos(camRotation);
        const camZoom = 698;
        const camHeight = 84000 / camZoom;

        g_camCache = {
            rotation: camRotation,
            sinRot: camSin,
            cosRot: camCos,
            cameraZoom: camZoom,
            cameraHeight: camHeight
        };
        // Ensure globals are updated
        cameraZoom = camZoom;
        cameraHeight = camHeight;

        const horizonY = (canvas.height - 120) * 0.5;

        if (!bgCache || bgCache.distanceLevel !== distanceLevel) {
            bgCache = { distanceLevel: distanceLevel, pastFloors: [] };
            const currentDist = 10 + (distanceLevel * 5);
            const court = getCourtDetails(currentDist);

            // Sky
            const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.6);
            skyGrad.addColorStop(0, court.sky1); skyGrad.addColorStop(1, court.sky2);
            bgCache.sky = skyGrad;

            // Current Floor
            const currentZoneGrad = ctx.createLinearGradient(0, horizonY, 0, canvas.height);
            currentZoneGrad.addColorStop(0, court.ground1); currentZoneGrad.addColorStop(1, court.ground2);
            bgCache.currentFloor = currentZoneGrad;

            // Past Floors
            for (let i = 0; i < COURT_ZONES.length; i++) {
                const z = COURT_ZONES[i];
                let zStart = (i === 0) ? 0 : COURT_ZONES[i-1].limit;
                let zEnd = z.limit;
                if (zStart >= currentDist) break;
                let drawEnd = Math.min(zEnd, currentDist);
                const yTop = getProjectedY(zStart, currentDist, horizonY); const yBottom = getProjectedY(drawEnd, currentDist, horizonY);
                if ((yBottom - yTop) > 0.5) {
                    const grad = ctx.createLinearGradient(0, yTop, 0, yBottom);
                    grad.addColorStop(0, z.ground1); grad.addColorStop(1, z.ground2);
                    bgCache.pastFloors.push({ y: yTop, h: (yBottom - yTop) + 2, grad: grad });
                }
            }
        }

        // DRAW FROM CACHE
        ctx.fillStyle = bgCache.sky; ctx.fillRect(0, 0, canvas.width, canvas.height);

        // SUN / MOON / STARS
        if (distanceLevel > 8) {
             // Simple stars
             ctx.fillStyle = 'rgba(255,255,255,0.8)';
             // Seeded random stars (reusing clouds speed for variation or just simple hash)
             for(let i=0; i<30; i++) {
                 let sx = (i * 137) % canvas.width;
                 let sy = (i * 59) % (horizonY * 0.8);
                 ctx.beginPath(); ctx.arc(sx, sy, 1 + (i%2), 0, Math.PI*2); ctx.fill();
             }
        } else {
             // Sun
             ctx.fillStyle = sunGradient;
             ctx.beginPath(); ctx.arc(700, 80, 80, 0, Math.PI*2); ctx.fill();
        }

        // BACKGROUND MOUNTAINS
        mountainLayers.forEach(layer => {
             const shift = (player3D.x + player3D.y) * layer.speed;
             const loopWidth = 2000;
             const offset = shift % loopWidth;
             let startX = -offset;
             if (startX > 0) startX -= loopWidth;

             // Draw enough copies to cover screen
             drawMountainLayer(layer, horizonY, startX);
             drawMountainLayer(layer, horizonY, startX + loopWidth);
             if(startX + loopWidth < 0) drawMountainLayer(layer, horizonY, startX + loopWidth * 2);
        });

        // CLOUDS
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        clouds.forEach(c => {
             c.x += c.speed;
             if(c.x > canvas.width + 200) c.x = -200;
             let xPos = c.x;
             let yPos = c.y;
             ctx.beginPath();
             c.puffs.forEach(p => {
                 ctx.moveTo(xPos + p.dx * c.scale, yPos + p.dy * c.scale);
                 ctx.arc(xPos + p.dx * c.scale, yPos + p.dy * c.scale, p.r * c.scale, 0, Math.PI*2);
             });
             ctx.fill();
        });

        ctx.fillStyle = bgCache.currentFloor; ctx.fillRect(0, horizonY, canvas.width, canvas.height - horizonY);
        bgCache.pastFloors.forEach(f => {
            ctx.fillStyle = f.grad; ctx.fillRect(0, f.y, canvas.width, f.h);
        });

        ctx.beginPath(); ctx.moveTo(0, horizonY); ctx.lineTo(canvas.width, horizonY); ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.stroke();

        // 3D OBJECTS
        g_poolIndex = 0;
        g_renderList.length = 0;

        // Use cached camera values (already calculated at top of function)

        // OPTIMIZATION: Cull objects far beyond the player
        // Player moves away from hoop. d.dist approximates distance from hoop (in pixels).
        // Objects with d.dist >> playerDistFromHoop are behind the camera.
        const playerDistFromHoop = Math.sqrt(Math.pow(player3D.x - HOOP_POS.x, 2) + Math.pow(player3D.y - HOOP_POS.y, 2));
        const cullDist = playerDistFromHoop + 3000; // Margin for scatter and frustum depth

        for (let i = 0; i < decors.length; i++) {
            const d = decors[i];

            // Optimization: Stop processing if objects are too far behind the player (out of view)
            if (d.dist > cullDist) break;

            // Fast Z-Check
            const dx = d.x - player3D.x;
            const dy = d.y - player3D.y;
            // ry calculation: dx * sin + dy * cos
            const ry = dx * camSin + dy * camCos;
            // cameraOffset is 400 in project()
            if (400 - ry <= 0) continue;

            const proj = project(d.x, d.y, 0);
            if (proj) {
                const obj = getRenderItem();
                obj.type = 'decor';
                obj.depth = proj.depth;
                obj.proj = proj;
                obj.zoneType = d.zoneType;
                obj.variant = d.variant;
                obj.seed = d.seed;
                g_renderList.push(obj);
            }
        }

        const hoopProj = project(HOOP_POS.x, HOOP_POS.y, HOOP_POS.z);
        if (hoopProj) {
            const obj = getRenderItem();
            obj.type = 'hoop';
            obj.depth = hoopProj.depth;
            obj.proj = hoopProj;
            g_renderList.push(obj);
        }

        const playerProj = project(player3D.x, player3D.y, player3D.z);
        if (playerProj) {
            const obj = getRenderItem();
            obj.type = 'player';
            obj.depth = playerProj.depth;
            obj.proj = playerProj;
            g_renderList.push(obj);
        }

        const shadowProj = project(player3D.x, player3D.y, 0);
        if (shadowProj) {
            const obj = getRenderItem();
            obj.type = 'shadow';
            obj.depth = shadowProj.depth;
            obj.proj = shadowProj;
            g_renderList.push(obj);
        }

        if (state === 'SHOOTING' && ball.active) {
            const ballProj = project(ball.x, ball.y, ball.z);
            if (ballProj) {
                const obj = getRenderItem();
                obj.type = 'ball';
                obj.depth = ballProj.depth;
                obj.proj = ballProj;
                g_renderList.push(obj);
            }
        }

        particles.forEach(p => {
             const proj = project(p.x, p.y, p.z);
             if(proj) {
                 const obj = getRenderItem();
                 obj.type = 'smoke';
                 obj.depth = proj.depth;
                 obj.proj = proj;
                 obj.alpha = p.alpha;
                 g_renderList.push(obj);
             }
        });

        g_renderList.sort((a, b) => b.depth - a.depth);
        g_renderList.forEach(obj => {
            if (obj.type === 'decor') drawDecor(obj.proj, obj.zoneType, obj.variant, obj.seed);
            if (obj.type === 'hoop') drawHoop(obj.proj);
            if (obj.type === 'shadow') drawShadow(obj.proj);
            if (obj.type === 'player') drawPlayer(obj.proj);
            if (obj.type === 'ball') drawBall(obj.proj);
            if (obj.type === 'smoke') drawSmoke(obj.proj, obj.alpha);
        });

        if (feedbackTimer > 0) {
            ctx.save(); ctx.font = "900 60px 'Arial Black'";
            ctx.fillStyle = feedback === "MUY BIEN!" || feedback === "CHANCEUX!" || feedback === "Swish" || feedback.includes('MONEY') || feedback === "SUR LA LIGNE!" || feedback === "OUF!" || feedback.includes('S√âRIE') ? "#00FF00" : "#FF0000";
            if (feedback === "DERNI√àRE CHANCE !") ctx.fillStyle = "#FFA500";
            ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.textAlign = "center";
            ctx.fillText(feedback, canvas.width/2, 200); ctx.strokeText(feedback, canvas.width/2, 200);
            ctx.restore();
        }
    }

    // Achievement Logic Helpers
    function unlockAchievement(id) {
        if (!playerData.unlockedAchievements.includes(id)) {
            playerData.unlockedAchievements.push(id);
            const ach = ACHIEVEMENTS.find(a => a.id === id);
            if(ach) {
                playerData.tacos += ach.reward;
                saveData();
                showNotification(ach.name, ach.reward);
                updateUI();
            }
        }
    }

    function checkAchievements(context) {
        const dist = 10 + (distanceLevel * 5);
        const ls = playerData.lifetimeStats;

        // Dynamic Check for New Achievements
        ACHIEVEMENTS.forEach(ach => {
            if (ach.type === 'distance' && context === 'score') {
                if (dist >= ach.threshold) unlockAchievement(ach.id);
            }
            if (ach.type === 'streak' && (context === 'streak' || context === 'score')) {
                if (currentStreak >= ach.threshold) unlockAchievement(ach.id);
            }
        });

        if (context === 'score') {
            unlockAchievement('rookie');
            if (ls.makes >= 100) unlockAchievement('veteran');
             if (dist >= 25) unlockAchievement('amateur'); if (dist >= 50) unlockAchievement('sniper');
            if (dist >= 75) unlockAchievement('pro');
            if (dist >= 100) { unlockAchievement('parking_lot'); unlockAchievement('urban_legend'); }
            if (dist >= 125) unlockAchievement('longshot'); if (dist >= 150) unlockAchievement('levis_legend');
            if (dist >= 300) unlockAchievement('chateau');
            if (dist >= 1000) unlockAchievement('mountain');
            if (dist >= 2000) unlockAchievement('astronaut');
            if (dist >= 5000) unlockAchievement('demigod');
            if (playerData.difficulty >= 3) unlockAchievement('daredevil');
            if (playerData.difficulty >= 2) unlockAchievement('hard_mode');
        }
        if(context === 'shot_stats') {
             if(ls.shots >= 500) unlockAchievement('ball_hog');
             if(ls.misses >= 50) unlockAchievement('bricklayer');
        }
        if(context === 'contest') {
             if(contestData.score > 10) unlockAchievement('contest_winner');
             if(contestData.score > 20) unlockAchievement('contest_perfect');
        }
        if (context === 'shop') {
            if (playerData.unlockedSkins.length >= 5) unlockAchievement('fashionista');
            if (playerData.unlockedSkins.length >= 10) unlockAchievement('wardrobe_malfunction');
            if (playerData.unlockedSkins.length >= 15) unlockAchievement('collector');
            if (playerData.stats.income >= 5) unlockAchievement('sweet_tooth');
            if (playerData.stats.aim >= 5) unlockAchievement('hawkeye');
            if (playerData.stats.luck >= 5) unlockAchievement('leprechaun');
            if (playerData.stats.moonwalk >= 5) unlockAchievement('moonwalker_pro');
            const animalsOwned = new Set();
            playerData.unlockedSkins.forEach(skinId => { const s = SKINS_DB.find(x => x.id === skinId); if(s) animalsOwned.add(s.animal); });
            if(animalsOwned.size >= 3) unlockAchievement('zoo');
        }
        if (context === 'lucky') unlockAchievement('lucky');
        if (context === 'skin') {
            const s = playerData.currentSkin;
            if(s.includes('robot') || s.includes('alien') || s.includes('astronaut')) unlockAchievement('cosplay');
            if(s.includes('lumberjack') || s.includes('hockey')) unlockAchievement('eh');
            if(s.includes('zombie') || s.includes('vampire') || s.includes('devil')) unlockAchievement('spooky');
            if(s.includes('poutine')) unlockAchievement('poutine_chef');
        }
        if (playerData.tacos >= 100) unlockAchievement('pocket_change');
        if (playerData.tacos >= 500) unlockAchievement('tycoon');
        if (playerData.tacos >= 2000) unlockAchievement('millionaire');
    }

    function showNotification(name, reward) {
        const notifText = document.getElementById('notifText');
        notifText.innerText = `${name} (+${reward} Tacos)`;
        notif.style.display = 'block'; setTimeout(() => { notif.style.display = 'none'; }, 3000);
    }

    function renderAchievements() {
        const list = document.getElementById('achList');
        list.innerHTML = '';
        ACHIEVEMENTS.forEach(ach => {
            const unlocked = playerData.unlockedAchievements.includes(ach.id);
            const div = document.createElement('div');
            div.className = `ach-row ${unlocked ? 'unlocked' : ''}`;
            div.innerHTML = `<div style="display:flex; align-items:center;"><div class="ach-icon">${unlocked ? 'üèÜ' : 'üîí'}</div><div class="ach-info"><h4>${ach.name}</h4><span>${ach.desc}</span></div></div>${unlocked ? '<div style="color:#00FF00">‚úì</div>' : ''}`;
            list.appendChild(div);
        });
    }

    // --- GAME ACTIONS ---
    function startJump() {
        if (state !== 'IDLE') return;
        state = 'JUMPING';
        feedback = "";

        const styleId = playerData.currentStyle || 'classic';
        const style = SHOOTING_STYLES.find(s => s.id === styleId) || SHOOTING_STYLES[0];
        const jv = (style.modifiers.jumpVelocity !== undefined) ? style.modifiers.jumpVelocity : 9;

        if (jv <= 0.5) {
            isGroundedShot = true;
            groundShotTimer = 0;
            player3D.vz = 0;
        } else {
            isGroundedShot = false;
            player3D.vz = jv;
        }
    }
    function releaseShot() { if (state !== 'JUMPING') return; const timingError = getCurrentVz(); shoot(timingError); }
    function retryShot() { player3D.z = 0; player3D.vz = 0; state = 'IDLE'; }

    function shoot(timingError) {
        state = 'SHOOTING';
        playerData.lifetimeStats.shots++;
        checkAchievements('shot_stats');

        const styleId = playerData.currentStyle || 'classic';
        const style = SHOOTING_STYLES.find(s => s.id === styleId) || SHOOTING_STYLES[0];
        const mods = style.modifiers;

        let threshold = calculateShotThreshold();
        if (!playerData.meterEnabled) threshold *= 1.2;

        const dx = HOOP_POS.x - player3D.x; const dy = HOOP_POS.y - player3D.y;

        let spawnZ = 120;
        if (styleId === 'airbud') spawnZ = 95;
        if (styleId === 'telekinesis' || styleId === 'peekaboo') spawnZ = 130;

        ball.x = player3D.x; ball.y = player3D.y; ball.z = player3D.z + spawnZ;
        ball.active = true;
        ball.isFire = (currentStreak >= 5);

        let flightTime = Math.min(120, 40 + (distanceLevel * 0.8));
        if(mods.speed) flightTime /= mods.speed;

        // Enforce minimum arc (parabola)
        flightTime = Math.max(32, flightTime);

        ball.vx = (dx / flightTime); ball.vy = (dy / flightTime); ball.vz = (HOOP_POS.z - ball.z + 0.5 * GRAVITY * flightTime * (flightTime - 1)) / flightTime;

        let isMiss = Math.abs(timingError) > threshold;

        // "Sur La Ligne" Bonus: 28% forgiveness zone (0.32 / 0.25 = 1.28)
        if (isMiss && Math.abs(timingError) < threshold * 1.28) {
            if(Math.random() > 0.5) { isMiss = false; feedback = "SUR LA LIGNE!"; feedbackTimer = 30; }
        }

        if (isMiss) {
            const luckChance = (playerData.stats.luck - 1) * 0.0111;
            let finalLuckChance = luckChance;
            if(mods.luckBonus) finalLuckChance *= mods.luckBonus;

            if (Math.random() < finalLuckChance) { feedback = "CHANCEUX!"; feedbackTimer = 30; checkAchievements('lucky'); }
            else {
                // Reconstruct accuracy magnitude for visuals
                // accuracy = 0.25 * (timingError / threshold)
                const accuracyMagnitude = 0.25 * (timingError / threshold);

                const len = Math.sqrt(dx*dx + dy*dy); const perpX = -dy / len; const perpY = dx / len;
                const scatter = (Math.random() > 0.5 ? 1 : -1) * Math.abs(accuracyMagnitude) * 15;
                ball.vx += perpX * scatter; ball.vy += perpY * scatter; ball.vz -= Math.abs(accuracyMagnitude) * 5;
                feedback = Math.abs(accuracyMagnitude) > 0.5 ? "AIRBALL" : "BRIQUE"; feedbackTimer = 30;
            }
        }
    }

    function handleScore() {
        ball.active = false; playerData.lifetimeStats.makes++; currentStreak++;
        checkAchievements('streak');
        if(currentGameMode === 'CONTEST') {
            const isMoneyBall = (contestData.ballsInRack === 4);
            const points = isMoneyBall ? 2 : 1;
            contestData.score += points;
            if (currentStreak >= 3) { feedback = `S√âRIE DE ${currentStreak}!`; } else { feedback = isMoneyBall ? "MONEY BALL! (+2)" : "Swish (+1)"; }
            feedbackTimer = 30; updateContestUI(); state = 'RESETTING'; setTimeout(nextLevel, 500);
        } else {
            consecutiveMisses = 0;
            if (currentStreak >= 3) { feedback = `S√âRIE DE ${currentStreak} üî•`; } else { feedback = "Swish"; }
            feedbackTimer = 60; state = 'RESETTING'; setTimeout(nextLevel, 1000);
        }
    }

    function handleMiss() {
        if(state === 'GAMEOVER') return;
        playerData.lifetimeStats.misses++; currentStreak = 0; checkAchievements('shot_stats');
        if(currentGameMode === 'CONTEST') {
            feedback = "Manqu√©"; feedbackTimer = 30; state = 'RESETTING'; setTimeout(nextLevel, 500);
        } else {
            consecutiveMisses++; updateUI();
            const maxMisses = 2 + (playerData.stats.extraLives || 0);
            if (consecutiveMisses >= maxMisses) {
                feedback = "TERMIN√â !"; feedbackTimer = 60; state = 'GAMEOVER'; setTimeout(openShop, 1500);
            } else {
                feedback = "DERNI√àRE CHANCE !"; feedbackTimer = 60; state = 'RESETTING'; setTimeout(retryShot, 1500);
            }
        }
    }

    function updateParticles(dt) {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.z += p.vz * dt;
            p.life -= dt;
            p.scale += 0.05 * dt;
            p.alpha = p.life / p.maxLife;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function update(dt) {
        updateParticles(dt);
        if (state === 'SHOP' || state === 'ACHIEVEMENTS' || state === 'STATS') return;
        if(currentGameMode === 'CONTEST' && state !== 'GAMEOVER') {
            if(contestData.timer > 0) {
                contestData.timer -= (1/60) * dt;
                if(contestData.timer <= 0) { contestData.timer = 0; endContest(); }
                if(Math.ceil(contestData.timer) !== lastDisplayedContestTime) { updateContestUI(); }
            }
        }
        if (state === 'JUMPING') {
            if (isGroundedShot) {
                groundShotTimer += dt;
                if (groundShotTimer > 60) {
                    shoot(20); // Force bad shot
                }
            } else {
                player3D.z += player3D.vz * dt; player3D.vz -= GRAVITY * dt;
                if (player3D.z <= 0) { player3D.z = 0; player3D.vz = 0; state = 'GAMEOVER'; feedback = "MARCH√â!"; feedbackTimer = 60; setTimeout(openShop, 1500); }
            }
        }
        if (state === 'SHOOTING') {
            if (player3D.z > 0) { player3D.z += player3D.vz * dt; player3D.vz -= GRAVITY * dt; if (player3D.z < 0) player3D.z = 0; }
            if (ball.active) {
                if (ball.isFire) {
                     // Emit smoke: 0.5s duration -> 30 frames
                     if (Math.random() < 0.8 * dt) {
                         particles.push({
                             x: ball.x + (Math.random()-0.5)*15,
                             y: ball.y + (Math.random()-0.5)*15,
                             z: ball.z + (Math.random()-0.5)*15,
                             vx: (Math.random()-0.5)*2,
                             vy: (Math.random()-0.5)*2,
                             vz: 1 + Math.random()*2,
                             life: 30, maxLife: 30,
                             scale: 0.5 + Math.random()*0.5, alpha: 1.0
                         });
                     }
                }

                const prevZ = ball.z;
                const prevX = ball.x;
                const prevY = ball.y;

                ball.x += ball.vx * dt; ball.y += ball.vy * dt; ball.z += ball.vz * dt; ball.vz -= GRAVITY * dt;
                if (prevZ >= HOOP_POS.z && ball.z <= HOOP_POS.z) {
                    let t = 0;
                    if (prevZ !== ball.z) {
                         t = (HOOP_POS.z - prevZ) / (ball.z - prevZ);
                    }
                    const crossX = prevX + (ball.x - prevX) * t;
                    const crossY = prevY + (ball.y - prevY) * t;

                    const distToHoopCenter = Math.sqrt(Math.pow(crossX - HOOP_POS.x, 2) + Math.pow(crossY - HOOP_POS.y, 2));
                    if (distToHoopCenter < 25) { handleScore(); return; }
                }
                const distToHoop = Math.sqrt(Math.pow(HOOP_POS.x - player3D.x, 2) + Math.pow(HOOP_POS.y - player3D.y, 2));
                const currentDist = Math.sqrt(Math.pow(ball.x - player3D.x, 2) + Math.pow(ball.y - player3D.y, 2));
                if (ball.z < -50 || currentDist > distToHoop + 5000) { ball.active = false; handleMiss(); return; }
                if (ball.z <= 0) { ball.z = 0; ball.active = false; handleMiss(); return; }
            }
        }
        if (feedbackTimer > 0) feedbackTimer -= 1 * dt;
    }

    // --- HELPER FUNCTIONS ---
    function nextLevel() {
        if(currentGameMode === 'CONTEST') {
            contestData.ballsInRack++;
            if(contestData.ballsInRack >= 5) {
                contestData.rack++; contestData.ballsInRack = 0;
                if(contestData.rack > 5) { endContest(); return; }
                else { setPlayerPositionForRack(contestData.rack); }
            }
            updateContestUI(); state = 'IDLE';
        } else {
            const baseReward = 1 * distanceLevel * playerData.difficulty;
            const multiplier = 1 + (playerData.stats.income - 1) * 0.5;
            let reward = Math.ceil(baseReward * multiplier);

            // New Streak Multiplier: +0.1x per shot in row
            if (currentStreak > 0) {
                reward = Math.ceil(reward * (1 + currentStreak * 0.1));
            }

            if (currentStreak > 1) reward += currentStreak * 2;
            playerData.tacos += reward;
            const jump = (playerData.stats.moonwalk !== undefined) ? playerData.stats.moonwalk : 1;
            distanceLevel += jump;
            const currentDistanceVal = 10 + (distanceLevel * 5);
            if (currentDistanceVal > playerData.highScore) { playerData.highScore = currentDistanceVal; highScoreEl.innerText = playerData.highScore + " pi"; }
            saveData(); checkAchievements('score');
            player3D.x -= 15 * jump; player3D.y += 15 * jump; player3D.z = 0; player3D.vz = 0; state = 'IDLE'; updateUI();
            invalidateBackgroundCache();
        }
    }

    function endContest() {
        state = 'GAMEOVER'; feedback = "TERMIN√â !"; feedbackTimer = 120;
        const reward = contestData.score * 10; playerData.tacos += reward;
        checkAchievements('contest'); saveData(); setTimeout(openShop, 2000);
    }

    function updateUI() {
        scoreEl.innerText = playerData.tacos;
        if(currentGameMode === 'CLASSIC') {
            distEl.innerText = (10 + (distanceLevel * 5)) + " pi";
            const maxMisses = 2 + (playerData.stats.extraLives || 0);
            missValEl.innerText = `${consecutiveMisses}/${maxMisses}`;
            const dist = 10 + (distanceLevel * 5); const c = getCourtDetails(dist); courtNameEl.innerText = c.name;
        } else { courtNameEl.innerText = "CONCOURS 3 POINTS"; }
    }

    function setPlayerPositionForRack(rackNum) {
        // Shift contest positions too (+133)
        if(rackNum === 1) { player3D.x = 333; player3D.y = 500; }
        else if(rackNum === 2) { player3D.x = 383; player3D.y = 400; }
        else if(rackNum === 3) { player3D.x = 433; player3D.y = 300; }
        else if(rackNum === 4) { player3D.x = 483; player3D.y = 200; }
        else if(rackNum === 5) { player3D.x = 533; player3D.y = 100; }
        player3D.z = 0; player3D.vz = 0;
        invalidateBackgroundCache();
    }

    function updateContestUI() {
        const newTime = Math.ceil(contestData.timer);
        contestTimeEl.innerText = newTime;
        lastDisplayedContestTime = newTime;
        contestScoreEl.innerText = contestData.score;
        contestRackEl.innerText = contestData.rack;
    }

    function startContest() {
        contestData = { timer: 60, score: 0, rack: 1, ballsInRack: 0, isActive: true };
        lastDisplayedContestTime = -1;
        currentStreak = 0;

        document.getElementById('classic-stats').style.display = 'none';
        strikesEl.style.display = 'none';
        contestUI.style.display = 'block';

        setPlayerPositionForRack(1);

        state = 'IDLE';
        updateUI();
        updateContestUI();
        playerData.lifetimeStats.contests++;
    }

    function resetGame() {
        if(currentGameMode === 'CONTEST') { startContest(); }
        else {
            distanceLevel = 1; consecutiveMisses = 0;
            player3D = { x: 433, y: 300, z: 0, vz: 0 };
            document.getElementById('classic-stats').style.display = 'block';
            strikesEl.style.display = 'block';
            contestUI.style.display = 'none';
            state = 'IDLE'; updateUI();
            invalidateBackgroundCache();
        }
    }

    // --- UI FUNCTIONS ---
    window.openShop = function() {
        if(state !== 'IDLE' && state !== 'GAMEOVER') return;
        state = 'SHOP'; shopUI.style.display = 'block'; achUI.style.display = 'none'; statsUI.style.display = 'none';
        document.getElementById('diffSlider').value = playerData.difficulty;
        updateDifficulty(); updateShopUI();
    }
    window.openAchievements = function() {
        if(state !== 'IDLE' && state !== 'GAMEOVER') return;
        state = 'ACHIEVEMENTS'; achUI.style.display = 'block'; shopUI.style.display = 'none'; statsUI.style.display = 'none'; renderAchievements();
    }
    window.openStats = function() {
        if(state !== 'IDLE' && state !== 'GAMEOVER' && state !== 'STATS') return;
        state = 'STATS';
        shopUI.style.display = 'none';
        achUI.style.display = 'none';
        statsUI.style.display = 'block';
        const ls = playerData.lifetimeStats;
        document.getElementById('statShots').innerText = ls.shots;
        document.getElementById('statMakes').innerText = ls.makes;
        document.getElementById('statMisses').innerText = ls.misses;
        document.getElementById('statContests').innerText = ls.contests;
        document.getElementById('statBestDist').innerText = playerData.highScore + " pi";
        let acc = 0;
        if(ls.shots > 0) acc = ((ls.makes / ls.shots) * 100).toFixed(1);
        document.getElementById('statAccuracy').innerText = acc + "%";
        const btnMob = document.getElementById('btnToggleMobile');
        if(btnMob) btnMob.innerText = playerData.mobileControls ? "TOUCH: ON" : "TOUCH: OFF";
        const btnMeter = document.getElementById('btnToggleMeter');
        if(btnMeter) btnMeter.innerText = playerData.meterEnabled ? "VIS√âE: OUI" : "VIS√âE: NON";
        const btnShape = document.getElementById('btnCycleMeterShape');
        if(btnShape) {
            let shapeName = "ARC";
            if(playerData.meterShape === 'vertical') shapeName = "VERT";
            if(playerData.meterShape === 'horizontal') shapeName = "HORIZ";
            btnShape.innerText = "FORME: " + shapeName;
        }
    }
    window.toggleMeter = function() {
        playerData.meterEnabled = !playerData.meterEnabled;
        saveData(); openStats(); // Refresh UI
    }
    window.cycleMeterShape = function() {
        const shapes = ['arc', 'vertical', 'horizontal'];
        let idx = shapes.indexOf(playerData.meterShape);
        if (idx < 0) idx = 0;
        idx = (idx + 1) % shapes.length;
        playerData.meterShape = shapes[idx];
        saveData(); openStats(); // Refresh UI
    }
    window.attemptReset = function() {
        const btn = document.getElementById('btnReset');
        if (resetStage === 0) { resetStage = 1; btn.innerText = "S√õR ? (CLIQUEZ ENCORE)"; btn.style.background = "#FF0000"; return; }
        playerData = JSON.parse(JSON.stringify(defaultData)); saveData();
        highScoreEl.innerText = playerData.highScore + " pi"; updateUI(); closeStats(); resetGame();
        resetStage = 0; btn.innerText = "R√âINITIALISER PROGRESSION"; btn.style.background = "#8B0000"; feedback = "RESET!"; feedbackTimer = 60;
    }
    window.unlockAllSkins = function() {
        if(resetStage === 0) {
            const btn = document.getElementById('btnUnlock');
            resetStage = 2; // Different stage for unlock
            btn.innerText = "S√õR ? (CLIQUEZ ENCORE)";
            btn.style.background = "#800080";
            return;
        }
        if(resetStage === 2) {
            SKINS_DB.forEach(skin => {
                if(!playerData.unlockedSkins.includes(skin.id)) {
                    playerData.unlockedSkins.push(skin.id);
                }
            });
            checkAchievements('shop');
            saveData();
            updateShopUI();
            const btn = document.getElementById('btnUnlock');
            btn.innerText = "TRICHEUR !";
            btn.disabled = true;
            resetStage = 0;
            showNotification("TRICHEUR !", 0);
        }
    }
    window.closeShop = function() { state = 'IDLE'; shopUI.style.display = 'none'; if(feedback === "TERMIN√â !" || feedback === "MARCH√â!") resetGame(); }
    window.closeAchievements = function() { state = 'IDLE'; achUI.style.display = 'none'; if(feedback === "TERMIN√â !" || feedback === "MARCH√â!") resetGame(); }
    window.closeStats = function() {
        state = 'IDLE'; statsUI.style.display = 'none'; resetStage = 0;
        const btn = document.getElementById('btnReset'); if(btn) { btn.innerText = "R√âINITIALISER PROGRESSION"; btn.style.background = "#8B0000"; }
        if(feedback === "TERMIN√â !" || feedback === "MARCH√â!") resetGame();
    }
    window.updateDifficulty = function() {
        const val = parseFloat(document.getElementById('diffSlider').value);
        playerData.difficulty = val;
        const label = document.getElementById('diffLabel');
        label.innerText = `x${val.toFixed(1)} Tacos`;
        if(val === 1) { label.innerText = "NORMAL (x1.0)"; label.style.color = "#00FF00"; }
        else if (val < 2.5) { label.innerText = `DIFFICILE (x${val.toFixed(1)})`; label.style.color = "#FFFF00"; }
        else { label.innerText = `L√âVIS LEGEND (x${val.toFixed(1)})`; label.style.color = "#FF0000"; }
        saveData();
    }
    window.getUpgradeCost = function(statName) {
        const lvl = playerData.purchasedStats[statName];
        if (statName === 'income') return Math.floor(25 * Math.pow(lvl, 2));
        if (statName === 'aim') return Math.floor(50 * Math.pow(lvl, 2));
        if (statName === 'luck') return Math.floor(150 * Math.pow(lvl, 2));
        if (statName === 'moonwalk') return Math.floor(150 * Math.pow(lvl, 2));
        if (statName === 'extraLives') return Math.floor(1000 * Math.pow(2, lvl));
        return 999;
    }
    window.buyUpgrade = function(stat) {
        if (stat === 'luck' && playerData.purchasedStats.luck >= 10) return;
        const cost = getUpgradeCost(stat);
        if (playerData.tacos >= cost) {
            playerData.tacos -= cost;
            playerData.purchasedStats[stat]++;
            playerData.stats[stat] = playerData.purchasedStats[stat]; // Auto-equip
            saveData();
            updateShopUI();
            updateUI();
            checkAchievements('shop');
        }
    }
    window.changeStatLevel = function(stat, delta) {
        const current = playerData.stats[stat];
        const max = playerData.purchasedStats[stat];
        const min = 0;

        let next = current + delta;
        if (next < min) next = min;
        if (next > max) next = max;

        if (next !== current) {
            playerData.stats[stat] = next;
            saveData();
            updateShopUI();
            updateUI();
        }
    }
    window.changeAnimal = function(dir) {
        viewingAnimalIndex += dir;
        if(viewingAnimalIndex < 0) viewingAnimalIndex = ANIMALS.length - 1;
        if(viewingAnimalIndex >= ANIMALS.length) viewingAnimalIndex = 0;
        viewingSkinIndex = 0; updateShopUI();
    }
    window.changeSkin = function(dir) {
        const currentAnimal = ANIMALS[viewingAnimalIndex];
        const animalSkins = SKINS_DB.filter(s => s.animal === currentAnimal);
        viewingSkinIndex += dir;
        if(viewingSkinIndex < 0) viewingSkinIndex = animalSkins.length - 1;
        if(viewingSkinIndex >= animalSkins.length) viewingSkinIndex = 0;
        updateShopUI();
    }
    window.buyOrEquipSkin = function() {
        const currentAnimal = ANIMALS[viewingAnimalIndex];
        const animalSkins = SKINS_DB.filter(s => s.animal === currentAnimal);
        const skin = animalSkins[viewingSkinIndex];
        const isUnlocked = playerData.unlockedSkins.includes(skin.id);
        if (isUnlocked) { playerData.currentSkin = skin.id; checkAchievements('skin'); }
        else if (playerData.tacos >= skin.cost) {
            playerData.tacos -= skin.cost; playerData.unlockedSkins.push(skin.id); playerData.currentSkin = skin.id;
            checkAchievements('shop'); checkAchievements('skin');
        }
        saveData(); updateShopUI(); updateUI();
    }
    window.changeShootingStyle = function(dir) {
        viewingStyleIndex += dir;
        if(viewingStyleIndex < 0) viewingStyleIndex = SHOOTING_STYLES.length - 1;
        if(viewingStyleIndex >= SHOOTING_STYLES.length) viewingStyleIndex = 0;
        updateShopUI();
    }
    window.buyOrEquipShootingStyle = function() {
        const style = SHOOTING_STYLES[viewingStyleIndex];
        if(!playerData.unlockedStyles) playerData.unlockedStyles = ['classic']; // Safety
        const isUnlocked = playerData.unlockedStyles.includes(style.id);

        if (isUnlocked) {
            playerData.currentStyle = style.id;
        } else if (playerData.tacos >= style.cost) {
            playerData.tacos -= style.cost;
            playerData.unlockedStyles.push(style.id);
            playerData.currentStyle = style.id;
        }
        saveData(); updateShopUI(); updateUI();
    }
    window.toggleHandedness = function() {
        playerData.isLefty = !playerData.isLefty;
        saveData(); updateShopUI();
    }
    window.toggleMobileControls = function() {
        playerData.mobileControls = !playerData.mobileControls;
        saveData(); updateShopUI(); updateMobileControlsUI();
        const btn = document.getElementById('btnToggleMobile');
        if(btn) btn.innerText = playerData.mobileControls ? "TOUCH: ON" : "TOUCH: OFF";
    }
    window.updateMobileControlsUI = function() {
        const btn = document.getElementById('mobileShootBtn');
        if(playerData.mobileControls && state !== 'STARTUP') btn.style.display = 'block';
        else btn.style.display = 'none';
    }

    function checkOrientation() {
        if (!playerData.mobileControls) return;
        const overlay = document.getElementById('orientation-overlay');
        const fsBtn = document.getElementById('btn-force-fullscreen');

        if (window.innerHeight > window.innerWidth) {
            overlay.style.display = 'flex';
            fsBtn.style.display = 'none';
        } else {
            overlay.style.display = 'none';
            checkFullscreenState();
        }
    }

    function checkFullscreenState() {
        if (!playerData.mobileControls) return;
        const fsBtn = document.getElementById('btn-force-fullscreen');
        const isFS = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;

        if (!isFS) {
            fsBtn.style.display = 'flex';
        } else {
            fsBtn.style.display = 'none';
        }
    }

    window.forceFullscreen = function() {
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen().catch(e => console.log(e));
        } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        }
        checkFullscreenState();
    }

    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    document.addEventListener('fullscreenchange', checkFullscreenState);
    document.addEventListener('webkitfullscreenchange', checkFullscreenState);

    window.choosePlatform = function(mode) {
        playerData.mobileControls = (mode === 'mobile');
        playerData.platformChosen = true;

        if (mode === 'mobile') {
            const elem = document.documentElement;
            const fsPromise = (elem.requestFullscreen) ? elem.requestFullscreen() : (elem.webkitRequestFullscreen ? elem.webkitRequestFullscreen() : null);

            if (fsPromise && fsPromise.catch) {
                fsPromise.catch(e => {
                    console.log("Fullscreen failed or rejected:", e);
                    checkFullscreenState(); // Show fallback button if failed
                });
            }

            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(e => console.log(e));
            }
            setTimeout(checkOrientation, 500);
        }

        saveData();
        startGame();
    }
    function checkStartup() {
        if(!playerData.platformChosen) {
            state = 'STARTUP';
            document.getElementById('startup-ui').style.display = 'flex';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            document.getElementById('strikes').style.display = 'none';
            document.getElementById('courtNameDisplay').style.display = 'none';
            document.getElementById('classic-stats').style.display = 'none';
        } else {
            startGame();
        }
    }
    function startGame() {
        state = 'IDLE';
        document.getElementById('startup-ui').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
        document.getElementById('controls').style.display = 'flex';
        document.getElementById('strikes').style.display = 'block';
        document.getElementById('courtNameDisplay').style.display = 'block';
        document.getElementById('classic-stats').style.display = 'block';
        updateUI();
        updateMobileControlsUI();
    }
    function renderUpgradeControl(statName, containerId) {
        const active = playerData.stats[statName];
        const purchased = playerData.purchasedStats[statName];
        const container = document.getElementById(containerId);
        if (!container) return;

        let html = '';

        // Down Arrow ([-]) - Visible if active level > 0
        if (active > 0) {
            html += `<button class="btn" onclick="changeStatLevel('${statName}', -1)" style="padding: 8px 12px; margin-right:5px;">‚¨áÔ∏è</button>`;
        }

        // Up Arrow ([+]) or Buy Button
        if (active < purchased) {
            // Navigate up through owned levels
            html += `<button class="btn" onclick="changeStatLevel('${statName}', 1)" style="padding: 8px 12px;">‚¨ÜÔ∏è</button>`;
        } else {
            // Buy next level
            if (statName === 'luck' && purchased >= 10) {
                html += `<button class="btn" disabled>MAX</button>`;
            } else {
                const cost = getUpgradeCost(statName);
                const disabled = playerData.tacos < cost ? 'disabled' : '';
                html += `<button class="btn" ${disabled} onclick="buyUpgrade('${statName}')">Acheter (${cost})</button>`;
            }
        }

        container.innerHTML = html;

        // Update Label Level
        const lblId = 'lvl' + statName.charAt(0).toUpperCase() + statName.slice(1);
        const lbl = document.getElementById(lblId);
        if (lbl) lbl.innerText = active;
    }

    window.updateShopUI = function() {
        document.getElementById('shopTacos').innerText = playerData.tacos;

        renderUpgradeControl('income', 'ctrl_income');
        renderUpgradeControl('aim', 'ctrl_aim');
        renderUpgradeControl('luck', 'ctrl_luck');
        renderUpgradeControl('moonwalk', 'ctrl_moonwalk');
        renderUpgradeControl('extraLives', 'ctrl_extraLives');

        // Skin UI
        const currentAnimal = ANIMALS[viewingAnimalIndex];
        const animalSkins = SKINS_DB.filter(s => s.animal === currentAnimal);
        const skin = animalSkins[viewingSkinIndex];
        document.getElementById('animalName').innerText = currentAnimal.toUpperCase();
        document.getElementById('skinName').innerText = skin.name;
        const btn = document.getElementById('btnEquipSkin');
        const status = document.getElementById('skinStatus');
        const isUnlocked = playerData.unlockedSkins.includes(skin.id);
        const isEquipped = playerData.currentSkin === skin.id;
        if (isEquipped) { status.innerText = "√âquip√©"; btn.style.display = 'none'; }
        else if (isUnlocked) { status.innerText = "Poss√©d√©"; btn.style.display = 'inline-block'; btn.innerText = "√âquiper"; btn.disabled = false; }
        else { status.innerText = `Co√ªt: ${skin.cost} Tacos`; btn.style.display = 'inline-block'; btn.innerText = "Acheter"; btn.disabled = playerData.tacos < skin.cost; }

        // Style UI
        const style = SHOOTING_STYLES[viewingStyleIndex];
        document.getElementById('styleName').innerText = style.name;
        document.getElementById('styleDesc').innerText = style.desc;
        const btnStyle = document.getElementById('btnEquipStyle');
        const statusStyle = document.getElementById('styleStatus');
        const isUnlockedStyle = playerData.unlockedStyles ? playerData.unlockedStyles.includes(style.id) : (style.id === 'classic');
        const isEquippedStyle = playerData.currentStyle === style.id;

        if (isEquippedStyle) { statusStyle.innerText = "√âquip√©"; btnStyle.style.display = 'none'; }
        else if (isUnlockedStyle) { statusStyle.innerText = "Poss√©d√©"; btnStyle.style.display = 'inline-block'; btnStyle.innerText = "√âquiper"; btnStyle.disabled = false; }
        else { statusStyle.innerText = `Co√ªt: ${style.cost} Tacos`; btnStyle.style.display = 'inline-block'; btnStyle.innerText = "Acheter"; btnStyle.disabled = playerData.tacos < style.cost; }

        const btnHand = document.getElementById('btnToggleHand');
        btnHand.innerText = playerData.isLefty ? "MAIN: GAUCHER" : "MAIN: DROITIER";
    }
    window.toggleMode = function() {
        if(state !== 'IDLE' && state !== 'GAMEOVER') return;
        if(currentGameMode === 'CLASSIC') { currentGameMode = 'CONTEST'; document.getElementById('modeBtnText').innerText = "CONCOURS"; }
        else { currentGameMode = 'CLASSIC'; document.getElementById('modeBtnText').innerText = "CLASSIQUE"; }
        resetGame();
    }

    // --- GAME LOOP ---
    function drawStartupScene() {
        // Dark Background
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Calculate positions for 2D Composition (Giant Cat + Hoop)
        // We will mock project() returns manually or just draw directly using screen coordinates
        // since we want a specific poster layout regardless of 3D camera.

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 2.0; // Base scale

        // 1. Hoop (Right side of center)
        const hoopX = centerX + 150;
        const hoopY = centerY + 50;
        const hoopP = { x: hoopX, y: hoopY, scale: scale * 1.5 };

        // Draw Hoop Manually (reuse drawHoop logic but simplified or just call it if it's robust)
        // drawHoop depends on projection for the pole... let's mock it
        ctx.fillStyle = '#444'; ctx.fillRect(hoopX - 5, hoopY, 10, 300); // Pole
        // Backboard/Rim
        const bbW = 60 * hoopP.scale; const bbH = 40 * hoopP.scale; const bbX = hoopX - bbW/2; const bbY = hoopY - bbH - 10*hoopP.scale;
        ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(bbX, bbY, bbW, bbH);
        ctx.strokeStyle = '#333'; ctx.lineWidth = 2*hoopP.scale; ctx.strokeRect(bbX, bbY, bbW, bbH);
        ctx.fillStyle = '#CE1126'; ctx.fillRect(bbX + bbW*0.35, bbY + bbH*0.6, bbW*0.3, bbH*0.3);
        ctx.beginPath(); ctx.ellipse(hoopX, hoopY, 18 * hoopP.scale, 5 * hoopP.scale, 0, 0, Math.PI * 2);
        ctx.strokeStyle = 'orange'; ctx.lineWidth = 4 * hoopP.scale; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(hoopX - 15*hoopP.scale, hoopY); ctx.lineTo(hoopX - 10*hoopP.scale, hoopY + 20*hoopP.scale); ctx.lineTo(hoopX + 10*hoopP.scale, hoopY + 20*hoopP.scale); ctx.lineTo(hoopX + 15*hoopP.scale, hoopY);
        ctx.strokeStyle = 'white'; ctx.lineWidth = 1*hoopP.scale; ctx.stroke();

        // 2. Giant Taco Cat (Left side of center)
        const catX = centerX - 150;
        const catY = centerY + 50;
        const catP = { x: catX, y: catY, scale: scale * 3.5 }; // Giant
        drawDecor(catP, 'tacocat', 'default', 0.5);

        // 3. Fire Ball (In the hoop)
        const ballP = { x: hoopX, y: hoopY + 20, scale: scale * 1.5 };
        drawBallSprite(ballP.x, ballP.y, ballP.scale, true);
    }

    function draw() {
        if (state === 'STARTUP') {
            drawStartupScene();
        } else {
            drawBackground();
            drawFlightTracker();
        }
    }

    let lastTime = 0;
    function loop(timestamp) {
        requestAnimationFrame(loop);
        if (!lastTime) lastTime = timestamp;
        const elapsed = timestamp - lastTime;
        let dt = elapsed / 16.666;
        if(dt > 4) dt = 4;
        lastTime = timestamp;
        update(dt);
        draw();
    }

    // Start buttons
    const mobBtn = document.getElementById('mobileShootBtn');
    mobBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (state === 'GAMEOVER') openShop(); else if (state === 'IDLE') startJump();
    }, {passive: false});
    mobBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (state === 'JUMPING') releaseShot();
    }, {passive: false});

    window.addEventListener('keydown', (e) => {
        if(state === 'SHOP') { if(e.code === 'Escape') closeShop(); return; }
        if(state === 'ACHIEVEMENTS') { if(e.code === 'Escape') closeAchievements(); return; }
        if(state === 'STATS') { if(e.code === 'Escape') closeStats(); return; }
        if(e.code === 'KeyP') openShop(); if(e.code === 'KeyO') openAchievements(); if(e.code === 'KeyS') openStats();
        if (e.code === 'Space' && !spacePressed) { spacePressed = true; if (state === 'GAMEOVER') openShop(); else if (state === 'IDLE') startJump(); }
    });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space') { spacePressed = false; if (state === 'JUMPING') releaseShot(); } });
    window.addEventListener('mousedown', (e) => {
        if(e.target.closest('.modal') || e.target.closest('.ui-btn')) return;
        if (state === 'IDLE' && playerData.mobileControls) return;
        if (state === 'GAMEOVER') openShop(); else if (state === 'IDLE') startJump();
    });
    window.addEventListener('mouseup', () => {
        if (state === 'JUMPING' && playerData.mobileControls) return;
        if (state === 'JUMPING') releaseShot();
    });

    // Initial resize call
    resizeGame();
    checkStartup();
    // Start loop
    requestAnimationFrame(loop);
</script>
</body>
</html>
