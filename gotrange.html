<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Taco Basket Ball - Qu√©bec √âdition</title>
    <link rel="icon" type="image/svg+xml" sizes="any" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjQwIiByPSIzMCIgZmlsbD0iI0ZGOEMwMCIvPjxwYXRoIGQ9Ik01MCAxMCBBIDMwIDMwIDAgMCAxIDUwIDcwIE0yMCA0MCBBIDMwIDMwIDAgMCAxIDgwIDQwIiBzdHJva2U9IiM4QjQ1MDAiIHN0cm9rZS13aWR0aD0iMyIgZmlsbD0ibm9uZSIvPjxwYXRoIGQ9Ik0xMCA1MCBRIDUwIDEwMCA5MCA1MCIgZmlsbD0iI0ZGRDcwMCIgc3Ryb2tlPSIjREFBNTIwIiBzdHJva2Utd2lkdGg9IjQiLz48cGF0aCBkPSJNMTUgNTAgUSAyNSA0MCAzNSA1MCBUIDU1IDUwIFQgNzUgNTAgVCA4NSA1MCIgc3Ryb2tlPSIjMzJDRDMyIiBzdHJva2Utd2lkdGg9IjQiIGZpbGw9Im5vbmUiLz48L3N2Zz4=">
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48Y2lyY2xlIGN4PSI1MCIgY3k9IjQwIiByPSIzMCIgZmlsbD0iI0ZGOEMwMCIvPjxwYXRoIGQ9Ik01MCAxMCBBIDMwIDMwIDAgMCAxIDUwIDcwIE0yMCA0MCBBIDMwIDMwIDAgMCAxIDgwIDQwIiBzdHJva2U9IiM4QjQ1MDAiIHN0cm9rZS13aWR0aD0iMyIgZmlsbD0ibm9uZSIvPjxwYXRoIGQ9Ik0xMCA1MCBRIDUwIDEwMCA5MCA1MCIgZmlsbD0iI0ZGRDcwMCIgc3Ryb2tlPSIjREFBNTIwIiBzdHJva2Utd2lkdGg9IjQiLz48cGF0aCBkPSJNMTUgNTAgUSAyNSA0MCAzNSA1MCBUIDU1IDUwIFQgNzUgNTAgVCA4NSA1MCIgc3Ryb2tlPSIjMzJDRDMyIiBzdHJva2Utd2lkdGg9IjQiIGZpbGw9Im5vbmUiLz48L3N2Zz4=">
    <link rel="manifest" href="data:application/manifest+json;base64,eyJuYW1lIjogIlRhY28gQmFza2V0IEJhbGwiLCAic2hvcnRfbmFtZSI6ICJUYWNvQmFsbCIsICJzdGFydF91cmwiOiAiLiIsICJkaXNwbGF5IjogImZ1bGxzY3JlZW4iLCAiYmFja2dyb3VuZF9jb2xvciI6ICIjMWExYTFhIiwgInRoZW1lX2NvbG9yIjogIiNGRkQ3MDAiLCAib3JpZW50YXRpb24iOiAibGFuZHNjYXBlIiwgImljb25zIjogW3sic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0F4TURBZ01UQXdJajQ4WTJseVkyeGxJR040UFNJMU1DSWdZM2s5SWpRd0lpQnlQU0l6TUNJZ1ptbHNiRDBpSTBaR09FTXdNQ0l2UGp4d1lYUm9JR1E5SWswMU1DQXhNQ0JCSURNd0lETXdJREFnTUNBeElEVXdJRGN3SUUweU1DQTBNQ0JCSURNd0lETXdJREFnTUNBeElEZ3dJRFF3SWlCemRISnZhMlU5SWlNNFFqUTFNREFpSUhOMGNtOXJaUzEzYVdSMGFEMGlNeUlnWm1sc2JEMGlibTl1WlNJdlBqeHdZWFJvSUdROUlrMHhNQ0ExTUNCUklEVXdJREV3TUNBNU1DQTFNQ0lnWm1sc2JEMGlJMFpHUkRjd01DSWdjM1J5YjJ0bFBTSWpSRUZCTlRJd0lpQnpkSEp2YTJVdGQybGtkR2c5SWpRaUx6NDhjR0YwYUNCa1BTSk5NVFVnTlRBZ1VTQXlOU0EwTUNBek5TQTFNQ0JVSURVMUlEVXdJRlFnTnpVZ05UQWdWQ0E0TlNBMU1DSWdjM1J5YjJ0bFBTSWpNekpEUkRNeUlpQnpkSEp2YTJVdGQybGtkR2c5SWpRaUlHWnBiR3c5SW01dmJtVWlMejQ4TDNOMlp6ND0iLCAic2l6ZXMiOiAiYW55IiwgInR5cGUiOiAiaW1hZ2Uvc3ZnK3htbCIsICJwdXJwb3NlIjogImFueSBtYXNrYWJsZSJ9LCB7InNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSFpwWlhkQ2IzZzlJakFnTUNBeE1EQWdNVEF3SWo0OFkybHlZMnhsSUdONFBTSTFNQ0lnWTNrOUlqUXdJaUJ5UFNJek1DSWdabWxzYkQwaUkwWkdPRU13TUNJdlBqeHdZWFJvSUdROUlrMDFNQ0F4TUNCQklETXdJRE13SURBZ01DQXhJRFV3SURjd0lFMHlNQ0EwTUNCQklETXdJRE13SURBZ01DQXhJRGd3SURRd0lpQnpkSEp2YTJVOUlpTTRRalExTURBaUlITjBjbTlyWlMxM2FXUjBhRDBpTXlJZ1ptbHNiRDBpYm05dVpTSXZQanh3WVhSb0lHUTlJazB4TUNBMU1DQlJJRFV3SURFd01DQTVNQ0ExTUNJZ1ptbHNiRDBpSTBaR1JEY3dNQ0lnYzNSeWIydGxQU0lqUkVGQk5USXdJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqUWlMejQ4Y0dGMGFDQmtQU0pOTVRVZ05UQWdVU0F5TlNBME1DQXpOU0ExTUNCVUlEVTFJRFV3SUZRZ056VWdOVEFnVkNBNE5TQTFNQ0lnYzNSeWIydGxQU0lqTXpKRFJETXlJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqUWlJR1pwYkd3OUltNXZibVVpTHo0OEwzTjJaejQ9IiwgInNpemVzIjogIjE5MngxOTIiLCAidHlwZSI6ICJpbWFnZS9zdmcreG1sIn0sIHsic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIWnBaWGRDYjNnOUlqQWdNQ0F4TURBZ01UQXdJajQ4WTJseVkyeGxJR040UFNJMU1DSWdZM2s5SWpRd0lpQnlQU0l6TUNJZ1ptbHNiRDBpSTBaR09FTXdNQ0l2UGp4d1lYUm9JR1E5SWswMU1DQXhNQ0JCSURNd0lETXdJREFnTUNBeElEVXdJRGN3SUUweU1DQTBNQ0JCSURNd0lETXdJREFnTUNBeElEZ3dJRFF3SWlCemRISnZhMlU5SWlNNFFqUTFNREFpSUhOMGNtOXJaUzEzYVdSMGFEMGlNeUlnWm1sc2JEMGlibTl1WlNJdlBqeHdZWFJvSUdROUlrMHhNQ0ExTUNCUklEVXdJREV3TUNBNU1DQTFNQ0lnWm1sc2JEMGlJMFpHUkRjd01DSWdjM1J5YjJ0bFBTSWpSRUZCTlRJd0lpQnpkSEp2YTJVdGQybGtkR2c5SWpRaUx6NDhjR0YwYUNCa1BTSk5NVFVnTlRBZ1VTQXlOU0EwTUNBek5TQTFNQ0JVSURVMUlEVXdJRlFnTnpVZ05UQWdWQ0E0TlNBMU1DSWdjM1J5YjJ0bFBTSWpNekpEUkRNeUlpQnpkSEp2YTJVdGQybGtkR2c5SWpRaUlHWnBiR3c5SW01dmJtVWlMejQ4TDNOMlp6ND0iLCAic2l6ZXMiOiAiNTEyeDUxMiIsICJ0eXBlIjogImltYWdlL3N2Zyt4bWwifV19">
    <meta name="theme-color" content="#FFD700">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Russo+One&family=Roboto+Condensed:wght@700&display=swap');

        :root {
            --broadcast-bg: #0f0f0f;
            --broadcast-accent: #FFD700;
            --broadcast-blue: #0047AB;
            --broadcast-red: #D32F2F;
            --broadcast-text: #ffffff;
            --broadcast-font-title: 'Russo One', 'Impact', sans-serif;
            --broadcast-font-body: 'Roboto Condensed', 'Arial Narrow', sans-serif;
        }

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: var(--broadcast-font-body);
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 1066px;
            height: 600px;
            background: #000;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        canvas {
            border: 4px solid #1a1a1a;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
            width: 100%;
            height: 100%;
            display: block;
            box-sizing: border-box;
        }

        /* SCOREBUG (Top HUD) */
        #scorebug-container {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            height: 60px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 100;
        }

        .sb-panel {
            background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
            border-bottom: 4px solid var(--broadcast-accent);
            color: white;
            padding: 0 25px;
            height: 60px;
            display: flex;
            align-items: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            transform: skewX(-15deg);
            border-left: 2px solid #444;
        }

        .sb-content {
            transform: skewX(15deg);
            display: flex;
            gap: 25px;
            align-items: center;
        }

        .sb-logo {
            font-family: var(--broadcast-font-title);
            font-size: 28px;
            color: var(--broadcast-accent);
            text-transform: uppercase;
            text-shadow: 2px 2px 0 #000;
            letter-spacing: 1px;
        }

        .sb-stat-group {
            display: flex;
            gap: 15px;
            border-left: 1px solid #444;
            padding-left: 15px;
        }

        .sb-stat {
            display: flex;
            flex-direction: column;
            line-height: 1;
            text-align: left;
        }

        .sb-label {
            font-size: 11px;
            color: #aaa;
            text-transform: uppercase;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .sb-value {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
        }

        .sb-highlight { color: var(--broadcast-accent); }
        .sb-danger { color: var(--broadcast-red); }

        /* Controls (Bottom Overlay) */
        #controls {
            position: absolute;
            bottom: 130px; /* Sits above the 120px canvas bar */
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: auto;
            z-index: 20;
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .broadcast-btn {
            background: rgba(10, 10, 10, 0.9);
            border: 1px solid #444;
            border-bottom: 3px solid var(--broadcast-accent);
            color: #fff;
            padding: 8px 30px;
            font-family: var(--broadcast-font-body);
            font-weight: 700;
            font-size: 18px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            transform: skewX(-10deg);
            box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        }

        .broadcast-btn span {
            display: inline-block;
            transform: skewX(10deg);
        }

        .broadcast-btn:hover {
            background: #333;
            border-color: #fff;
            border-bottom-color: #fff;
        }

        .broadcast-btn:active {
            transform: skewX(-10deg) translateY(2px);
            box-shadow: none;
        }

        .broadcast-icon-btn {
            background: rgba(10, 10, 10, 0.9);
            border: 2px solid #444;
            color: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .broadcast-icon-btn:hover {
            border-color: var(--broadcast-accent);
            color: var(--broadcast-accent);
            background: #222;
        }

        /* Modals Remaster */
        .modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            max-height: 85%;
            overflow-y: auto;
            background: #111;
            border: 2px solid var(--broadcast-accent);
            padding: 0; /* Removing padding to use header fully */
            color: white;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
            border-radius: 0; /* Sharp corners */
        }

        .modal-content-wrapper {
            padding: 25px;
        }

        .modal::-webkit-scrollbar { width: 8px; }
        .modal::-webkit-scrollbar-track { background: #222; }
        .modal::-webkit-scrollbar-thumb { background: var(--broadcast-accent); }

        .modal-header {
            background: linear-gradient(90deg, #222, #111);
            color: var(--broadcast-accent);
            padding: 15px;
            font-size: 2.5em;
            font-family: var(--broadcast-font-title);
            text-transform: uppercase;
            border-bottom: 2px solid #333;
            margin: 0;
            text-align: center;
        }

        .upgrade-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a1a;
            margin: 10px 0;
            padding: 15px;
            border: 1px solid #333;
            border-left: 4px solid #555;
        }
        .difficulty-row {
            background: #1a1a1a;
            border: 1px solid var(--broadcast-accent);
            margin: 15px 0;
            padding: 15px;
            text-align: left;
        }
        input[type=range] { width: 100%; margin: 15px 0; cursor: pointer; accent-color: var(--broadcast-accent); }

        .ach-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #1a1a1a;
            border: 1px solid #333;
            margin: 8px 0;
            padding: 12px;
            opacity: 0.7;
            transition: 0.3s;
        }
        .ach-row.unlocked {
            border-color: var(--broadcast-accent);
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.1), transparent);
            opacity: 1;
            border-left: 4px solid var(--broadcast-accent);
        }
        .ach-icon { font-size: 28px; margin-right: 15px; }
        .ach-info h4 { margin: 0; color: #fff; font-family: var(--broadcast-font-body); font-size: 1.2em; text-transform: uppercase; }
        .ach-row.unlocked .ach-info h4 { color: var(--broadcast-accent); }
        .ach-info span { font-size: 0.9em; color: #aaa; }

        .btn {
            background: #222;
            color: white;
            border: 1px solid #555;
            padding: 8px 20px;
            cursor: pointer;
            font-family: var(--broadcast-font-body);
            font-weight: bold;
            font-size: 16px;
            text-transform: uppercase;
            transition: all 0.2s;
        }
        .btn:hover { background: #333; border-color: #fff; }
        .btn:active { transform: translateY(2px); }
        .btn:disabled { background: #111; color: #444; border-color: #222; cursor: not-allowed; transform: none; }
        .btn-close {
            background: var(--broadcast-red);
            border: none;
            width: 100%;
            padding: 15px;
            font-size: 1.4em;
            margin-top: 20px;
        }
        .btn-close:hover { background: #b71c1c; }

        .skin-viewer {
            margin-top: 20px;
            border-top: 1px solid #333;
            padding-top: 15px;
            background: #151515;
            padding: 15px;
        }
        .skin-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin: 10px 0;
        }
        .selector-label { width: 180px; font-size: 1.4em; color: var(--broadcast-accent); font-weight: bold; text-transform: uppercase; font-family: var(--broadcast-font-title); }

        #notification {
            position: absolute;
            bottom: 280px; /* Adjusted for new HUD */
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            border-left: 5px solid var(--broadcast-accent);
            color: #fff;
            padding: 15px 40px;
            font-size: 1.4em;
            font-weight: bold;
            display: none;
            z-index: 200;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            font-family: var(--broadcast-font-title);
            animation: slideUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes slideUp {
            from { bottom: 200px; opacity: 0; }
            to { bottom: 280px; opacity: 1; }
        }

        /* Mobile Controls */
        .mobile-shoot-btn {
            position: fixed;
            right: 30px;
            bottom: 40%;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #FFA500, #FF4500);
            border: 4px solid #331a00;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            display: none;
            z-index: 9999;
            touch-action: none;
            -webkit-tap-highlight-color: transparent;
            cursor: pointer;
            user-select: none;
        }
        .mobile-shoot-btn:active { transform: scale(0.95); box-shadow: 0 2px 5px rgba(0,0,0,0.5); }
        .mobile-shoot-btn::before { /* Horizontal Line */
            content: ''; position: absolute; top: 48%; left: 0; width: 100%; height: 4%; background: #331a00; opacity: 0.8;
        }
        .mobile-shoot-btn::after { /* Vertical Line */
            content: ''; position: absolute; left: 48%; top: 0; height: 100%; width: 4%; background: #331a00; opacity: 0.8;
        }
        .mb-curve {
             position: absolute; top: 5%; bottom: 5%; left: 5%; right: 5%;
             border-radius: 50%; border: 4px solid #331a00; opacity: 0.8;
             clip-path: polygon(0 0, 25% 0, 25% 100%, 0 100%);
        }
        .mb-curve.right { transform: scaleX(-1); }

        #startup-ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            text-align: center;
        }
        .startup-btn {
            background: linear-gradient(to bottom, #FF8C00, #FF4500);
            border: 3px solid #FFF;
            color: white;
            font-size: 1.5em;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 900;
            text-shadow: 2px 2px 0 #000;
            box-shadow: 0 5px 0 #8B0000;
            transition: transform 0.1s;
        }
        .startup-btn:active { transform: translateY(5px); box-shadow: none; }
        .startup-btn:hover { background: #FFD700; color: #000; text-shadow: none; }

        #orientation-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 10000;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            text-align: center;
        }
        .rotate-icon {
            font-size: 5em;
            margin-bottom: 20px;
            animation: rotatePhone 2s infinite ease-in-out;
        }
        @keyframes rotatePhone {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
            100% { transform: rotate(0deg); }
        }

        #btn-force-fullscreen {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #FFD700;
            border-radius: 8px;
            color: #FFD700;
            font-size: 30px;
            display: none;
            z-index: 99999;
            cursor: pointer;
            justify-content: center;
            align-items: center;
            line-height: 50px;
            text-align: center;
        }

        .gamepad-focus {
            outline: 4px solid #FFD700 !important;
            box-shadow: 0 0 15px #FFD700 !important;
            transform: scale(1.05);
            z-index: 9999;
            position: relative;
        }
    </style>
</head>
<body>

<div id="btn-force-fullscreen" onclick="forceFullscreen()">‚õ∂</div>

<div id="orientation-overlay">
    <div class="rotate-icon">üì±</div>
    <h2>PIVOTEZ VOTRE APPAREIL</h2>
    <p>ROTATE YOUR DEVICE</p>
</div>

<div id="game-container">
    <div id="scorebug-container">
        <!-- Left Panel: Logo & Main Score -->
        <div class="sb-panel">
            <div class="sb-content">
                <div class="sb-logo">TACO BASKETBALL</div>
                <div class="sb-stat-group">
                    <div class="sb-stat">
                        <span class="sb-label">TACOS</span>
                        <span class="sb-value sb-highlight" id="scoreVal">0</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel: Stats & Context -->
        <div class="sb-panel">
            <div class="sb-content">
                <div id="classic-stats" style="display:flex; gap:25px;">
                    <div class="sb-stat">
                        <span class="sb-label">MISSES</span>
                        <span class="sb-value sb-danger" id="missVal">0</span>
                    </div>
                </div>

                <!-- Court Name (always visible) -->
                <div class="sb-stat" style="border-left: 1px solid #444; padding-left: 20px;">
                    <span class="sb-label">LOCATION</span>
                    <span class="sb-value" id="courtNameDisplay" style="font-size: 18px; white-space: nowrap;">COUR ARRI√àRE</span>
                </div>
            </div>
        </div>
    </div>

    <div id="contest-ui" style="display:none; position:absolute; top:100px; left:50%; transform:translateX(-50%); text-align:center; z-index:90;">
        <div style="background:rgba(0,0,0,0.8); border:2px solid #FFD700; padding:10px 30px; display:inline-block; transform:skewX(-10deg);">
            <div style="transform:skewX(10deg); display:flex; gap:30px;">
                <div class="sb-stat"><span class="sb-label">TIME</span><span class="sb-value" id="contestTime">60</span></div>
                <div class="sb-stat"><span class="sb-label">SCORE</span><span class="sb-value sb-highlight" id="contestScore">0</span></div>
                <div class="sb-stat"><span class="sb-label">RACK</span><span class="sb-value" id="contestRack">1</span></div>
            </div>
        </div>
    </div>

    <div id="controls">
        <div class="broadcast-btn" onclick="toggleMode()"><span>MODE: <span id="modeBtnText">CLASSIQUE</span></span></div>
        <div class="broadcast-btn" onclick="openShop()"><span>BOUTIQUE [P]</span></div>
        <div class="broadcast-btn" onclick="openAchievements()"><span>TROPH√âES [O]</span></div>
        <div class="broadcast-btn" onclick="openStats()"><span>STATS [S]</span></div>
    </div>
    <div style="position: absolute; bottom: 30px; right: 30px; z-index: 120; display:flex; gap:15px; align-items:center;">
        <div class="broadcast-icon-btn" style="width: 40px; height: 40px; font-size: 20px;" onclick="prevTrack()">‚óÄ</div>
        <div id="btn-mute" class="broadcast-icon-btn" style="width: 50px; height: 50px; font-size: 24px;" onclick="toggleMuteUI()">üîä</div>
        <div class="broadcast-icon-btn" style="width: 40px; height: 40px; font-size: 20px;" onclick="nextTrack()">‚ñ∂</div>
    </div>
    <div id="notification">
        <div>üèÜ SUCC√àS D√âBLOQU√â !</div>
        <div id="notifText" style="color:white; font-size:0.8em; margin-top:5px;">Rookie</div>
    </div>

    <div id="mobileShootBtn" class="mobile-shoot-btn">
        <div class="mb-curve"></div>
        <div class="mb-curve right"></div>
    </div>

    <div id="startup-ui">
        <h1 style="font-size: 4em; margin: 0; position: absolute; top: 10%; width: 100%;">TACO BASKET BALL</h1>
        <div style="position: absolute; bottom: 10%; width: 100%;">
            <h2 style="color: #FFD700; text-shadow: 2px 2px 0 #000; font-size: 2em; margin-bottom: 20px;">CHOISIS TA PLATEFORME</h2>
            <div>
                <button class="startup-btn" onclick="choosePlatform('desktop')">ORDI üíª</button>
                <button class="startup-btn" onclick="choosePlatform('mobile')">MOBILE üì±</button>
            </div>
        </div>
    </div>

    <!-- MODALS -->
    <div id="statsUI" class="modal">
        <div class="modal-header">STATISTIQUES √Ä VIE</div>

        <div id="dailyChallengeContainer" style="background:linear-gradient(90deg, #1a1a1a, #2a2a2a); padding:15px; margin:10px 15px; border:1px solid #FFD700; border-left: 5px solid #FFD700; text-align:left; transform: skewX(-5deg);">
             <div style="transform: skewX(5deg);">
                 <h3 style="margin:0 0 10px 0; color:#FFD700; text-transform:uppercase; font-family: var(--broadcast-font-title);">üìÖ D√âFI DU JOUR</h3>
                 <div id="dailyDesc" style="color:#FFF; font-size:1.1em; margin-bottom:8px; font-weight:bold;">Chargement...</div>
                 <div style="background:#000; height:12px; width:100%; border:1px solid #555;">
                     <div id="dailyBar" style="background:#00FF00; height:100%; width:0%; transition: width 0.5s;"></div>
                 </div>
                 <div style="display:flex; justify-content:space-between; margin-top:5px; font-size:0.9em; color:#aaa; font-family: var(--broadcast-font-body);">
                     <span id="dailyProgressText" style="color:#FFF;">0 / 0</span>
                     <span id="dailyRewardText" style="color:#FFD700;">+500 Tacos</span>
                 </div>
             </div>
        </div>

        <div style="text-align:left; padding: 10px; font-size: 1.2em;">
            <p style="overflow:hidden;">Tirs Totaux: <span id="statShots" style="color:#FFF; float:right">0</span></p>
            <p style="overflow:hidden;">Paniers: <span id="statMakes" style="color:#00FF00; float:right">0</span></p>
            <p style="overflow:hidden;">Rat√©s: <span id="statMisses" style="color:#FF0000; float:right">0</span></p>
            <p style="overflow:hidden;">Pr√©cision: <span id="statAccuracy" style="color:#FFD700; float:right">0%</span></p>
            <p style="overflow:hidden;">Concours Jou√©s: <span id="statContests" style="color:#00FFFF; float:right">0</span></p>
            <hr style="border-color:#555; margin:15px 0;">
            <p style="overflow:hidden;">Meilleure Distance: <span id="statBestDist" style="color:#FFD700; float:right">0 pi</span></p>
            <p style="overflow:hidden;">Record Time Attack: <span id="statTimeAttack" style="color:#FF4500; float:right">0</span></p>
        </div>

        <div style="margin-top: 15px; border-top: 1px solid #555; padding-top: 10px;">
            <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                <strong style="color:#FFD700">TAILLE VIS√âE</strong>
                <span id="meterSizeLabel" style="color:#00FF00; font-weight:bold;">100%</span>
            </div>
            <input type="range" id="meterSizeSlider" min="0.5" max="1.5" step="0.1" value="1.0" oninput="updateMeterScale()">
        </div>

        <div style="margin-top: 5px; border-top: 1px solid #555; padding-top: 10px;">
            <div style="display:flex; justify-content:space-between; margin-bottom:5px;">
                <strong style="color:#FFD700">MOMENT DU TIR</strong>
                <span id="releaseTimingLabel" style="color:#00FFFF; font-weight:bold;">L√ÇCHER (TARD)</span>
            </div>
            <input type="range" id="releaseTimingSlider" min="0" max="3" step="1" value="3" oninput="updateReleaseTiming()">
        </div>

        <button id="btnReset" class="btn" style="background: #8B0000; margin-top: 20px; width: 100%; border: 1px solid #ff4444;" onclick="attemptReset()">R√âINITIALISER PROGRESSION</button>
        <button id="btnUnlock" class="btn" style="background: #4B0082; margin-top: 10px; width: 100%; border: 1px solid #9370DB;" onclick="unlockAllSkins()">D√âBLOQUER TOUS LES SKINS</button>
        <button id="btnToggleMobile" class="btn" style="background: #006400; margin-top: 10px; width: 100%; border: 1px solid #00FF00;" onclick="toggleMobileControls()">TOUCH: OFF</button>
        <button id="btnToggleGraphics" class="btn" style="background: #006400; margin-top: 10px; width: 100%; border: 1px solid #00FF00;" onclick="toggleGraphics()">QUALIT√â: HAUTE</button>
        <button id="btnToggleMeter" class="btn" style="background: #2F4F4F; margin-top: 10px; width: 100%; border: 1px solid #00CED1;" onclick="toggleMeter()">VIS√âE: OUI</button>
        <button id="btnCycleMeterShape" class="btn" style="background: #2F4F4F; margin-top: 10px; width: 100%; border: 1px solid #00CED1;" onclick="cycleMeterShape()">FORME: ARC</button>
        <button class="btn btn-close" onclick="closeStats()">FERMER</button>
    </div>

    <div id="shopUI" class="modal">
        <div class="modal-header">TACO MERCADO</div>
        <p>Tacos Disponibles: <span id="shopTacos" style="color:#FFFF00; font-size: 1.2em; font-weight: bold;">0</span></p>
        <div class="difficulty-row">
            <div style="display:flex; justify-content:space-between; margin-bottom:5px;"><strong>DIFFICULT√â</strong><span id="diffLabel" style="color:#00FF00; font-weight:bold;">NORMAL (x1.0)</span></div>
            <input type="range" id="diffSlider" min="1" max="3" step="0.5" value="1" oninput="updateDifficulty()">
            <div style="font-size:0.8em; color:#aaa;">Plus c'est dur, plus √ßa paye !</div>
        </div>
        <div class="upgrade-row"><div style="text-align:left;"><strong style="font-size:1.1em; color:#FFD700;">SIROP D'√âRABLE</strong> (Niv <span id="lvlIncome">1</span>)<br><span style="font-size:0.85em; color:#ccc;">R√©compense sucr√©e ! (Multiplicateur x0.5/niv)</span></div><div id="ctrl_income" class="upgrade-controls"></div></div>
        <div class="upgrade-row"><div style="text-align:left;"><strong style="font-size:1.1em; color:#FFD700;">VIS√âE ASSIST√âE</strong> (Niv <span id="lvlAim">1</span>)<br><span style="font-size:0.85em; color:#ccc;">Fen√™tre de tir plus large.</span></div><div id="ctrl_aim" class="upgrade-controls"></div></div>
        <div class="upgrade-row"><div style="text-align:left;"><strong style="font-size:1.1em; color:#FFD700;">TACO GREASE</strong> (Niv <span id="lvlLuck">1</span>)<br><span style="font-size:0.85em; color:#ccc;">Chance de rebond favorable.</span></div><div id="ctrl_luck" class="upgrade-controls"></div></div>
        <div class="upgrade-row"><div style="text-align:left;"><strong style="font-size:1.1em; color:#FFD700;">MOONWALK</strong> (Niv <span id="lvlMoonwalk">1</span>)<br><span style="font-size:0.85em; color:#ccc;">Recule plus vite apr√®s chaque panier !</span></div><div id="ctrl_moonwalk" class="upgrade-controls"></div></div>
        <div class="upgrade-row"><div style="text-align:left;"><strong style="font-size:1.1em; color:#FFD700;">SECONDE CHANCE</strong> (Niv <span id="lvlExtraLives">0</span>)<br><span style="font-size:0.85em; color:#ccc;">Tirs de plus avant Game Over.</span></div><div id="ctrl_extraLives" class="upgrade-controls"></div></div>
        <div class="skin-viewer">
            <h3 style="color:#aaa; border-bottom:1px solid #555; padding-bottom:5px;">VESTIAIRE</h3>
            <div class="skin-nav"><button class="btn" onclick="changeAnimal(-1)">&lt;</button><span id="animalName" class="selector-label">Rat</span><button class="btn" onclick="changeAnimal(1)">&gt;</button></div>
            <div class="skin-nav"><button class="btn" onclick="changeSkin(-1)">&lt;</button><span id="skinName" class="selector-label">Classic</span><button class="btn" onclick="changeSkin(1)">&gt;</button></div>
            <div id="skinStatus" style="margin-bottom:15px; color:#aaa; font-style:italic;">√âquip√©</div>
            <button id="btnEquipSkin" class="btn" style="width:100%; font-size: 1.1em;" onclick="buyOrEquipSkin()">√âquiper</button>

            <h3 style="color:#aaa; border-bottom:1px solid #555; padding-bottom:5px; margin-top:20px;">STYLE DE TIR</h3>
            <div class="skin-nav"><button class="btn" onclick="changeShootingStyle(-1)">&lt;</button><span id="styleName" class="selector-label">Classique</span><button class="btn" onclick="changeShootingStyle(1)">&gt;</button></div>
            <div id="styleDesc" style="font-size:0.9em; color:#ccc; margin-bottom:5px; height:40px;">Standard</div>
            <div id="styleStatus" style="margin-bottom:15px; color:#aaa; font-style:italic;">√âquip√©</div>
            <button id="btnEquipStyle" class="btn" style="width:100%; font-size: 1.1em;" onclick="buyOrEquipShootingStyle()">√âquiper</button>
            <button id="btnToggleHand" class="btn" style="width:100%; margin-top:10px; background:linear-gradient(to bottom, #444, #222); border:1px solid #666;" onclick="toggleHandedness()">MAIN: DROITIER</button>
        </div>
        <button class="btn btn-close" onclick="closeShop()">FERMER</button>
    </div>

    <div id="achUI" class="modal">
        <div class="modal-header">SALLE DES TROPH√âES</div>
        <div id="achList"></div>
        <button class="btn btn-close" onclick="closeAchievements()">FERMER</button>
    </div>

    <canvas id="gameCanvas"></canvas>
</div>

<script>
    // --- 1. DATA & CONSTANTS (DEFINED FIRST) ---
    var ACHIEVEMENTS = [
        { id: 'rookie', name: 'Recrue', desc: 'Premier panier marqu√©', reward: 10 },
        { id: 'veteran', name: 'V√©t√©ran', desc: 'Marquer 100 paniers au total', reward: 150 },
        { id: 'ball_hog', name: 'Ball Hog', desc: 'Tirer 500 fois', reward: 100 },
        { id: 'bricklayer', name: 'Briqueur', desc: 'Rater 50 tirs', reward: 25 },
        { id: 'amateur', name: 'Amateur', desc: 'Atteindre 25 pi', reward: 25 },
        { id: 'sniper', name: 'Sniper', desc: 'Atteindre 50 pi', reward: 50 },
        { id: 'pro', name: 'Pro Shooter', desc: 'Atteindre 75 pi', reward: 75 },
        { id: 'parking_lot', name: 'Parking', desc: 'Atteindre 100 pi', reward: 100 },
        { id: 'longshot', name: 'Longue Distance', desc: 'Atteindre 125 pi', reward: 125 },
        { id: 'levis_legend', name: 'L√©vis Legend', desc: 'Atteindre 150 pi', reward: 200 },
        { id: 'interstellar', name: 'Interstellaire', desc: 'Atteindre 200 pi', reward: 300 },
        { id: 'moonwalker', name: 'Marcheur Lunaire', desc: 'Atteindre 500 pi', reward: 500 },
        { id: 'demigod', name: 'Demi-Dieu', desc: 'Atteindre 1000 pi', reward: 1000 },
        { id: 'contest_winner', name: 'Roi du Concours', desc: 'Score > 10 au Concours', reward: 200 },
        { id: 'contest_perfect', name: 'Perfection', desc: 'Score > 20 au Concours', reward: 500 },
        { id: 'pocket_change', name: 'Fond de poche', desc: 'Avoir 100 Tacos', reward: 10 },
        { id: 'tycoon', name: 'Taco Tycoon', desc: 'Avoir 500 Tacos', reward: 50 },
        { id: 'millionaire', name: 'Millionaire', desc: 'Avoir 2000 Tacos', reward: 200 },
        { id: 'sweet_tooth', name: 'Bec Sucr√©', desc: 'Sirop √ârable Niv 5', reward: 100 },
        { id: 'hawkeye', name: 'Oeil de Lynx', desc: 'Vis√©e Assist√©e Niv 5', reward: 100 },
        { id: 'leprechaun', name: 'Chanceux', desc: 'Taco Grease Niv 5', reward: 100 },
        { id: 'fashionista', name: 'Fashionista', desc: 'D√©bloquer 5 skins', reward: 100 },
        { id: 'wardrobe_malfunction', name: 'Garde-robe Pleine', desc: 'D√©bloquer 10 skins', reward: 300 },
        { id: 'collector', name: 'Collectionneur', desc: 'D√©bloquer 15 skins', reward: 500 },
        { id: 'zoo', name: 'Gardien de Zoo', desc: 'Skins pour 3 animaux diff√©rents', reward: 150 },
        { id: 'lucky', name: 'Chance Pure', desc: 'Avoir un rebond chanceux', reward: 25 },
        { id: 'daredevil', name: 'Casse-cou', desc: 'Marquer en difficult√© max', reward: 50 },
        { id: 'hard_mode', name: 'Travaillant', desc: 'Marquer en mode Difficile', reward: 25 },
        { id: 'cosplay', name: 'Cosplay', desc: '√âquiper Robot/Alien/Ninja', reward: 20 },
        { id: 'eh', name: 'Canadien', desc: '√âquiper B√ªcheron ou Hockey', reward: 20 },
        { id: 'spooky', name: 'Effrayant', desc: '√âquiper Zombie/Vampire/Diable', reward: 20 },
        { id: 'urban_legend', name: 'L√©gende Urbaine', desc: 'Jouer sur le Terrain de Rue', reward: 50 },
        { id: 'ice_cold', name: 'Glace', desc: 'Jouer sur la Patinoire', reward: 100 },
        { id: 'astronaut_training', name: 'Cadet Spatial', desc: 'Jouer sur la Lune', reward: 150 },
        // STREAK ACHIEVEMENTS
        { id: 'streak_2', name: 'Le D√©but', desc: '2 paniers de suite', reward: 5, type: 'streak', threshold: 2 },
        { id: 'streak_3', name: 'Le Hat Trick', desc: '3 paniers de suite', reward: 10, type: 'streak', threshold: 3 },
        { id: 'streak_4', name: 'Le Quatuor', desc: '4 paniers de suite', reward: 15, type: 'streak', threshold: 4 },
        { id: 'streak_5', name: 'En Feu', desc: '5 paniers de suite', reward: 20, type: 'streak', threshold: 5 },
        { id: 'streak_6', name: 'Six-pack', desc: '6 paniers de suite', reward: 25, type: 'streak', threshold: 6 },
        { id: 'streak_7', name: 'Chanceux 7', desc: '7 paniers de suite', reward: 30, type: 'streak', threshold: 7 },
        { id: 'streak_8', name: 'Huitre', desc: '8 paniers de suite', reward: 35, type: 'streak', threshold: 8 },
        { id: 'streak_9', name: 'Le Neuf', desc: '9 paniers de suite', reward: 40, type: 'streak', threshold: 9 },
        { id: 'streak_10', name: 'La Dizaine', desc: '10 paniers de suite', reward: 50, type: 'streak', threshold: 10 },
        { id: 'streak_11', name: 'Onze', desc: '11 paniers de suite', reward: 55, type: 'streak', threshold: 11 },
        { id: 'streak_12', name: 'Douzaine', desc: '12 paniers de suite', reward: 60, type: 'streak', threshold: 12 },
        { id: 'streak_13', name: 'Malchance?', desc: '13 paniers de suite', reward: 65, type: 'streak', threshold: 13 },
        { id: 'streak_14', name: 'Quatorze', desc: '14 paniers de suite', reward: 70, type: 'streak', threshold: 14 },
        { id: 'streak_15', name: 'Quinze', desc: '15 paniers de suite', reward: 75, type: 'streak', threshold: 15 },
        { id: 'streak_16', name: 'Seize', desc: '16 paniers de suite', reward: 80, type: 'streak', threshold: 16 },
        { id: 'streak_17', name: 'Dix-sept', desc: '17 paniers de suite', reward: 85, type: 'streak', threshold: 17 },
        { id: 'streak_18', name: 'Majeur', desc: '18 paniers de suite', reward: 90, type: 'streak', threshold: 18 },
        { id: 'streak_19', name: 'Presque 20', desc: '19 paniers de suite', reward: 95, type: 'streak', threshold: 19 },
        { id: 'streak_20', name: 'Vingtaine', desc: '20 paniers de suite', reward: 100, type: 'streak', threshold: 20 },
        { id: 'streak_25', name: 'Quart de Si√®cle', desc: '25 paniers de suite', reward: 150, type: 'streak', threshold: 25 },
        { id: 'streak_30', name: 'Trente', desc: '30 paniers de suite', reward: 200, type: 'streak', threshold: 30 },
        { id: 'streak_35', name: 'Trente-Cinq', desc: '35 paniers de suite', reward: 250, type: 'streak', threshold: 35 },
        { id: 'streak_40', name: 'Quarantaine', desc: '40 paniers de suite', reward: 300, type: 'streak', threshold: 40 },
        { id: 'streak_45', name: 'Mi-temps', desc: '45 paniers de suite', reward: 350, type: 'streak', threshold: 45 },
        { id: 'streak_50', name: 'Demi-Centenaire', desc: '50 paniers de suite', reward: 500, type: 'streak', threshold: 50 },
        { id: 'streak_55', name: 'Vitesse de Croisi√®re', desc: '55 paniers de suite', reward: 550, type: 'streak', threshold: 55 },
        { id: 'streak_60', name: 'Soixante', desc: '60 paniers de suite', reward: 600, type: 'streak', threshold: 60 },
        { id: 'streak_65', name: 'L\'√Çge d\'Or', desc: '65 paniers de suite', reward: 650, type: 'streak', threshold: 65 },
        { id: 'streak_70', name: 'Septante', desc: '70 paniers de suite', reward: 700, type: 'streak', threshold: 70 },
        { id: 'streak_75', name: 'Trois Quarts', desc: '75 paniers de suite', reward: 750, type: 'streak', threshold: 75 },
        { id: 'streak_80', name: 'Quatre-Vingts', desc: '80 paniers de suite', reward: 800, type: 'streak', threshold: 80 },
        { id: 'streak_85', name: 'Inarr√™table', desc: '85 paniers de suite', reward: 850, type: 'streak', threshold: 85 },
        { id: 'streak_90', name: 'L\'√âlite', desc: '90 paniers de suite', reward: 900, type: 'streak', threshold: 90 },
        { id: 'streak_95', name: 'Presque L√†', desc: '95 paniers de suite', reward: 950, type: 'streak', threshold: 95 },
        { id: 'streak_100', name: 'Le Centenaire', desc: '100 paniers de suite !', reward: 2000, type: 'streak', threshold: 100 },
        // DISTANCE ACHIEVEMENTS
        { id: 'dist_250', name: 'La Colline', desc: 'Atteindre 250 pi', reward: 100, type: 'distance', threshold: 250 },
        { id: 'dist_300', name: 'Tour Eiffel (presque)', desc: 'Atteindre 300 pi', reward: 120, type: 'distance', threshold: 300 },
        { id: 'dist_350', name: 'Gratte-ciel', desc: 'Atteindre 350 pi', reward: 140, type: 'distance', threshold: 350 },
        { id: 'dist_400', name: 'Hauteur de la Tour', desc: 'Atteindre 400 pi', reward: 160, type: 'distance', threshold: 400 },
        { id: 'dist_450', name: 'Vue Panoramique', desc: 'Atteindre 450 pi', reward: 180, type: 'distance', threshold: 450 },
        { id: 'dist_600', name: 'Space Needle', desc: 'Atteindre 600 pi', reward: 200, type: 'distance', threshold: 600 },
        { id: 'dist_700', name: 'Haut Perche', desc: 'Atteindre 700 pi', reward: 220, type: 'distance', threshold: 700 },
        { id: 'dist_800', name: 'Nuages Bas', desc: 'Atteindre 800 pi', reward: 240, type: 'distance', threshold: 800 },
        { id: 'dist_900', name: 'Tour Eiffel (Sommet)', desc: 'Atteindre 900 pi', reward: 260, type: 'distance', threshold: 900 },
        { id: 'dist_1100', name: 'Le Mille +', desc: 'Atteindre 1100 pi', reward: 300, type: 'distance', threshold: 1100 },
        { id: 'dist_1200', name: 'Empire State', desc: 'Atteindre 1200 pi', reward: 320, type: 'distance', threshold: 1200 },
        { id: 'dist_1300', name: 'Chicago', desc: 'Atteindre 1300 pi', reward: 340, type: 'distance', threshold: 1300 },
        { id: 'dist_1400', name: 'CN Tower (Base)', desc: 'Atteindre 1400 pi', reward: 360, type: 'distance', threshold: 1400 },
        { id: 'dist_1500', name: 'CN Tower (Sommet)', desc: 'Atteindre 1500 pi', reward: 380, type: 'distance', threshold: 1500 },
        { id: 'dist_1750', name: 'One World Trade', desc: 'Atteindre 1750 pi', reward: 400, type: 'distance', threshold: 1750 },
        { id: 'dist_2000', name: 'Burj Khalifa (Base)', desc: 'Atteindre 2000 pi', reward: 450, type: 'distance', threshold: 2000 },
        { id: 'dist_2250', name: 'Burj Khalifa (Demi)', desc: 'Atteindre 2250 pi', reward: 500, type: 'distance', threshold: 2250 },
        { id: 'dist_2500', name: 'Burj Khalifa (Sommet)', desc: 'Atteindre 2500 pi', reward: 550, type: 'distance', threshold: 2500 },
        { id: 'dist_2717', name: 'Plus Haut Batiment', desc: 'Atteindre 2717 pi', reward: 600, type: 'distance', threshold: 2717 },
        { id: 'dist_3000', name: 'Montagne', desc: 'Atteindre 3000 pi', reward: 650, type: 'distance', threshold: 3000 },
        { id: 'dist_3500', name: 'Kilom√®tre Vertical', desc: 'Atteindre 3500 pi', reward: 700, type: 'distance', threshold: 3500 },
        { id: 'dist_4000', name: 'H√©licopt√®re', desc: 'Atteindre 4000 pi', reward: 750, type: 'distance', threshold: 4000 },
        { id: 'dist_4500', name: 'Grand Canyon', desc: 'Atteindre 4500 pi', reward: 800, type: 'distance', threshold: 4500 },
        { id: 'dist_5000', name: 'Un Mille Marin', desc: 'Atteindre 5000 pi', reward: 850, type: 'distance', threshold: 5000 },
        { id: 'dist_6000', name: 'Denver', desc: 'Atteindre 6000 pi', reward: 900, type: 'distance', threshold: 6000 },
        { id: 'dist_7000', name: 'Mexico City', desc: 'Atteindre 7000 pi', reward: 950, type: 'distance', threshold: 7000 },
        { id: 'dist_8000', name: 'Machu Picchu', desc: 'Atteindre 8000 pi', reward: 1000, type: 'distance', threshold: 8000 },
        { id: 'dist_9000', name: 'Quito', desc: 'Atteindre 9000 pi', reward: 1100, type: 'distance', threshold: 9000 },
        { id: 'dist_10000', name: 'Aviation L√©g√®re', desc: 'Atteindre 10000 pi', reward: 1200, type: 'distance', threshold: 10000 },
        { id: 'dist_12000', name: 'Mont Fuji', desc: 'Atteindre 12000 pi', reward: 1300, type: 'distance', threshold: 12000 },
        { id: 'dist_14000', name: 'Mont Rainier', desc: 'Atteindre 14000 pi', reward: 1400, type: 'distance', threshold: 14000 },
        { id: 'dist_16000', name: 'Mont Blanc', desc: 'Atteindre 16000 pi', reward: 1500, type: 'distance', threshold: 16000 },
        { id: 'dist_18000', name: 'Camp de Base', desc: 'Atteindre 18000 pi', reward: 1600, type: 'distance', threshold: 18000 },
        { id: 'dist_19000', name: 'Kilimanjaro', desc: 'Atteindre 19000 pi', reward: 1800, type: 'distance', threshold: 19000 },
        { id: 'dist_20000', name: 'Denali', desc: 'Atteindre 20000 pi', reward: 2000, type: 'distance', threshold: 20000 }
    ];

    var DAILY_CHALLENGES = [
        { id: 'makes_50', type: 'makes', desc: 'Marquer 50 Paniers', target: 50, reward: 500 },
        { id: 'makes_100', type: 'makes', desc: 'Marquer 100 Paniers', target: 100, reward: 1200 },
        { id: 'streak_5', type: 'streak', desc: 'Faire une s√©rie de 5', target: 5, reward: 300 },
        { id: 'streak_10', type: 'streak', desc: 'Faire une s√©rie de 10', target: 10, reward: 1000 },
        { id: 'contest_20', type: 'contest_score', desc: 'Marquer 20 pts (Concours)', target: 20, reward: 600 },
        { id: 'contest_50', type: 'contest_score', desc: 'Marquer 50 pts (Concours)', target: 50, reward: 1500 },
        { id: 'time_30', type: 'time_attack_score', desc: 'Marquer 30 pts (Time Attack)', target: 30, reward: 600 },
        { id: 'time_60', type: 'time_attack_score', desc: 'Marquer 60 pts (Time Attack)', target: 60, reward: 1500 },
        { id: 'distance_500', type: 'distance', desc: 'Parcourir 500 pieds', target: 500, reward: 500 },
        { id: 'play_contest_3', type: 'play_contest', desc: 'Jouer 3 Concours', target: 3, reward: 500 },
        { id: 'play_time_3', type: 'play_time_attack', desc: 'Jouer 3 Time Attack', target: 3, reward: 500 }
    ];

    var COURT_ZONES = [
        { limit: 50, name: "COUR ARRI√àRE", type: 'grass', ground1: '#228B22', ground2: '#32CD32', sky1: '#87CEEB', sky2: '#FFF' },
        { limit: 100, name: "PARC DE LA PAIX", type: 'tree', ground1: '#8B4513', ground2: '#D2691E', sky1: '#87CEEB', sky2: '#E0FFFF' },
        { limit: 200, name: "VIEUX-L√âVIS", type: 'castle', ground1: '#8B0000', ground2: '#A52A2A', sky1: '#4682B4', sky2: '#87CEEB' },
        { limit: 350, name: "TERRAIN DE RUE", type: 'castle', ground1: '#696969', ground2: '#808080', sky1: '#4682B4', sky2: '#87CEEB' },
        { limit: 500, name: "FOR√äT BOR√âALE", type: 'tree', ground1: '#006400', ground2: '#2F4F4F', sky1: '#2E8B57', sky2: '#8FBC8F' },
        { limit: 750, name: "LA PATINOIRE", type: 'mountain', ground1: '#E0FFFF', ground2: '#FFFFFF', sky1: '#87CEEB', sky2: '#F0F8FF' },
        { limit: 1000, name: "FLEUVE ST-LAURENT", type: 'water', ground1: '#00008B', ground2: '#1E90FF', sky1: '#191970', sky2: '#4169E1' },
        { limit: 1500, name: "MONT-SAINTE-ANNE", type: 'mountain', ground1: '#F0FFFF', ground2: '#E0FFFF', sky1: '#87CEEB', sky2: '#00BFFF' },
        { limit: 2500, name: "HAUTE ATMOSPH√àRE", type: 'space', ground1: '#483D8B', ground2: '#6A5ACD', sky1: '#000080', sky2: '#000000' },
        { limit: 4000, name: "BASE LUNAIRE", type: 'space', ground1: '#808080', ground2: '#A9A9A9', sky1: '#000000', sky2: '#191970' },
        { limit: 6000, name: "MARS", type: 'space', ground1: '#8B4513', ground2: '#CD853F', sky1: '#FF4500', sky2: '#000000' },
        { limit: 8000, name: "LE NETHER", type: 'space', ground1: '#8B0000', ground2: '#2F0000', sky1: '#330000', sky2: '#000000' },
        { limit: 9999999, name: "DIMENSION TACO", type: 'grass', ground1: '#FF00FF', ground2: '#00FFFF', sky1: '#FFFF00', sky2: '#FF0000' }
    ];

    var SCALE_OBJECTS = [
        { limit: 15, name: "Voiture Compacte", icon: "üöó" },
        { limit: 25, name: "Orignal (2m)", icon: "ü¶å" },
        { limit: 30, name: "Ligne de 3 points", icon: "üèÄ" },
        { limit: 40, name: "Autobus Scolaire", icon: "üöå" },
        { limit: 60, name: "Piste de Bowling", icon: "üé≥" },
        { limit: 94, name: "Terrain NBA", icon: "üèÄ" },
        { limit: 150, name: "Baleine Bleue", icon: "üêã" },
        { limit: 195, name: "Tour de Pise", icon: "üáÆüáπ", type: 'landmark_leaning' },
        { limit: 230, name: "Envergure Boeing 747", icon: "‚úàÔ∏è" },
        { limit: 272, name: "Chute Montmorency", icon: "üåä" },
        { limit: 305, name: "Statue de la Libert√©", icon: "üóΩ", type: 'landmark_statue' },
        { limit: 350, name: "Ch√¢teau Frontenac", icon: "üè∞", type: 'landmark_castle' },
        { limit: 450, name: "Pyramide de Gizeh", icon: "üî∫", type: 'landmark_pyramid' },
        { limit: 600, name: "Space Needle", icon: "üõ∏", type: 'landmark_needle' },
        { limit: 984, name: "Tour Eiffel", icon: "üá´üá∑", type: 'landmark_tower' },
        { limit: 1454, name: "Empire State Building", icon: "üèôÔ∏è", type: 'landmark_building', color: '#555' },
        { limit: 1815, name: "Tour CN", icon: "üóº", type: 'landmark_needle' },
        { limit: 2200, name: "Pont de Qu√©bec (Trav√©e)", icon: "üåâ" },
        { limit: 2717, name: "Burj Khalifa", icon: "üè¢", type: 'landmark_building', color: '#AAA' },
        { limit: 5280, name: "Un Mille (1.6km)", icon: "üõ£Ô∏è" },
        { limit: 10000, name: "Piste A√©roport", icon: "üõ´" },
        { limit: 14410, name: "Mont Rainier", icon: "üèîÔ∏è" },
        { limit: 20310, name: "Mont Denali", icon: "‚õ∞Ô∏è" },
        { limit: 29029, name: "Mont Everest", icon: "üóª" },
        { limit: 35000, name: "Altitude de Croisi√®re", icon: "‚úàÔ∏è" },
        { limit: 100000, name: "Stratosph√®re", icon: "üéà" },
        { limit: 328000, name: "Ligne de K√°rm√°n (Espace)", icon: "üåå" },
        { limit: 1300000, name: "Station Spatiale (ISS)", icon: "üõ∞Ô∏è" },
        { limit: 9999999, name: "La Lune", icon: "üåë" }
    ];

    var SKINS_DB = [
        // RATS
        { id: 'rat_classic', animal: 'rat', name: 'Classique', cost: 0 },
        { id: 'rat_lumberjack', animal: 'rat', name: 'B√ªcheron', cost: 500, jerseyColor: '#b30000', shortsColor: '#00008b', legType: 'pants', shoesColor: '#8B4513', pattern: 'plaid', headAccessory: 'beanie', hatColor: '#FF0000', backProp: 'axe', clothingDetail: 'suspenders' },
        { id: 'rat_mariachi', animal: 'rat', name: 'El Mariachi', cost: 1000, jerseyColor: '#1a1a1a', shortsColor: '#1a1a1a', legType: 'pants', shoesColor: '#000', pattern: 'suit', headAccessory: 'sombrero', hatColor: '#1a1a1a', backProp: 'guitar' },
        { id: 'rat_luchador', animal: 'rat', name: 'Luchador', cost: 1500, jerseyColor: '#008000', shortsColor: '#008000', legType: 'pants', shoesColor: '#000', socksColor: '#FFF' },
        { id: 'rat_alien', animal: 'rat', name: 'Alien', cost: 3000, jerseyColor: '#C0C0C0', shortsColor: '#C0C0C0', sleeveColor: '#C0C0C0', legType: 'pants', shoesColor: '#555', headDetail: 'antenna' },
        { id: 'rat_zombie', animal: 'rat', name: 'Zombie', cost: 3000, jerseyColor: '#5D4037', shortsColor: '#3E2723', legType: 'pants', shoesColor: '#111' },
        { id: 'rat_astronaut', animal: 'rat', name: 'Astronaute', cost: 5000, jerseyColor: '#FFF', shortsColor: '#FFF', sleeveColor: '#FFF', legType: 'pants', shoesColor: '#AAA', headAccessory: 'helmet', hatColor: '#87CEEB', backProp: 'oxygen_tank' },
        { id: 'rat_ninja', animal: 'rat', name: 'Ninja', cost: 5000, jerseyColor: '#111', shortsColor: '#111', sleeveColor: '#111', legType: 'pants', headAccessory: 'headband', hatColor: '#F00', backProp: 'katanas' },
        { id: 'rat_robot', animal: 'rat', name: 'Robot', cost: 5000, jerseyColor: '#808080', shortsColor: '#808080', sleeveColor: '#808080', legType: 'pants', backProp: 'windup_key', headDetail: 'antenna' },
        { id: 'rat_pirate', animal: 'rat', name: 'Pirate', cost: 1500, jerseyColor: '#FFF', shortsColor: '#000', legType: 'pants', shoesColor: '#000', headAccessory: 'eyepatch', backProp: 'sword', headDetail: 'bandana_ties' },
        { id: 'rat_clown', animal: 'rat', name: 'Clown', cost: 1500, jerseyColor: '#FFD700', shortsColor: '#FF4500', shoesColor: '#F00', headAccessory: 'red_nose' },
        { id: 'rat_vampire', animal: 'rat', name: 'Vampire', cost: 3000, jerseyColor: '#FFF', shortsColor: '#000', legType: 'pants', shoesColor: '#000', backAccessory: 'cape', backColor: '#000' },
        { id: 'rat_chef', animal: 'rat', name: 'Chef', cost: 750, jerseyColor: '#FFF', shortsColor: '#000', shoesColor: '#000', headAccessory: 'chef_hat', clothingDetail: 'apron_ties' },
        { id: 'rat_hockey', animal: 'rat', name: 'Joueur Hockey', cost: 7500, jerseyColor: '#CC0000', shortsColor: '#000', legType: 'pants', shoesColor: '#FFF', headAccessory: 'helmet', hatColor: '#FFF', backProp: 'hockey_sticks' },
        { id: 'rat_poutine', animal: 'rat', name: 'Poutine', cost: 7500, jerseyColor: '#8B4513', shortsColor: '#F4C430', shoesColor: '#8B4513' },
        { id: 'rat_king', animal: 'rat', name: 'Roi', cost: 10000, jerseyColor: '#800080', shortsColor: '#800080', legType: 'pants', shoesColor: '#FFD700', headAccessory: 'crown', backAccessory: 'cape', backColor: '#800080' },
        { id: 'rat_wizard', animal: 'rat', name: 'Sorcier', cost: 10000, jerseyColor: '#000080', shortsColor: '#000080', legType: 'pants', shoesColor: '#000', headAccessory: 'wizard_hat', backAccessory: 'cape', backColor: '#000080', backProp: 'staff' },
        { id: 'rat_devil', animal: 'rat', name: 'Diable', cost: 15000, jerseyColor: '#800000', shortsColor: '#800000', legType: 'pants', shoesColor: '#000', headAccessory: 'horns', tailType: 'devil' },
        { id: 'rat_angel', animal: 'rat', name: 'Ange', cost: 15000, jerseyColor: '#FFF', shortsColor: '#FFF', legType: 'pants', shoesColor: '#FFD700', headAccessory: 'halo', backAccessory: 'wings' },
        // NEW RATS
        { id: 'rat_ghost', animal: 'rat', name: 'Fant√¥me', cost: 2000, furColor: 'rgba(255,255,255,0.6)', jerseyColor: 'rgba(255,255,255,0.3)', shortsColor: 'rgba(255,255,255,0.3)' },
        { id: 'rat_jester', animal: 'rat', name: 'Bouffon', cost: 2500, jerseyColor: '#FF00FF', shortsColor: '#FFFF00', shoesColor: '#00FFFF', headAccessory: 'crown', hatColor: '#FF00FF' },
        { id: 'rat_miner', animal: 'rat', name: 'Mineur', cost: 3000, jerseyColor: '#555', shortsColor: '#333', headAccessory: 'helmet', hatColor: '#FFA500' },
        { id: 'rat_rapper', animal: 'rat', name: 'Rappeur', cost: 3500, jerseyColor: '#FFF', shortsColor: '#000', headAccessory: 'beanie', hatColor: '#000', backAccessory: 'backpack' },
        { id: 'rat_detective', animal: 'rat', name: 'D√©tective', cost: 4000, jerseyColor: '#D2B48C', shortsColor: '#8B4513', legType: 'pants', headAccessory: 'hat', hatColor: '#8B4513' },

        // CATS
        { id: 'cat_classic', animal: 'cat', name: 'Classique', cost: 250 },
        { id: 'cat_tabby', animal: 'cat', name: 'Tigr√©', cost: 1000, furColor: '#FFA500' },
        { id: 'cat_tuxedo', animal: 'cat', name: 'Tuxedo', cost: 1000, furColor: '#111' },
        // NEW CATS
        { id: 'cat_panther', animal: 'cat', name: 'Panth√®re', cost: 2500, furColor: '#000', headAccessory: 'collar', hatColor: '#FFD700' },
        { id: 'cat_siamese', animal: 'cat', name: 'Siamois', cost: 2500, furColor: '#D2B48C', hasSpots: true, headAccessory: 'bow', hatColor: '#FF69B4' },
        { id: 'cat_sphinx', animal: 'cat', name: 'Sphinx', cost: 3000, furColor: '#FFC0CB', headAccessory: 'crown' },
        { id: 'cat_garfield', animal: 'cat', name: 'Lundi', cost: 3500, furColor: '#FF8C00', pattern: 'stripes', headAccessory: 'beanie', hatColor: '#000' },
        { id: 'cat_persian', animal: 'cat', name: 'Persan', cost: 4000, furColor: '#FFF', headAccessory: 'bow', hatColor: '#800080' },

        // DOGS
        { id: 'dog_classic', animal: 'dog', name: 'Classique', cost: 250 },
        { id: 'dog_dalmation', animal: 'dog', name: 'Dalmatien', cost: 1000, furColor: '#FFF', hasSpots: true },
        { id: 'dog_pug', animal: 'dog', name: 'Carlin', cost: 1500, furColor: '#d2b48c' },
        // NEW DOGS
        { id: 'dog_husky', animal: 'dog', name: 'Husky', cost: 2500, furColor: '#AAA', headAccessory: 'scarf', hatColor: '#FF0000' },
        { id: 'dog_boxer', animal: 'dog', name: 'Boxer', cost: 2500, furColor: '#8B4513', headAccessory: 'headband', hatColor: '#FFF' },
        { id: 'dog_police', animal: 'dog', name: 'K-9', cost: 3000, jerseyColor: '#000080', shortsColor: '#000080', headAccessory: 'hat', hatColor: '#000080' },
        { id: 'dog_golden', animal: 'dog', name: 'Golden', cost: 3500, furColor: '#FFD700', headAccessory: 'halo' },
        { id: 'dog_hotdog', animal: 'dog', name: 'Hot-Dog', cost: 4000, jerseyColor: '#FFA500', shortsColor: '#8B4513' },
        { id: 'dog_airbud', animal: 'dog', name: 'Golden Bud', cost: 500, furColor: '#DAA520', jerseyColor: '#191970', shortsColor: '#191970', trimColor: '#FFD700', number: '1', numberColor: '#FFD700' },

        // BEARS
        { id: 'bear_classic', animal: 'bear', name: 'Classique', cost: 500 },
        { id: 'bear_panda', animal: 'bear', name: 'Panda', cost: 3000, furColor: '#FFF', legType: 'panda_limbs' },
        { id: 'bear_polar', animal: 'bear', name: 'Polaire', cost: 3000, furColor: '#F0F8FF' },
        // NEW BEARS
        { id: 'bear_grizzly', animal: 'bear', name: 'Grizzly', cost: 2500, furColor: '#3E2723', headAccessory: 'hat', hatColor: '#5D4037' },
        { id: 'bear_teddy', animal: 'bear', name: 'Toutou', cost: 2500, furColor: '#D2691E', headAccessory: 'bow', hatColor: '#FF0000' },
        { id: 'bear_cyborg', animal: 'bear', name: 'Cyborg', cost: 4000, furColor: '#C0C0C0', headDetail: 'antenna' },
        { id: 'bear_gummy', animal: 'bear', name: 'G√©latine', cost: 3500, furColor: 'rgba(255,0,0,0.6)' },
        { id: 'bear_care', animal: 'bear', name: 'Calin', cost: 3500, furColor: '#FF69B4', pattern: 'heart' },

        // RABBITS
        { id: 'rabbit_classic', animal: 'rabbit', name: 'Classique', cost: 250, furColor: '#8B4513' },
        { id: 'rabbit_jack', animal: 'rabbit', name: 'Li√®vre', cost: 1000, furColor: '#FFFFFF' },
        { id: 'rabbit_magic', animal: 'rabbit', name: 'Magicien', cost: 2500, jerseyColor: '#000', shortsColor: '#000', legType: 'pants', shoesColor: '#FFF', headAccessory: 'wizard_hat', hatColor: '#000', backProp: 'staff' },
        // NEW RABBITS
        { id: 'rabbit_easter', animal: 'rabbit', name: 'P√¢ques', cost: 2500, furColor: '#ADD8E6', pattern: 'spots', backProp: 'basket' },
        { id: 'rabbit_energizer', animal: 'rabbit', name: 'Duracell', cost: 3000, furColor: '#FF69B4', headAccessory: 'headband', hatColor: '#000' },
        { id: 'rabbit_velveteen', animal: 'rabbit', name: 'Peluche', cost: 2000, furColor: '#A0522D', clothingDetail: 'stitches' },
        { id: 'rabbit_killer', animal: 'rabbit', name: 'Vorpal', cost: 5000, furColor: '#FFF', headAccessory: 'collar', hatColor: '#FF0000' },
        { id: 'rabbit_cyborg', animal: 'rabbit', name: 'Robo-Lapin', cost: 4000, furColor: '#C0C0C0' },

        // MOOSE
        { id: 'moose_classic', animal: 'moose', name: 'Classique', cost: 750 },
        { id: 'moose_royal', animal: 'moose', name: 'Royal', cost: 5000, headAccessory: 'crown', backAccessory: 'cape', backColor: '#800080' },
        // NEW MOOSE
        { id: 'moose_mountie', animal: 'moose', name: 'Gendarme', cost: 3000, jerseyColor: '#FF0000', shortsColor: '#000', headAccessory: 'hat', hatColor: '#8B4513' },
        { id: 'moose_christmas', animal: 'moose', name: 'No√´l', cost: 3000, jerseyColor: '#006400', shortsColor: '#FF0000', headAccessory: 'antlers_lights' },
        { id: 'moose_swamp', animal: 'moose', name: 'Marais', cost: 2500, furColor: '#556B2F', headAccessory: 'algae' },
        { id: 'moose_albino', animal: 'moose', name: 'Albinos', cost: 4000, furColor: '#FFF', headAccessory: 'halo' },
        { id: 'moose_bullwinkle', animal: 'moose', name: 'Toon', cost: 3500, furColor: '#8B4513', jerseyType: 'tshirt' },

        // FOXES (NEW)
        { id: 'fox_classic', animal: 'fox', name: 'Classique', cost: 1000 },
        { id: 'fox_arctic', animal: 'fox', name: 'Arctique', cost: 2000, furColor: '#FFF', headAccessory: 'ear_muffs', hatColor: '#ADD8E6' },
        { id: 'fox_kitsune', animal: 'fox', name: 'Kitsune', cost: 5000, furColor: '#FFD700', tailType: 'multi' },
        { id: 'fox_ninja', animal: 'fox', name: 'Ombre', cost: 3000, jerseyColor: '#000', shortsColor: '#000', headAccessory: 'headband' },
        { id: 'fox_pilot', animal: 'fox', name: 'Pilote', cost: 3000, jerseyColor: '#FFF', shortsColor: '#228B22', headAccessory: 'helmet', hatColor: '#CCC' },
        { id: 'fox_gentleman', animal: 'fox', name: 'Gentleman', cost: 4000, jerseyColor: '#000', shortsColor: '#000', legType: 'pants', pattern: 'suit', headAccessory: 'top_hat' },

        // WOLVES (NEW)
        { id: 'wolf_classic', animal: 'wolf', name: 'Classique', cost: 1000 },
        { id: 'wolf_black', animal: 'wolf', name: 'Noir', cost: 2000, furColor: '#1a1a1a', headAccessory: 'collar', hatColor: '#FF0000' },
        { id: 'wolf_white', animal: 'wolf', name: 'Blanc', cost: 2000, furColor: '#FFF', headAccessory: 'scarf', hatColor: '#00008B' },
        { id: 'wolf_alpha', animal: 'wolf', name: 'Alpha', cost: 5000, furColor: '#333' },
        { id: 'wolf_cyber', animal: 'wolf', name: 'Cyber', cost: 4000, furColor: '#C0C0C0', headDetail: 'visor' },
        { id: 'wolf_shaman', animal: 'wolf', name: 'Chaman', cost: 3500, furColor: '#808080', headAccessory: 'feathers' },

        // LIONS (NEW)
        { id: 'lion_classic', animal: 'lion', name: 'Classique', cost: 1500 },
        { id: 'lion_scar', animal: 'lion', name: 'Balafr√©', cost: 3000, furColor: '#8B4513' },
        { id: 'lion_white', animal: 'lion', name: 'Blanc', cost: 3000, furColor: '#FFF', headAccessory: 'crown' },
        { id: 'lion_king', animal: 'lion', name: 'Roi', cost: 10000, headAccessory: 'crown', backAccessory: 'cape', backColor: '#800080' },
        { id: 'lion_rasta', animal: 'lion', name: 'Rasta', cost: 4000, jerseyColor: '#008000', shortsColor: '#FFFF00', shoesColor: '#FF0000', headAccessory: 'beanie' },
        { id: 'lion_mech', animal: 'lion', name: 'Mecha', cost: 5000, furColor: '#C0C0C0', headDetail: 'visor' },

        // TIGERS (NEW)
        { id: 'tiger_classic', animal: 'tiger', name: 'Classique', cost: 1500, pattern: 'tiger_stripes' },
        { id: 'tiger_white', animal: 'tiger', name: 'Blanc', cost: 3000, furColor: '#FFF', pattern: 'tiger_stripes', headAccessory: 'headband', hatColor: '#FFF' },
        { id: 'tiger_sabretooth', animal: 'tiger', name: 'Smilodon', cost: 5000, furColor: '#D2B48C', headAccessory: 'collar', hatColor: '#000' },
        { id: 'tiger_karate', animal: 'tiger', name: 'Karat√©', cost: 3500, jerseyColor: '#FFF', shortsColor: '#FFF', legType: 'pants', headAccessory: 'headband' },
        { id: 'tiger_tony', animal: 'tiger', name: 'Mascotte', cost: 4000, jerseyColor: '#FF0000', headAccessory: 'bandana_neck' },
        { id: 'tiger_neon', animal: 'tiger', name: 'N√©on', cost: 4500, furColor: '#00FFFF', pattern: 'tiger_stripes' },

        // PIGS (NEW)
        { id: 'pig_classic', animal: 'pig', name: 'Classique', cost: 1000 },
        { id: 'pig_muddy', animal: 'pig', name: 'Boueux', cost: 2000, furColor: '#FFC0CB', pattern: 'spots', spotColor: '#8B4513' },
        { id: 'pig_boar', animal: 'pig', name: 'Sanglier', cost: 3000, furColor: '#5D4037', headDetail: 'mohawk', hairColor: '#000' },
        { id: 'pig_bank', animal: 'pig', name: 'Tirelire', cost: 4000, furColor: '#FF69B4', skinType: 'shiny' },
        { id: 'pig_police', animal: 'pig', name: 'Police', cost: 3500, jerseyColor: '#000080', shortsColor: '#000080', headAccessory: 'hat', hatColor: '#000080' },
        { id: 'pig_gentleman', animal: 'pig', name: 'Riche', cost: 5000, jerseyColor: '#000', shortsColor: '#000', legType: 'pants', headAccessory: 'top_hat', pattern: 'suit' },

        // COWS (NEW)
        { id: 'cow_classic', animal: 'cow', name: 'Classique', cost: 1000, pattern: 'cow_spots' },
        { id: 'cow_highland', animal: 'cow', name: 'Highland', cost: 3000, furColor: '#8B0000' },
        { id: 'cow_bull', animal: 'cow', name: 'Taureau', cost: 3500, furColor: '#000', headAccessory: 'bandana_neck' },
        { id: 'cow_strawberry', animal: 'cow', name: 'Fraise', cost: 2500, furColor: '#FFC0CB', pattern: 'cow_spots', headAccessory: 'flower' },
        { id: 'cow_farmer', animal: 'cow', name: 'Fermier', cost: 3000, clothingDetail: 'overalls', jerseyColor: '#87CEEB', shortsColor: '#000080' },
        { id: 'cow_space', animal: 'cow', name: 'Espace', cost: 5000, furColor: '#00FF00', headAccessory: 'helmet' },

        // MONKEYS (NEW)
        { id: 'monkey_classic', animal: 'monkey', name: 'Classique', cost: 1000 },
        { id: 'monkey_gorilla', animal: 'monkey', name: 'Gorille', cost: 3000, furColor: '#000', backProp: 'barrel' },
        { id: 'monkey_chimp', animal: 'monkey', name: 'Chimpanz√©', cost: 2500, furColor: '#333', headAccessory: 'fez' },
        { id: 'monkey_wukong', animal: 'monkey', name: 'Wukong', cost: 10000, furColor: '#FFD700', headAccessory: 'crown', backProp: 'staff' },
        { id: 'monkey_space', animal: 'monkey', name: 'Cosmonaute', cost: 4000, jerseyColor: '#FFA500', shortsColor: '#FFA500', legType: 'pants', headAccessory: 'helmet' },
        { id: 'monkey_zombie', animal: 'monkey', name: 'Zombie', cost: 3000, furColor: '#556B2F' },

        // PENGUINS (NEW)
        { id: 'penguin_classic', animal: 'penguin', name: 'Classique', cost: 1000 },
        { id: 'penguin_emperor', animal: 'penguin', name: 'Empereur', cost: 2500, headDetail: 'yellow_neck' },
        { id: 'penguin_tuxedo', animal: 'penguin', name: 'Tuxedo', cost: 2000, pattern: 'suit' },
        { id: 'penguin_icy', animal: 'penguin', name: 'Glace', cost: 3000, furColor: '#ADD8E6', headAccessory: 'ear_muffs', hatColor: '#FFF' },
        { id: 'penguin_pilot', animal: 'penguin', name: 'Pilote', cost: 3500, headAccessory: 'helmet', hatColor: '#CCC' },
        { id: 'penguin_rico', animal: 'penguin', name: 'Rico', cost: 3000, headDetail: 'mohawk' },

        // NBA LEGENDS (Humans - Accurate Colors & Patterns)
        { id: 'human_wall', animal: 'human', name: 'Speedy', cost: 5000, heightScale: 1.085, widthScale: 0.9, jerseyColor: '#FFF', shortsColor: '#FFF', sideStripesColor: '#002B5C', trimColor: '#E31837', number: '2', numberColor: '#E31837', skinTone: '#5c3a21', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', sleeveRight: '#E31837' },
        { id: 'human_lebron', animal: 'human', name: 'The King', cost: 25000, heightScale: 1.170, widthScale: 1.0, armWidthScale: 1.1, legWidthScale: 1.1, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '23', numberColor: '#552583', skinTone: '#4a3020', hairStyle: 'headband', hairColor: '#000', headbandColor: '#552583', sleeveRight: '#FDB927', socksColor: '#FFF', shoesColor: '#552583' },
        { id: 'human_kobe8', animal: 'human', name: 'Frobe', cost: 30000, heightScale: 1.130, widthScale: 0.9, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '8', numberColor: '#552583', skinTone: '#5c3a21', hairStyle: 'afro', hairColor: '#000', socksColor: '#FFF', shoesColor: '#111' },
        { id: 'human_kobe24', animal: 'human', name: 'Black Mamba', cost: 30000, heightScale: 1.130, widthScale: 0.9, jerseyColor: '#FFF', shortsColor: '#FFF', trimColor: '#552583', number: '24', numberColor: '#552583', skinTone: '#5c3a21', hairStyle: 'bald', hairColor: '#000', sleeveRight: '#FFF', socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_curry', animal: 'human', name: 'Chef Curry', cost: 30000, heightScale: 1.070, widthScale: 0.85, armWidthScale: 0.9, legWidthScale: 0.9, jerseyColor: '#1D428A', shortsColor: '#1D428A', trimColor: '#FFC72C', number: '30', numberColor: '#FFC72C', skinTone: '#dcb98a', hairStyle: 'short', hairColor: '#000', jerseyType: 'tshirt', socksColor: '#FFF', shoesColor: '#FFC72C' },
        { id: 'human_magic', animal: 'human', name: 'Magic', cost: 30000, heightScale: 1.170, widthScale: 0.95, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '32', numberColor: '#552583', skinTone: '#5c3a21', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#FFF', shortsLength: 'short' },
        { id: 'human_drj', animal: 'human', name: 'The Doctor', cost: 35000, heightScale: 1.140, widthScale: 0.9, jerseyColor: '#FFF', shortsColor: '#FFF', trimColor: '#ED174C', number: '32', numberColor: '#ED174C', skinTone: '#5c3a21', hairStyle: 'afro', hairColor: '#000', socksColor: '#FFF', shoesColor: '#ED174C', shortsLength: 'short' },
        { id: 'human_wilt', animal: 'human', name: 'The Stilt', cost: 40000, heightScale: 1.230, widthScale: 0.95, jerseyColor: '#552583', shortsColor: '#552583', sideStripesColor: '#FDB927', number: '13', numberColor: '#FFF', skinTone: '#4a3020', hairStyle: 'headband', hairColor: '#000', headbandColor: '#FDB927', socksColor: '#FFF', shoesColor: '#FFF', shortsLength: 'short' },
        { id: 'human_mj', animal: 'human', name: 'The G.O.A.T.', cost: 50000, heightScale: 1.130, widthScale: 0.9, jerseyColor: '#CE1141', shortsColor: '#CE1141', trimColor: '#000', number: '23', numberColor: '#000', skinTone: '#3e271a', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#CE1141' },
        { id: 'human_bird', animal: 'human', name: 'Larry Legend', cost: 40000, heightScale: 1.170, widthScale: 0.95, jerseyColor: '#007A33', shortsColor: '#007A33', trimColor: '#FFF', number: '33', numberColor: '#FFF', skinTone: '#f0d5be', hairStyle: 'short', hairColor: '#e3c179', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_shaq', animal: 'human', name: 'Diesel', cost: 40000, heightScale: 1.230, widthScale: 1.2, armWidthScale: 1.3, legWidthScale: 1.3, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '34', numberColor: '#552583', skinTone: '#3c2415', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#111' },
        { id: 'human_ai', animal: 'human', name: 'The Answer', cost: 35000, heightScale: 1.040, widthScale: 0.8, jerseyColor: '#000', shortsColor: '#000', trimColor: '#ED174C', number: '3', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'cornrows', hairColor: '#000', headbandColor: '#FFF', sleeveRight: '#000', socksColor: '#000', shoesColor: '#FFF' },
        { id: 'human_duncan', animal: 'human', name: 'Big Fundamental', cost: 35000, heightScale: 1.200, widthScale: 0.95, jerseyColor: '#000', shortsColor: '#000', trimColor: '#C4CED4', number: '21', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'short', hairColor: '#000', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_rodman', animal: 'human', name: 'The Worm', cost: 30000, heightScale: 1.140, widthScale: 0.9, jerseyColor: '#CE1141', shortsColor: '#000', trimColor: '#000', number: '91', numberColor: '#000', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#00FF00', socksColor: '#FFF', shoesColor: '#FFF', shortsLength: 'short' },
        { id: 'human_barkley', animal: 'human', name: 'Sir Charles', cost: 30000, heightScale: 1.130, widthScale: 1.05, jerseyColor: '#1D1160', shortsColor: '#1D1160', sideStripesColor: '#E56020', number: '34', numberColor: '#E56020', skinTone: '#8d5524', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_dirk', animal: 'human', name: 'German Jesus', cost: 30000, heightScale: 1.215, widthScale: 0.92, jerseyColor: '#00538C', shortsColor: '#00538C', sideStripesColor: '#B8C4CA', number: '41', numberColor: '#FFF', skinTone: '#f0d5be', hairStyle: 'curly_long', hairColor: '#dcb98a', socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_giannis', animal: 'human', name: 'Greek Freak', cost: 25000, heightScale: 1.200, widthScale: 0.98, jerseyColor: '#00471B', shortsColor: '#00471B', sideStripesColor: '#EEE1C6', number: '34', numberColor: '#EEE1C6', skinTone: '#4a3020', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_joker', animal: 'human', name: 'The Joker', cost: 25000, heightScale: 1.200, widthScale: 1.1, armWidthScale: 1.1, legWidthScale: 1.1, jerseyColor: '#0E2240', shortsColor: '#0E2240', trimColor: '#FEC524', number: '15', numberColor: '#FEC524', skinTone: '#f0d5be', hairStyle: 'short', hairColor: '#4a3020', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_luka', animal: 'human', name: 'Luka Magic', cost: 25000, heightScale: 1.140, widthScale: 1.0, jerseyColor: '#00538C', shortsColor: '#00538C', sideStripesColor: '#B8C4CA', number: '77', numberColor: '#FFF', skinTone: '#f0d5be', hairStyle: 'short', hairColor: '#4a3020', socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_kd', animal: 'human', name: 'Slim Reaper', cost: 30000, heightScale: 1.200, widthScale: 0.85, armWidthScale: 0.8, legWidthScale: 0.8, jerseyColor: '#1D1160', shortsColor: '#1D1160', sideStripesColor: '#E56020', number: '35', numberColor: '#E56020', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#1D428A' },
        { id: 'human_harden', animal: 'human', name: 'The Beard', cost: 25000, heightScale: 1.110, widthScale: 0.95, jerseyColor: '#CE1141', shortsColor: '#CE1141', sideStripesColor: '#FFF', number: '13', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'mohawk', hairColor: '#000', beard: true, beardColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_vince', animal: 'human', name: 'Vinsanity', cost: 30000, heightScale: 1.130, widthScale: 0.92, jerseyColor: '#753BBD', shortsColor: '#753BBD', pinstripesColor: '#CE1141', number: '15', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_kareem', animal: 'human', name: 'Cap', cost: 45000, heightScale: 1.245, widthScale: 0.88, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '33', numberColor: '#552583', skinTone: '#4a3020', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#1D428A', shortsLength: 'short' },
        { id: 'human_russell', animal: 'human', name: 'Bill', cost: 50000, heightScale: 1.185, widthScale: 0.9, jerseyColor: '#007A33', shortsColor: '#007A33', trimColor: '#FFF', number: '6', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#000', beard: true, beardColor: '#ccc', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_pip', animal: 'human', name: 'Pip', cost: 30000, heightScale: 1.160, widthScale: 0.9, jerseyColor: '#CE1141', shortsColor: '#CE1141', trimColor: '#000', number: '33', numberColor: '#000', skinTone: '#4a3020', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_wade', animal: 'human', name: 'Flash', cost: 30000, heightScale: 1.100, widthScale: 0.92, jerseyColor: '#000', shortsColor: '#000', sideStripesColor: '#98002E', number: '3', numberColor: '#FFF', skinTone: '#4a3020', hairStyle: 'short', hairColor: '#000', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_reggie', animal: 'human', name: 'Reggie', cost: 25000, heightScale: 1.140, widthScale: 0.85, jerseyColor: '#002D62', shortsColor: '#002D62', pinstripesColor: '#FDB927', number: '31', numberColor: '#FDB927', skinTone: '#8d5524', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_tmac', animal: 'human', name: 'T-Mac', cost: 25000, heightScale: 1.160, widthScale: 0.9, jerseyColor: '#007DC5', shortsColor: '#007DC5', pinstripesColor: '#C4CED4', number: '1', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_kg', animal: 'human', name: 'Big Ticket', cost: 30000, heightScale: 1.200, widthScale: 0.88, jerseyColor: '#005083', shortsColor: '#005083', trimColor: '#78BE20', number: '21', numberColor: '#FFF', skinTone: '#2e1e16', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_jackie', animal: 'human', name: 'Semi Moon', cost: 500, heightScale: 1.1, widthScale: 1.0, jerseyColor: '#FFF', shortsColor: '#FFF', trimColor: '#FFA500', sideStripesColor: '#00CED1', number: '33', numberColor: '#00CED1', skinTone: '#ffe0bd', hairStyle: 'afro', hairColor: '#5D4037', headAccessory: 'headband', hatColor: '#FFA500', socksColor: '#FFF', shoesColor: '#FFF', shortsLength: 'short' },

        // PARODIES & MYTHICAL (Unique)
        { id: 'human_hedgehog', animal: 'human', name: 'H√©risson Bleu', cost: 15000, heightScale: 0.9, widthScale: 0.9, jerseyColor: '#0000FF', shortsColor: '#0000FF', sleeveColor: '#0000FF', skinTone: '#0000FF', hairStyle: 'spikes', hairColor: '#0000FF', shoesColor: '#FF0000', socksColor: '#FFF' },
        { id: 'human_soldier', animal: 'human', name: 'Soldat du Futur', cost: 20000, heightScale: 1.2, widthScale: 1.1, jerseyColor: '#2E8B57', shortsColor: '#2E8B57', sleeveColor: '#000', headAccessory: 'helmet', hatColor: '#2E8B57', skinTone: '#000', headDetail: 'visor' },
        { id: 'human_raider', animal: 'human', name: 'Aventuri√®re', cost: 15000, heightScale: 1.05, widthScale: 0.95, jerseyColor: '#00CED1', shortsColor: '#8B4513', skinTone: '#f0d5be', hairStyle: 'long', hairColor: '#5D4037', backAccessory: 'backpack', backColor: '#8B4513', shortsLength: 'short' },
        { id: 'human_goku', animal: 'human', name: 'Guerrier Z', cost: 25000, heightScale: 1.1, widthScale: 1.05, jerseyColor: '#FF4500', shortsColor: '#FF4500', sleeveColor: '#000080', skinTone: '#f0d5be', hairStyle: 'spikes', hairColor: '#FFD700', shoesColor: '#000080' },
        { id: 'human_samus', animal: 'human', name: 'Chasseuse Spatiale', cost: 25000, heightScale: 1.15, widthScale: 1.0, jerseyColor: '#FF4500', shortsColor: '#FF4500', headAccessory: 'helmet', hatColor: '#FF0000', headDetail: 'visor', skinTone: '#FFD700', sleeveColor: '#FFD700', shoesColor: '#FFD700' },
        { id: 'hybrid_marsupial', animal: 'human', name: 'Marsupial', cost: 15000, headType: 'bandicoot', heightScale: 1.0, widthScale: 1.0, jerseyType: 'none', shortsColor: '#0000FF', skinTone: '#FFA500', furColor: '#FFA500', shoesColor: '#FF0000' },
        { id: 'hybrid_yeti', animal: 'human', name: 'Y√©ti', cost: 20000, headType: 'yeti', heightScale: 1.3, widthScale: 1.3, jerseyType: 'none', shortsColor: '#FFF', skinTone: '#FFF', furColor: '#FFF' },
        { id: 'hybrid_cyclops', animal: 'human', name: 'Cyclope', cost: 25000, headType: 'cyclops', heightScale: 1.4, widthScale: 1.2, jerseyType: 'none', shortsColor: '#8B4513', skinTone: '#f0d5be' },

        // NEW LEGENDS & CURRENT STARS
        { id: 'human_nash', animal: 'human', name: 'Captain Canada', cost: 35000, heightScale: 1.05, widthScale: 0.88, jerseyColor: '#1D1160', shortsColor: '#1D1160', sideStripesColor: '#E56020', number: '13', numberColor: '#E56020', skinTone: '#f0d5be', hairStyle: 'long', hairColor: '#6B4423', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_dream', animal: 'human', name: 'The Dream', cost: 40000, heightScale: 1.21, widthScale: 0.95, jerseyColor: '#CE1141', shortsColor: '#CE1141', trimColor: '#FDB927', number: '34', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_ewing', animal: 'human', name: 'Big Pat', cost: 35000, heightScale: 1.21, widthScale: 0.95, jerseyColor: '#006BB6', shortsColor: '#006BB6', trimColor: '#F58426', number: '33', numberColor: '#F58426', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_zeke', animal: 'human', name: 'Zeke', cost: 35000, heightScale: 1.02, widthScale: 0.85, jerseyColor: '#006BB6', shortsColor: '#006BB6', sideStripesColor: '#ED174C', number: '11', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'short', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_glide', animal: 'human', name: 'The Glide', cost: 35000, heightScale: 1.15, widthScale: 0.92, jerseyColor: '#CE1141', shortsColor: '#CE1141', trimColor: '#000', number: '22', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'bald', hairColor: '#000', socksColor: '#FFF', shoesColor: '#000', shortsLength: 'short' },
        { id: 'human_truth', animal: 'human', name: 'The Truth', cost: 30000, heightScale: 1.15, widthScale: 1.0, jerseyColor: '#007A33', shortsColor: '#007A33', trimColor: '#000', number: '34', numberColor: '#FFF', skinTone: '#5c3a21', hairStyle: 'headband', hairColor: '#000', headbandColor: '#007A33', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_shuttlesworth', animal: 'human', name: 'Jesus', cost: 30000, heightScale: 1.13, widthScale: 0.9, jerseyColor: '#007A33', shortsColor: '#007A33', trimColor: '#FFF', number: '20', numberColor: '#FFF', skinTone: '#8d5524', hairStyle: 'bald', hairColor: '#000', sleeveLeft: '#007A33', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_klaw', animal: 'human', name: 'The Klaw', cost: 35000, heightScale: 1.15, widthScale: 1.0, jerseyColor: '#000', shortsColor: '#000', sideStripesColor: '#C4CED4', number: '2', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'cornrows', hairColor: '#000', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_wemby', animal: 'human', name: 'L\'Alien', cost: 35000, heightScale: 1.30, widthScale: 0.85, armWidthScale: 0.8, legWidthScale: 0.8, jerseyColor: '#000', shortsColor: '#000', sideStripesColor: '#C4CED4', number: '1', numberColor: '#FFF', skinTone: '#8d5524', hairStyle: 'short', hairColor: '#000', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_sga', animal: 'human', name: 'SGA', cost: 30000, heightScale: 1.14, widthScale: 0.9, jerseyColor: '#007AC1', shortsColor: '#007AC1', sideStripesColor: '#EF3B24', number: '2', numberColor: '#EF3B24', skinTone: '#5c3a21', hairStyle: 'cornrows', hairColor: '#000', headbandColor: '#000', socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_brow', animal: 'human', name: 'The Brow', cost: 30000, heightScale: 1.21, widthScale: 0.95, jerseyColor: '#FDB927', shortsColor: '#FDB927', sideStripesColor: '#552583', number: '3', numberColor: '#552583', skinTone: '#5c3a21', hairStyle: 'afro', hairColor: '#000', beard: true, socksColor: '#FFF', shoesColor: '#000' },
        { id: 'human_kyrie', animal: 'human', name: 'Uncle Drew', cost: 30000, heightScale: 1.04, widthScale: 0.9, jerseyColor: '#00538C', shortsColor: '#00538C', sideStripesColor: '#B8C4CA', number: '11', numberColor: '#FFF', skinTone: '#8d5524', hairStyle: 'short', hairColor: '#000', beard: true, socksColor: '#000', shoesColor: '#000' },
        { id: 'human_dame', animal: 'human', name: 'Dame Time', cost: 30000, heightScale: 1.04, widthScale: 0.95, jerseyColor: '#000', shortsColor: '#000', pinstripesColor: '#CE1141', number: '0', numberColor: '#CE1141', skinTone: '#5c3a21', hairStyle: 'short', hairColor: '#000', sleeveLeft: '#000', socksColor: '#000', shoesColor: '#000' },
        { id: 'human_tatum', animal: 'human', name: 'Taco Jay', cost: 30000, heightScale: 1.18, widthScale: 0.95, jerseyColor: '#007A33', shortsColor: '#007A33', trimColor: '#FFF', number: '0', numberColor: '#FFF', skinTone: '#dcb98a', hairStyle: 'short', hairColor: '#000', beard: true, socksColor: '#FFF', shoesColor: '#FFF' },
        { id: 'human_process', animal: 'human', name: 'The Process', cost: 30000, heightScale: 1.25, widthScale: 1.1, jerseyColor: '#006BB6', shortsColor: '#006BB6', trimColor: '#ED174C', number: '21', numberColor: '#FFF', skinTone: '#3e271a', hairStyle: 'short', hairColor: '#000', beard: true, socksColor: '#FFF', shoesColor: '#000' },

        // FAKE VIDEO GAME CHARACTERS
        { id: 'fake_mario', animal: 'human', name: 'Plombier Rouge', cost: 10000, heightScale: 0.9, widthScale: 1.1, jerseyColor: '#F00', shortsColor: '#00F', number: 'M', numberColor: '#F00', skinTone: '#ffe0bd', hairStyle: 'hat', hairColor: '#3c2415', hatColor: '#F00', clothingDetail: 'overalls', beard: true, beardColor: '#3c2415', socksColor: '#FFF', shoesColor: '#3c2415' },
        { id: 'fake_luigi', animal: 'human', name: 'Plombier Vert', cost: 10000, heightScale: 1.1, widthScale: 0.9, jerseyColor: '#00A000', shortsColor: '#00F', number: 'L', numberColor: '#00A000', skinTone: '#ffe0bd', hairStyle: 'hat', hairColor: '#3c2415', hatColor: '#00A000', clothingDetail: 'overalls', beard: true, beardColor: '#3c2415', socksColor: '#FFF', shoesColor: '#3c2415' },
        { id: 'fake_link', animal: 'human', name: 'Elfe H√©ros', cost: 12000, heightScale: 1.0, widthScale: 0.95, jerseyColor: '#00A000', shortsColor: '#FFF', number: '', numberColor: '#000', skinTone: '#ffe0bd', hairStyle: 'long', hairColor: '#FFD700', headAccessory: 'wizard_hat', hatColor: '#00A000', socksColor: '#FFF', shoesColor: '#3c2415' },
        { id: 'fake_kratos', animal: 'human', name: 'Spartiate', cost: 15000, heightScale: 1.15, widthScale: 1.2, jerseyColor: '#B22222', shortsColor: '#333', number: '', numberColor: '#000', skinTone: '#FFF', hairStyle: 'beard', hairColor: '#333', beard: true, beardColor: '#333', pattern: 'tattoo_red', socksColor: '#333', shoesColor: '#333' },
        { id: 'fake_zeus', animal: 'human', name: 'Dieu Tonnerre', cost: 20000, heightScale: 1.2, widthScale: 1.1, jerseyColor: '#FFF', shortsColor: '#FFF', number: '', numberColor: '#FFD700', skinTone: '#dcb98a', hairStyle: 'curly_long', hairColor: '#FFF', beard: true, beardColor: '#FFF', headAccessory: 'bandana_neck', hatColor: '#FFD700', shoesColor: '#FFD700' },

        // THE ANCHOR (Ron Burgundy Parody)
        { id: 'human_anchor', animal: 'human', name: 'The Anchor', cost: 0, heightScale: 1.06, widthScale: 1.05, jerseyColor: '#800020', shortsColor: '#800020', legType: 'pants', sleeveColor: '#800020', hairStyle: 'pompadour', hairColor: '#5D4037', skinTone: '#f0d5be', shoesColor: '#333', pattern: 'suit_jacket', jerseyType: 'tshirt' },

        // MYTHICAL CREATURES (HYBRIDS)
        { id: 'hybrid_minotaur', animal: 'human', name: 'Minotaure', cost: 25000, headType: 'bull', heightScale: 1.3, widthScale: 1.2, jerseyType: 'none', shortsColor: '#5D4037', skinTone: '#8B4513', furColor: '#8B4513', tailType: 'bull' },
        { id: 'hybrid_gorgon', animal: 'human', name: 'Gorgone', cost: 25000, heightScale: 1.05, widthScale: 1.0, jerseyColor: '#228B22', shortsColor: '#333', skinTone: '#90EE90', hairStyle: 'snakes', hairColor: '#006400', tailType: 'snake' },
        { id: 'hybrid_anubis', animal: 'human', name: 'Anubis', cost: 30000, headType: 'jackal', heightScale: 1.2, widthScale: 0.95, jerseyType: 'none', shortsColor: '#FFF', skinTone: '#000', furColor: '#000', headAccessory: 'gold_bands' }
    ];

    var ANIMALS = ['rat', 'cat', 'dog', 'bear', 'rabbit', 'moose', 'fox', 'wolf', 'lion', 'tiger', 'pig', 'cow', 'monkey', 'penguin', 'human'];
    var CROWD_EMOJIS = ['üê≠', 'üê±', 'üê∂', 'üêª', 'üêº', 'üê®', 'üêØ', 'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ', 'üêî', 'üêß', 'üê¶'];

    var SHOOTING_STYLES = [
        // KEPT
        { id: 'classic', name: 'Classique', cost: 0, desc: 'Style standard. √âquilibr√©.', modifiers: {} },
        { id: 'curry', name: 'Chef Curry', cost: 0, desc: 'Tir rapide et fluide.', modifiers: { timingWindow: 0.9 } },

        // NEW REALISTIC (NBA LEGENDS)
        { id: 'jordan', name: 'The GOAT', cost: 0, desc: 'Suspension parfaite, saut maximal.', modifiers: { jumpVelocity: 10.5, timingWindow: 0.85 } },
        { id: 'kobe', name: 'Black Mamba', cost: 0, desc: 'Fadeaway technique et pr√©cis.', modifiers: { timingWindow: 0.8, speed: 1.1 } },
        { id: 'lebron', name: 'King James', cost: 0, desc: 'Tir puissant, recul l√©ger.', modifiers: { jumpVelocity: 10.0, speed: 1.2 } },
        { id: 'kd', name: 'Slim Reaper', cost: 0, desc: 'Rel√¢chement tr√®s haut, impossible √† contrer.', modifiers: { speed: 0.9, timingWindow: 0.95 } },
        { id: 'ray', name: 'Jesus', cost: 0, desc: 'M√©canique robotique parfaite.', modifiers: { speed: 1.4, timingWindow: 0.9 } },
        { id: 'bird', name: 'Larry Legend', cost: 0, desc: 'Tir derri√®re la t√™te, tr√®s pr√©cis.', modifiers: { speed: 0.8, timingWindow: 1.2 } },
        { id: 'dirk', name: 'German Jesus', cost: 0, desc: 'Fadeaway sur une jambe.', modifiers: { timingWindow: 1.0, speed: 0.9 } },
        { id: 'kareem', name: 'Sky Hook', cost: 0, desc: 'Le bras roul√© inarr√™table. (Au sol)', modifiers: { jumpVelocity: 0, speed: 0.8 } },
        { id: 'shaq', name: 'Diesel', cost: 0, desc: 'Tir √† une main rigide.', modifiers: { jumpVelocity: 6, speed: 1.1, timingWindow: 0.7 } },
        { id: 'magic', name: 'Showtime', cost: 0, desc: 'Pouss√©e du ballon, vision de jeu.', modifiers: { speed: 1.0 } },
        { id: 'harden', name: 'The Beard', cost: 0, desc: 'Step-back et pause.', modifiers: { timingWindow: 1.1, speed: 0.9 } },
        { id: 'luka', name: 'Luka Magic', cost: 0, desc: 'Tir lent mais hypnotique.', modifiers: { speed: 0.85, timingWindow: 1.15 } },
        { id: 'klay', name: 'Game 6', cost: 0, desc: 'Forme pure, pas de saut inutile.', modifiers: { speed: 1.3, timingWindow: 0.95 } },
        { id: 'reggie', name: 'Knick Killer', cost: 0, desc: 'Extension compl√®te des bras.', modifiers: { speed: 1.2 } },
        { id: 'westbrook', name: 'Brodie', cost: 0, desc: 'Saut explosif, tir tendu.', modifiers: { jumpVelocity: 11.0, speed: 1.5, timingWindow: 0.6 } },
        { id: 'joker', name: 'Big Honey', cost: 0, desc: 'Tir derri√®re la t√™te. (Au sol)', modifiers: { jumpVelocity: 0, speed: 0.8 } },
        { id: 'trae', name: 'Ice Trae', cost: 0, desc: 'Pouss√©e rapide depuis la poitrine.', modifiers: { speed: 1.3, timingWindow: 0.9 } },
        { id: 'ai', name: 'The Answer', cost: 0, desc: 'Arm√© tr√®s haut derri√®re la t√™te.', modifiers: { speed: 1.4, jumpVelocity: 10.0 } },
        { id: 'melo', name: 'Hoodie Melo', cost: 0, desc: 'Le tir le plus pur.', modifiers: { speed: 1.0, timingWindow: 1.0 } },
        { id: 'haliburton', name: 'Hali', cost: 0, desc: 'Tir bizarre √† deux mains.', modifiers: { speed: 1.1, timingWindow: 0.8 } },
        { id: 'marion', name: 'The Matrix', cost: 0, desc: 'T-Rex shot. Tr√®s moche.', modifiers: { speed: 1.8, timingWindow: 0.7 } },
        { id: 'noah', name: 'Tornado', cost: 0, desc: 'La tornade √† deux mains.', modifiers: { speed: 0.9, jumpVelocity: 8.0 } },
        { id: 'bol', name: 'Manute', cost: 0, desc: 'La catapulte g√©ante.', modifiers: { speed: 0.7, jumpVelocity: 4.0 } },
        { id: 'sga', name: 'Timeline', cost: 0, desc: 'Lent et m√©thodique.', modifiers: { speed: 0.9, timingWindow: 1.1 } },

        // NEW SILLY / GROUNDED
        { id: 'granny', name: 'Rick Barry', cost: 0, desc: '√Ä la cuill√®re. (Au sol)', modifiers: { jumpVelocity: 0, speed: 0.7, timingWindow: 1.5 } },
        { id: 'bowling', name: 'Strike', cost: 0, desc: 'Lancer de bowling. (Au sol)', modifiers: { jumpVelocity: 0, speed: 0.6 } },
        { id: 'hadouken', name: 'Hadouken', cost: 0, desc: 'Boule de feu ! (Au sol)', modifiers: { jumpVelocity: 0, speed: 2.5, timingWindow: 0.5 } },
        { id: 'tpose', name: 'Le Glitch', cost: 0, desc: 'T-Pose mena√ßante. (Au sol)', modifiers: { jumpVelocity: 0, speed: 3.0, timingWindow: 0.3 } },
        { id: 'airbud', name: 'Le Museau', cost: 0, desc: 'Passe de la truffe.', modifiers: { speed: 1.2, jumpVelocity: 0 } },
        { id: 'telekinesis', name: 'Psychokin√©sie', cost: 0, desc: 'Par la pens√©e.', modifiers: { jumpVelocity: 0, speed: 2.0, timingWindow: 0.5 } },
        { id: 'peekaboo', name: 'Coucou !', cost: 0, desc: 'O√π est-il ?', modifiers: { jumpVelocity: 0, speed: 0.8 } }
    ];

    // Animation Keyframes (Optimized: Moved to global scope to avoid reallocation)
    const DEFAULT_IDLE = { la: Math.PI/2 - 0.2, ra: Math.PI/2 + 0.2, lfa: Math.PI/2 - 0.1, rfa: Math.PI/2 + 0.1, w: 0 };
    const ANIM_DATA = {
        // --- KEPT ---
        classic: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -2.2, ra: -2.2, lfa: -0.5, rfa: -0.8, w: 0 },
            release: { la: -2.0, ra: -Math.PI/2 - 0.2, lfa: -0.8, rfa: -Math.PI/2 - 0.1, w: 1.0 }
        },
        curry: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.8, rfa: -1.8, w: 0 },
            set: { la: -1.0, ra: -1.2, lfa: -2.5, rfa: -2.8, w: 0.5 },
            release: { la: -1.2, ra: -Math.PI/2 - 0.3, lfa: -2.2, rfa: -Math.PI/2, w: 1.5 }
        },

        // --- NEW REALISTIC ---
        jordan: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.3, ra: -2.5, lfa: -1.2, rfa: -1.6, w: 0 }, // High set
            release: { la: -2.0, ra: -Math.PI/2 - 0.4, lfa: -1.0, rfa: -Math.PI/2 - 0.2, w: 1.6 } // Perfect follow through
        },
        kobe: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.4, ra: -2.4, lfa: -1.5, rfa: -2.6, w: 0 }, // Fadeaway posture
            release: { la: -2.1, ra: -Math.PI/2 - 0.5, lfa: -1.8, rfa: -Math.PI/2 - 0.3, w: 1.7 } // High release
        },
        lebron: {
            ready: { la: 0.4, ra: 2.4, lfa: 1.4, rfa: -1.6, w: 0 },
            set: { la: -2.0, ra: -2.3, lfa: -2.0, rfa: -2.8, w: 0 }, // Power gather
            release: { la: -1.5, ra: -Math.PI/2 - 0.2, lfa: -2.2, rfa: -Math.PI/2, w: 1.5 }
        },
        kd: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -2.6, ra: -2.8, lfa: -2.0, rfa: -2.0, w: 0 }, // Starting high
            release: { la: -2.4, ra: -Math.PI/2 - 0.8, lfa: -1.5, rfa: -Math.PI/2 - 0.6, w: 1.8 } // Super high release point
        },
        ray: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.6, rfa: -1.9, w: 0 },
            set: { la: -2.2, ra: -2.2, lfa: -2.5, rfa: -2.9, w: 0 }, // 90 degree perfect
            release: { la: -2.0, ra: -Math.PI/2 - 0.3, lfa: -2.2, rfa: -Math.PI/2 - 0.1, w: 1.6 } // Snap
        },
        bird: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -2.8, ra: -3.0, lfa: -1.5, rfa: -1.5, w: 0.5 }, // Behind head
            release: { la: -2.5, ra: -Math.PI/2 - 0.1, lfa: -1.2, rfa: -Math.PI/2, w: 1.2 }
        },
        dirk: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -2.5, ra: -2.5, lfa: -1.5, rfa: -1.5, w: 0 }, // High hold
            release: { la: -2.3, ra: -Math.PI/2, lfa: -1.3, rfa: -Math.PI/2, w: 1.0 } // Soft touch
        },
        kareem: {
            ready: { la: 1.0, ra: 1.0, lfa: 1.5, rfa: 1.5, w: 0 },
            set: { la: 0.5, ra: 0.0, lfa: 2.0, rfa: -2.0, w: 0 }, // Side windup
            release: { la: 0.5, ra: -Math.PI + 0.5, lfa: 1.5, rfa: -Math.PI, w: 0.5 } // Hook extension
        },
        shaq: {
            ready: { la: 0.5, ra: 2.0, lfa: 1.5, rfa: -1.5, w: 0 },
            set: { la: -1.5, ra: -2.0, lfa: -0.5, rfa: -1.0, w: 0 }, // Bulky set
            release: { la: -1.0, ra: -Math.PI/2, lfa: -0.5, rfa: -1.0, w: 0.5 } // Push, no wrist flick
        },
        magic: {
            ready: { la: 0.5, ra: 2.4, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -1.8, ra: -1.8, lfa: -0.5, rfa: -0.5, w: 0 }, // Chest push start
            release: { la: -1.5, ra: -Math.PI/2 + 0.2, lfa: -0.8, rfa: -Math.PI/2 + 0.2, w: 1.0 }
        },
        harden: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -1.5, ra: -1.5, lfa: -2.5, rfa: -2.5, w: 0 }, // Low gather
            release: { la: -1.8, ra: -Math.PI/2 - 0.4, lfa: -2.0, rfa: -Math.PI/2 - 0.2, w: 1.5 }
        },
        luka: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.0, ra: -2.2, lfa: -1.0, rfa: -1.8, w: 0.2 }, // Slow windup
            release: { la: -1.8, ra: -Math.PI/2 - 0.3, lfa: -1.2, rfa: -Math.PI/2, w: 1.4 }
        },
        klay: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.1, ra: -2.1, lfa: -2.3, rfa: -2.6, w: 0 }, // Compact
            release: { la: -2.0, ra: -Math.PI/2 - 0.2, lfa: -2.1, rfa: -Math.PI/2, w: 1.5 }
        },
        reggie: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.2, ra: -2.2, lfa: -2.5, rfa: -2.9, w: 0 },
            release: { la: -1.5, ra: -Math.PI/2 - 0.2, lfa: -1.5, rfa: -Math.PI/2 - 0.4, w: 1.5 } // Arms cross slightly
        },
        westbrook: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.5, ra: -2.8, lfa: -2.0, rfa: -2.5, w: 0 }, // High jump point
            release: { la: -2.3, ra: -Math.PI/2 - 0.6, lfa: -2.2, rfa: -Math.PI/2 - 0.4, w: 2.0 } // Aggressive snap
        },
        joker: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -1.2, ra: -3.0, lfa: -2.3, rfa: -2.2, w: 0 }, // Deep behind head
            release: { la: -1.5, ra: -Math.PI/2 - 0.1, lfa: -2.0, rfa: -Math.PI/2, w: 0.8 } // Lazy flick
        },
        trae: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -1.2, ra: -1.2, lfa: -2.5, rfa: -2.5, w: 0.5 }, // Low push
            release: { la: -1.0, ra: -1.0, lfa: -2.2, rfa: -1.5, w: 1.0 } // Push forward
        },
        ai: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -1.4, ra: -3.0, lfa: -2.5, rfa: -2.5, w: 0 }, // Way back
            release: { la: -1.8, ra: -Math.PI/2 - 0.5, lfa: -2.2, rfa: -Math.PI/2 - 0.3, w: 1.8 } // Snap
        },
        melo: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.3, ra: -2.3, lfa: -2.0, rfa: -2.6, w: 0 }, // Textbook
            release: { la: -2.1, ra: -Math.PI/2 - 0.3, lfa: -1.8, rfa: -Math.PI/2 - 0.1, w: 1.5 }
        },
        haliburton: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -1.5, ra: -1.5, lfa: -1.5, rfa: -1.5, w: 0 }, // Both hands low
            release: { la: -1.5, ra: -1.2, lfa: -1.5, rfa: -1.2, w: 1.0 } // Push shot
        },
        marion: {
            ready: { la: 0.5, ra: 2.5, lfa: 2.0, rfa: -2.0, w: 0 },
            set: { la: -1.0, ra: -1.2, lfa: -2.8, rfa: -2.8, w: 0 }, // T-Rex
            release: { la: -0.8, ra: -0.8, lfa: -2.5, rfa: -0.5, w: 0.2 } // Tiny flick
        },
        noah: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 },
            set: { la: -1.8, ra: -1.8, lfa: 0.5, rfa: -0.5, w: 1.0 }, // Tornado spin
            release: { la: -1.5, ra: -0.8, lfa: 0.2, rfa: -0.2, w: 0 }
        },
        bol: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -2.8, ra: -3.0, lfa: -1.5, rfa: -1.8, w: 0 }, // Far back
            release: { la: -2.5, ra: -1.5, lfa: -1.2, rfa: -1.2, w: 0.5 } // Catapult
        },
        sga: {
            ready: { la: 0.5, ra: 2.5, lfa: 1.5, rfa: -1.8, w: 0 },
            set: { la: -1.8, ra: -2.0, lfa: -1.5, rfa: -1.8, w: 0.2 }, // Slow methodical
            release: { la: -1.6, ra: -Math.PI/2 - 0.2, lfa: -1.2, rfa: -Math.PI/2, w: 1.2 }
        },

        // --- NEW SILLY / GROUNDED ---
        granny: {
            ready: { la: 0.8, ra: 0.8, lfa: 2.0, rfa: 2.0, w: 0 },
            set: { la: 1.0, ra: 1.2, lfa: 2.2, rfa: 2.2, w: 0 }, // Low between legs
            release: { la: -1.0, ra: -1.0, lfa: 0.5, rfa: 0.5, w: 0 } // Scoop up
        },
        bowling: {
            ready: { la: 0.2, ra: 1.5, lfa: 2.0, rfa: 1.0, w: 0 },
            set: { la: 0.2, ra: 2.8, lfa: 2.0, rfa: 2.9, w: 0 }, // Backswing
            release: { la: 0.2, ra: -1.8, lfa: 1.0, rfa: -0.2, w: 0 } // Roll forward
        },
        hadouken: {
            ready: { la: 1.5, ra: 1.5, lfa: 2.5, rfa: 0.5, w: 0 },
            set: { la: 1.8, ra: 1.8, lfa: 2.9, rfa: 0.4, w: 0 }, // Charge at hip
            release: { la: -1.5, ra: -1.6, lfa: -0.1, rfa: -0.1, w: 0 } // Thrust
        },
        tpose: {
            ready: { la: 0, ra: 0, lfa: 0, rfa: 0, w: 0 },
            set: { la: 0, ra: 0, lfa: 0, rfa: 0, w: 0 },
            release: { la: 0, ra: 0, lfa: 0, rfa: 0, w: 0 } // Dominance
        },
        airbud: {
            ready: { la: 0.5, ra: 2.6, lfa: 1.5, rfa: -2.0, w: 0 }, // Holding ball (Classic Ready)
            set: { la: 1.3, ra: 1.8, lfa: 1.3, rfa: 1.8, w: 0 }, // Paws drop down (Tuck)
            release: { la: 1.5, ra: 1.6, lfa: 1.5, rfa: 1.6, w: 0 } // Stay down
        },
        telekinesis: {
            ready: { la: 1.5, ra: 1.6, lfa: 1.5, rfa: 1.6, w: 0 }, // Sides
            set: { la: -2.0, ra: -1.1, lfa: -0.5, rfa: -2.6, w: 0 }, // Temples
            release: { la: -0.5, ra: -2.6, lfa: -0.5, rfa: -2.6, w: 0 } // Fling Out
        },
        peekaboo: {
            ready: { la: -2.0, ra: -1.1, lfa: -0.5, rfa: -2.6, w: 0 }, // Hands on face
            set: { la: -2.0, ra: -1.1, lfa: -0.5, rfa: -2.6, w: 0 }, // Still on face
            release: { la: -0.5, ra: -2.6, lfa: -0.5, rfa: -2.6, w: 0 } // Fling Out
        }
    };

    // Center of screen is 1066/2 = 533.
    // Shift hoop to x=600 is fine (slightly right),
    // but we might want to center the "court path" a bit more.
    const HOOP_POS = { x: 733, y: 150, z: 130 }; // Moved +133 to account for +266 width
    const PIXELS_PER_FOOT = 4.2426;

    var decors = [];
    // Increased range to ~120,000 pixels (approx 28,000 feet) to cover late game
    // Increased count to 4000 to maintain density
    for(let i=0; i<4000; i++) {
        const dist = Math.random() * 120000;
        const pathX = 733 - (dist * 0.7);
        const pathY = 150 + (dist * 0.7);
        const scatter = (Math.random() - 0.5) * 1200;

        const dX = pathX + scatter;
        const dY = pathY + scatter;

        // Safety Corridor Check: Prevent objects between player (sum=600) and hoop (sum=750)
        // Player Width ~30 units. Safety = 1.5x (~45).
        // Corridor: [600 - 60, 750 + 60] -> [540, 810]
        const sum = dX + dY;
        if (sum > 540 && sum < 810) continue;

        const dDist = Math.sqrt(Math.pow(dX - HOOP_POS.x, 2) + Math.pow(dY - HOOP_POS.y, 2));

        // Convert Pixel Distance to Game Feet for Zone Lookup
        const feetDist = dDist / PIXELS_PER_FOOT;

        const decorZone = COURT_ZONES.find(z => feetDist < z.limit) || COURT_ZONES[COURT_ZONES.length-1];
        let variant = 'default';
        if(decorZone.type === 'tree') {
             variant = (decorZone.name.includes("FOR√äT") || decorZone.name.includes("MONT")) ? 'pine' : 'oak';
        }
        decors.push({ x: dX, y: dY, dist: dist, zoneType: decorZone.type, variant: variant, seed: Math.random() });
    }

    // Crowd Generation (Stands along the side)
    for(let d = 500; d < 120000; d += 800) {
        const pathX = 733 - (d * 0.7);
        const pathY = 150 + (d * 0.7);
        const offset = 400;
        const density = Math.min(1.0, d/50000);

        // Left Stand
        if (Math.random() > 0.3) {
             decors.push({ x: pathX - offset, y: pathY - offset, dist: d, zoneType: 'crowd', variant: {side:'left', density:density}, seed: Math.random() });
        }
        // Right Stand
        if (Math.random() > 0.3) {
             decors.push({ x: pathX + offset, y: pathY + offset, dist: d, zoneType: 'crowd', variant: {side:'right', density:density}, seed: Math.random() });
        }
    }

    // LANDMARK GENERATION
    SCALE_OBJECTS.forEach(obj => {
        if (obj.type) {
            const dist = obj.limit * PIXELS_PER_FOOT;
            const pathX = 733 - (dist * 0.7);
            const pathY = 150 + (dist * 0.7);
            // Place landmarks mostly centered but pushed back or offset
            const offset = (Math.random() > 0.5 ? 1 : -1) * (300 + Math.random()*200);
            decors.push({ x: pathX + offset, y: pathY + offset, dist: dist, zoneType: obj.type, variant: obj, seed: Math.random() });
        }
    });

    // TACO CAT: One per zone guaranteed
    for(let i=0; i<COURT_ZONES.length; i++) {
        const z = COURT_ZONES[i];
        const prevLimit = (i === 0) ? 0 : COURT_ZONES[i-1].limit;
        const range = Math.min(z.limit, prevLimit + 3000) - prevLimit; // Cap range slightly for large zones

        const dist = prevLimit + Math.random() * range; // This is FEET

        // Convert Feet to Pixels for Coordinate Calculation
        const pixelDist = dist * PIXELS_PER_FOOT;

        const pathX = 733 - (pixelDist * 0.7);
        const pathY = 150 + (pixelDist * 0.7);

        let dX, dY;
        let attempts = 0;
        do {
            const scatter = (Math.random() - 0.5) * 1000;
            dX = pathX + scatter;
            dY = pathY + scatter;
            attempts++;
        } while (attempts < 10 && (dX + dY > 540 && dX + dY < 810));

        decors.push({ x: dX, y: dY, dist: pixelDist, zoneType: 'tacocat', variant: 'default', seed: Math.random() });
    }

    // OPTIMIZATION: Sort decors by distance from hoop to allow early exit in render loop
    decors.sort((a, b) => a.dist - b.dist);

    var clouds = [];
    var mountainLayers = [];

    function initBackgroundElements() {
        // Clouds
        clouds = [];
        for(let i=0; i<8; i++) {
            let c = {
                x: Math.random() * 2000,
                y: Math.random() * 200,
                speed: 0.1 + Math.random() * 0.2,
                scale: 0.8 + Math.random() * 0.8,
                puffs: []
            };
            let numPuffs = 4 + Math.floor(Math.random() * 5);
            for(let j=0; j<numPuffs; j++) {
                c.puffs.push({
                    dx: (Math.random() - 0.5) * 60,
                    dy: (Math.random() - 0.5) * 30,
                    r: 25 + Math.random() * 25
                });
            }
            clouds.push(c);
        }

        // Mountain Layers
        mountainLayers = [];
        const colors = ['#2F4F4F', '#243b3b', '#162424'];
        const baseHeights = [250, 180, 120];
        const speeds = [0.02, 0.05, 0.1];

        for(let L=0; L<3; L++) {
            let points = [];
            let x = 0;
            let y = Math.random() * baseHeights[L];
            // Generate a looped path
            while(x <= 2200) { // Enough for screen width + shift
                 points.push({x: x, y: y});
                 x += 40 + Math.random() * 60;
                 y += (Math.random() - 0.5) * 100;
                 if(y < 50) y = 50; if(y > baseHeights[L] + 100) y = baseHeights[L] + 100;
            }
            // Smooth loop?
            points[points.length-1].y = points[0].y;
            mountainLayers.push({ points: points, color: colors[L], speed: speeds[L] });
        }
    }
    initBackgroundElements();

    var bgCache = null;

    // --- OPTIMIZATION: Render Object Pooling ---
    // Monomorphic class for V8 optimization
    class RenderItem {
        constructor() {
            this.type = null;
            this.depth = 0;
            this.x = 0;
            this.y = 0;
            this.scale = 0;
            this.zoneType = null;
            this.variant = null;
            this.seed = 0;
            this.alpha = 0;
            this.color = null;
            this.ballRef = null;
        }
    }

    var g_renderItemPool = [];
    var g_renderList = [];
    let g_poolIndex = 0;

    function getRenderItem() {
        let obj;
        if (g_poolIndex < g_renderItemPool.length) {
            obj = g_renderItemPool[g_poolIndex];
        } else {
            obj = new RenderItem();
            g_renderItemPool.push(obj);
        }
        g_poolIndex++;
        return obj;
    }

    // Pre-allocate some objects
    for(let i=0; i<1000; i++) {
        g_renderItemPool.push(new RenderItem());
    }

    // --- OPTIMIZATION: Cached Shooting Style ---
    let g_cachedStyleId = null;
    let g_cachedStyleObj = null;

    function getCurrentStyle() {
        const currentId = playerData.currentStyle || 'classic';
        if (currentId !== g_cachedStyleId || !g_cachedStyleObj) {
            g_cachedStyleObj = SHOOTING_STYLES.find(s => s.id === currentId) || SHOOTING_STYLES[0];
            g_cachedStyleId = currentId;
        }
        return g_cachedStyleObj;
    }

    function isMechanicalSkin(skinId) {
        if (!skinId) return false;
        const s = skinId.toLowerCase();
        return s.includes('robot') || s.includes('cyborg') || s.includes('mech') || s.includes('cyber') || s.includes('android');
    }

    // --- OPTIMIZATION: Fuzzy Noise Lookup Table ---
    const NOISE_LUT_SIZE = 4096;
    const g_noiseLUT = new Float32Array(NOISE_LUT_SIZE);
    for (let i = 0; i < NOISE_LUT_SIZE; i++) {
        g_noiseLUT[i] = Math.random();
    }

    // --- BASKETBALL GEOMETRY (For Rotation) ---
    var g_ballGeo = [];
    function generateBasketballGeometry() {
        const paths = [];
        const res = 24; // Points per circle

        // Circle 1: Facing Viewer (XY Plane)
        let c1 = []; for(let i=0; i<=res; i++) { const a = (i/res)*Math.PI*2; c1.push({x:Math.cos(a), y:Math.sin(a), z:0}); }
        // Circle 2: Perpendicular Vertical (YZ Plane)
        let c2 = []; for(let i=0; i<=res; i++) { const a = (i/res)*Math.PI*2; c2.push({x:0, y:Math.cos(a), z:Math.sin(a)}); }
        // Circle 3: Perpendicular Horizontal (XZ Plane)
        let c3 = []; for(let i=0; i<=res; i++) { const a = (i/res)*Math.PI*2; c3.push({x:Math.cos(a), y:0, z:Math.sin(a)}); }

        paths.push(c1, c2, c3);
        return paths;
    }
    g_ballGeo = generateBasketballGeometry();

    function binarySearchLowerBound(arr, val) {
        let l = 0, r = arr.length - 1;
        let idx = arr.length; // Default if not found (all smaller)
        while (l <= r) {
            let m = (l + r) >>> 1; // Unsigned right shift for floor
            if (arr[m].dist >= val) {
                idx = m;
                r = m - 1;
            } else {
                l = m + 1;
            }
        }
        return idx;
    }

    // --- 1.5 AUDIO SYSTEM (RETRO SYNTH) ---
    const AudioSystem = {
        ctx: null,
        isMuted: false,
        isPlayingMusic: false,
        nextNoteTime: 0,
        beatCount: 0,
        lookahead: 25.0,
        scheduleAheadTime: 0.1,
        timerID: null,
        currentTrackIndex: 0,
        tracks: [],

        init: function() {
            if (this.ctx) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.ctx = new AudioContext();
            if(this.ctx.state === 'suspended') this.ctx.resume();

            this.tracks = [
                {
                    name: 'Lo-Fi Chill',
                    tempo: 0.2, // Seconds per 16th note (approx 75 BPM)
                    schedule: (beat, time, sys) => {
                        if (beat % 16 === 0 || beat % 16 === 10) sys.playKick(time, {freq: 150, decay: 0.5});
                        if (beat % 16 === 8) sys.playSnare(time, {tone: 250, noise: 1000});
                        if (beat % 2 === 0) sys.playHiHat(time, {freq: 7000, decay: 0.05, vol: 0.1});
                        if (beat === 0) sys.playChord(time, [261.6, 311.1, 392.0, 466.2], 'triangle', 800);
                        if (beat === 16) sys.playChord(time, [174.6, 207.7, 261.6, 311.1], 'triangle', 800);
                    }
                },
                {
                    name: 'Rock Arena',
                    tempo: 0.15, // Faster (100 BPM)
                    schedule: (beat, time, sys) => {
                        if (beat % 16 === 0 || beat % 16 === 10 || beat % 16 === 14) sys.playKick(time, {freq: 120, decay: 0.3, type:'square'});
                        if (beat % 16 === 4 || beat % 16 === 12) sys.playSnare(time, {tone: 200, noise: 800, decay: 0.2, vol: 0.3});
                        if (beat % 4 === 0) sys.playHiHat(time, {freq: 5000, decay: 0.1, vol: 0.2});
                        if (beat === 0) sys.playChord(time, [130.8, 196.0, 261.6], 'sawtooth', 2000, 0.1); // C3 Power
                        if (beat === 16) sys.playChord(time, [110.0, 164.8, 220.0], 'sawtooth', 2000, 0.1); // A2 Power
                    }
                },
                {
                    name: '8-Bit Arcade',
                    tempo: 0.12, // Fast (125 BPM)
                    schedule: (beat, time, sys) => {
                         if (beat % 8 === 0) sys.playKick(time, {freq: 200, decay: 0.1, type: 'square'});
                         if (beat % 8 === 4) sys.playSnare(time, {noise: 3000, decay: 0.1, vol: 0.2, type: 'noise_only'});
                         const arpeggio = [523.25, 659.25, 783.99, 1046.50]; // C Major
                         if (beat % 2 === 0) {
                             const note = arpeggio[(beat/2) % 4];
                             sys.playTone(time, note, 'square', 0.1);
                         }
                    }
                },
                {
                    name: 'Trap Beat',
                    tempo: 0.18, // ~83 BPM
                    schedule: (beat, time, sys) => {
                        if (beat % 32 === 0 || beat % 32 === 10 || beat % 32 === 22) sys.playKick(time, {freq: 60, decay: 1.0, type: 'sine', vol: 0.8});
                        if (beat % 16 === 8) sys.playSnare(time, {tone: 400, noise: 2000, decay: 0.15, vol: 0.4});
                        if (beat % 2 === 0) {
                             if (beat === 28 || beat === 30) {
                                 sys.playHiHat(time, {freq: 8000, decay: 0.02, vol: 0.2});
                                 sys.playHiHat(time + 0.06, {freq: 8000, decay: 0.02, vol: 0.15});
                                 sys.playHiHat(time + 0.12, {freq: 8000, decay: 0.02, vol: 0.1});
                             } else {
                                 sys.playHiHat(time, {freq: 8000, decay: 0.05, vol: 0.25});
                             }
                        }
                        if (beat === 0) sys.playChord(time, [261.6, 311.1, 392.0], 'sine', 400, 0.05);
                        if (beat === 16) sys.playChord(time, [233.0, 277.1, 349.2], 'sine', 400, 0.05);
                    }
                }
            ];

            if (playerData.currentTrackIndex !== undefined) {
                this.currentTrackIndex = playerData.currentTrackIndex;
                if(this.currentTrackIndex >= this.tracks.length) this.currentTrackIndex = 0;
            }
            this.startMusic();
        },

        toggleMute: function() {
            this.isMuted = !this.isMuted;
            if(this.ctx) {
                if(this.isMuted) this.ctx.suspend();
                else this.ctx.resume();
            }
            return this.isMuted;
        },

        changeTrack: function(direction) {
            this.currentTrackIndex += direction;
            if (this.currentTrackIndex >= this.tracks.length) this.currentTrackIndex = 0;
            if (this.currentTrackIndex < 0) this.currentTrackIndex = this.tracks.length - 1;

            playerData.currentTrackIndex = this.currentTrackIndex;
            saveData();
            showNotification("üéµ " + this.tracks[this.currentTrackIndex].name, 0);
        },

        createOscillator: function(type, freq, start, dur, vol) {
            if (!this.ctx || this.isMuted) return;
            const t = this.ctx.currentTime + (start || 0);
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, t);
            gain.gain.setValueAtTime(vol, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + dur);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(t);
            osc.stop(t + dur);
            return { osc, gain };
        },

        playTone: function(time, freq, type, dur) {
            this.createOscillator(type, freq, 0, dur, 0.1);
        },

        playSwish: function() {
            if (!this.ctx || this.isMuted) return;
            const t = this.ctx.currentTime;
            const dur = 0.4;
            const bufferSize = this.ctx.sampleRate * dur;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;

            const filter = this.ctx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.Q.value = 1;
            filter.frequency.setValueAtTime(800, t);
            filter.frequency.linearRampToValueAtTime(300, t + dur);

            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0.2, t);
            gain.gain.linearRampToValueAtTime(0, t + dur);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start(t);
        },

        playBrick: function() {
            if (!this.ctx || this.isMuted) return;
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'square';
            osc.frequency.setValueAtTime(250, t);
            osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
            gain.gain.setValueAtTime(0.1, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(t);
            osc.stop(t + 0.1);
        },

        playFloorHit: function() {
            if (!this.ctx || this.isMuted) return;
            this.createOscillator('triangle', 80, 0, 0.1, 0.2);
        },

        playWindowBreak: function() {
            if (!this.ctx || this.isMuted) return;
            const t = this.ctx.currentTime;
            const dur = 0.6;
            const bufferSize = this.ctx.sampleRate * dur;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);

            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;

            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = 2000;

            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0.3, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + dur);

            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start(t);

            for(let i=0; i<5; i++) {
                setTimeout(() => {
                    if(this.ctx && !this.isMuted) this.createOscillator('sine', 2000 + Math.random()*3000, 0, 0.1, 0.05);
                }, Math.random() * 200);
            }
        },

        playKick: function(time, opts={}) {
            if(!this.ctx || this.isMuted) return;
            const freq = opts.freq || 150;
            const decay = opts.decay || 0.5;
            const type = opts.type || 'sine';
            const vol = opts.vol || 0.4;

            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + decay);
            gain.gain.setValueAtTime(vol, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + decay);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start(time);
            osc.stop(time + decay);
        },

        playSnare: function(time, opts={}) {
            if(!this.ctx || this.isMuted) return;
            const toneFreq = opts.tone || 250;
            const noiseFilter = opts.noise || 1000;
            const decay = opts.decay || 0.1;
            const vol = opts.vol || 0.15;
            const type = opts.type || 'triangle';

            if (type !== 'noise_only') {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(toneFreq, time);
                gain.gain.setValueAtTime(vol, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + decay);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start(time);
                osc.stop(time + decay);
            }

            const dur = decay * 2;
            const bufferSize = this.ctx.sampleRate * dur;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const nGain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = noiseFilter;
            nGain.gain.setValueAtTime(vol, time);
            nGain.gain.exponentialRampToValueAtTime(0.01, time + dur);
            noise.connect(filter);
            filter.connect(nGain);
            nGain.connect(this.ctx.destination);
            noise.start(time);
        },

        playHiHat: function(time, opts={}) {
            if(!this.ctx || this.isMuted) return;
            const freq = opts.freq || 7000;
            const decay = opts.decay || 0.05;
            const vol = opts.vol || 0.1;

            const dur = decay;
            const bufferSize = this.ctx.sampleRate * dur;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = this.ctx.createBufferSource();
            noise.buffer = buffer;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass';
            filter.frequency.value = freq;
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(vol, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + dur);
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(this.ctx.destination);
            noise.start(time);
        },

        playChord: function(time, notes, type='triangle', filterFreq=800, vol=0.04) {
            if(!this.ctx || this.isMuted) return;
            notes.forEach((freq, i) => {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.value = freq;

                if (type === 'triangle') {
                    const lfo = this.ctx.createOscillator();
                    const lfoGain = this.ctx.createGain();
                    lfo.frequency.value = 2 + Math.random();
                    lfoGain.gain.value = 1.5;
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    lfo.start(time);
                    lfo.stop(time + 2.0);
                }

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = filterFreq;

                gain.gain.setValueAtTime(vol, time);
                gain.gain.linearRampToValueAtTime(vol * 1.5, time + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 2.0);

                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);

                osc.start(time);
                osc.stop(time + 2.0);
            });
        },

        scheduler: function() {
            if (!this.tracks || this.tracks.length === 0) return;
            const track = this.tracks[this.currentTrackIndex] || this.tracks[0];
            const beatInterval = track.tempo;

            while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
                this.scheduleNote(this.beatCount, this.nextNoteTime);
                this.nextNoteTime += beatInterval;
                this.beatCount++;
                if(this.beatCount >= 32) this.beatCount = 0;
            }
            this.timerID = window.setTimeout(this.scheduler.bind(this), this.lookahead);
        },

        scheduleNote: function(beatNumber, time) {
            const track = this.tracks[this.currentTrackIndex] || this.tracks[0];
            if(track.schedule) track.schedule(beatNumber, time, this);
        },

        startMusic: function() {
            if(this.isPlayingMusic) return;
            if(!this.ctx) return;
            this.isPlayingMusic = true;
            this.nextNoteTime = this.ctx.currentTime + 0.1;
            this.scheduler();
        },

        stopMusic: function() {
            this.isPlayingMusic = false;
            window.clearTimeout(this.timerID);
        }
    };

    // --- 2. GLOBAL VARIABLES ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Optimization: Pre-calculated Sun Gradient
    const sunGradient = ctx.createRadialGradient(700, 80, 0, 700, 80, 80);
    sunGradient.addColorStop(0, '#FFD700');
    sunGradient.addColorStop(0.5, '#FFD700'); // Solid core (r=40)
    sunGradient.addColorStop(0.6, 'rgba(255, 165, 0, 0.5)'); // Glow start
    sunGradient.addColorStop(1, 'rgba(255, 165, 0, 0)'); // Fade out

    const scoreEl = document.getElementById('scoreVal');
    const shopUI = document.getElementById('shopUI');
    const achUI = document.getElementById('achUI');
    const statsUI = document.getElementById('statsUI');
    const notif = document.getElementById('notification');
    const courtNameEl = document.getElementById('courtNameDisplay');
    const missValEl = document.getElementById('missVal');
    const container = document.getElementById('game-container');
    const contestUI = document.getElementById('contest-ui');
const contestTimeEl = document.getElementById('contestTime');
const contestScoreEl = document.getElementById('contestScore');
const contestRackEl = document.getElementById('contestRack');

    canvas.width = 1066;
    canvas.height = 600;

    let viewingAnimalIndex = 0;
    let viewingSkinIndex = 0;
    let viewingStyleIndex = 0;
    let currentGameMode = 'CLASSIC';
    let contestData = { timer: 60, score: 0, rack: 1, ballsInRack: 0, isActive: false };
let lastDisplayedContestTime = -1;
    let distanceLevel = 1;
    var state = 'IDLE';
    let feedback = "";
    let feedbackTimer = 0;
    let crowdCheerTimer = 0;
    let consecutiveMisses = 0;
    var currentStreak = 0;
    let spacePressed = false;
    let cameraZoom = 800;
    let cameraHeight = 300;
    let g_camCache = null; // Optimization: Per-frame camera cache
    let resetStage = 0;
    let isGroundedShot = false;
    let groundShotTimer = 0;
    let airbudJumpTime = 0;

    // Physique
    const GRAVITY = 0.5;
    const DEBUG = false;
    // Shift player start position to match new center (300 -> 433)
    var player3D = { x: 433, y: 300, z: 0, vz: 0 };
    var ball = { x: 0, y: 0, z: 0, vx: 0, vy: 0, vz: 0, active: false, isFire: false, trail: [], rotationX: 0 };
    var activeBalls = [];
    var timeAttackData = { timer: 60, score: 0, highScore: 0, active: false };
    var particles = [];

    // Expose for debugging
    if (DEBUG) {
        window.player3D = player3D;
        window.state = state;
    }

    const defaultData = {
        tacos: 0, level: 1, difficulty: 1.0, highScore: 10,
        stats: { income: 1, aim: 1, luck: 1, moonwalk: 1, extraLives: 0 },
        purchasedStats: { income: 1, aim: 1, luck: 1, moonwalk: 1, extraLives: 0 },
        lifetimeStats: { shots: 0, makes: 0, misses: 0, contests: 0 },
        dailyChallenge: { date: '', id: '', progress: 0, claimed: false },
        unlockedSkins: ['human_anchor', 'rat_classic'], currentSkin: 'human_anchor', unlockedAchievements: [],
        unlockedStyles: ['classic'], currentStyle: 'classic', isLefty: false,
        mobileControls: false, platformChosen: false,
        meterEnabled: true, meterShape: 'arc', meterScale: 1.0,
        releaseTiming: 3, // 0: Jump, 1: Setpoint, 2: Push, 3: Release (Default)
        graphics: 'HIGH', // 'HIGH' or 'LOW'
        currentTrackIndex: 0
    };

    let savedData = localStorage.getItem('tacoSaveData');
    let playerData = savedData ? JSON.parse(savedData) : JSON.parse(JSON.stringify(defaultData));

    // Migration logic to fix old saves
    if(!playerData.unlockedAchievements) playerData.unlockedAchievements = [];
    if(!playerData.stats.income) playerData.stats.income = 1;
    if(!playerData.stats.moonwalk) playerData.stats.moonwalk = 1;
    if(typeof playerData.stats.extraLives === 'undefined') playerData.stats.extraLives = 0;
    if(!playerData.lifetimeStats) playerData.lifetimeStats = { shots: 0, makes: 0, misses: 0, contests: 0 };
    if(!playerData.unlockedSkins) playerData.unlockedSkins = ['rat_classic'];
    if(!playerData.currentSkin) playerData.currentSkin = 'rat_classic';
    if(!playerData.unlockedStyles) playerData.unlockedStyles = ['classic'];
    if(!playerData.currentStyle) playerData.currentStyle = 'classic';
    if(typeof playerData.isLefty === 'undefined') playerData.isLefty = false;
    if(typeof playerData.platformChosen === 'undefined') playerData.platformChosen = false;
    if(!playerData.dailyChallenge) playerData.dailyChallenge = { date: '', id: '', progress: 0, claimed: false };
    if(typeof playerData.meterEnabled === 'undefined') playerData.meterEnabled = true;
    if(typeof playerData.meterShape === 'undefined') playerData.meterShape = 'arc';
    if(typeof playerData.releaseTiming === 'undefined') playerData.releaseTiming = 3;
    if(typeof playerData.graphics === 'undefined') playerData.graphics = 'HIGH';
    if(typeof playerData.currentTrackIndex === 'undefined') playerData.currentTrackIndex = 0;

    // Migration: purchasedStats
    if (!playerData.purchasedStats) {
        playerData.purchasedStats = {
            income: playerData.stats.income || 1,
            aim: playerData.stats.aim || 1,
            luck: playerData.stats.luck || 1,
            moonwalk: playerData.stats.moonwalk || 1,
            extraLives: (typeof playerData.stats.extraLives !== 'undefined') ? playerData.stats.extraLives : 0
        };
    }

    // Don't auto-set mobileControls here anymore, wait for choice if not chosen
    window.playerData = playerData;

    // Initialize Daily Challenge
    initDailyChallenge();

    // --- 3. HELPER FUNCTIONS ---
    function saveData() { localStorage.setItem('tacoSaveData', JSON.stringify(playerData)); }

    function initDailyChallenge() {
        const today = new Date().toDateString();
        // Reset if date changed or if data is missing/corrupt
        if (playerData.dailyChallenge.date !== today || !playerData.dailyChallenge.id) {
            const randomIndex = Math.floor(Math.random() * DAILY_CHALLENGES.length);
            const challenge = DAILY_CHALLENGES[randomIndex];
            playerData.dailyChallenge = {
                date: today,
                id: challenge.id,
                progress: 0,
                claimed: false
            };
            saveData();
        }
    }

    function checkDailyProgress(type, amount) {
        const dc = playerData.dailyChallenge;
        if (dc.claimed) return;

        const challengeDef = DAILY_CHALLENGES.find(c => c.id === dc.id);
        if (!challengeDef) return;

        // If the active challenge type matches the event
        if (challengeDef.type === type) {
            if (type === 'streak') {
                // Streak is "reach X", not cumulative
                if (amount >= challengeDef.target) {
                    completeDailyChallenge(challengeDef);
                }
            } else {
                // Cumulative
                dc.progress += amount;
                if (dc.progress >= challengeDef.target) {
                    dc.progress = challengeDef.target;
                    completeDailyChallenge(challengeDef);
                } else {
                    saveData();
                }
            }
        }
    }

    function completeDailyChallenge(def) {
        if(playerData.dailyChallenge.claimed) return;
        playerData.dailyChallenge.claimed = true;
        playerData.tacos += def.reward;
        saveData();
        showNotification("D√âFI COMPL√âT√â !", def.reward);
        // Visual flair could go here
    }

    function calculateShotThreshold() {
        const style = getCurrentStyle();
        const mods = style.modifiers;

        let aimBonus = (playerData.stats.aim - 1);
        let baseDampener = 6.0;
        if (currentGameMode === 'CONTEST') { aimBonus *= 0.2; baseDampener = 4.5; }
        if (currentGameMode === 'TIME_ATTACK') { aimBonus = 0; }
        let dampener = baseDampener + aimBonus;

        if(mods.timingWindow) dampener *= mods.timingWindow;

        // Note: We do NOT apply the 1.2x 'no-meter' bonus here.
        // This function returns the standard physical threshold (meter visible difficulty).
        // The shooter function applies the bonus on top if the meter is actually disabled.

        if (dampener > 36.0) dampener = 36.0;

        const distPenalty = 1.0 + Math.pow(distanceLevel, 1.25) * 0.06;
        let finalDistPenalty = distPenalty;
        if(mods.rangeBonus) finalDistPenalty = 1.0 + (distPenalty - 1.0) * (1.0 - mods.rangeBonus);

        // accuracy = (timingError / dampener) * difficulty * finalDistPenalty
        // success condition: |accuracy| <= 0.25
        // |timingError| <= 0.25 * dampener / (difficulty * finalDistPenalty)

        return (0.25 * dampener) / (playerData.difficulty * finalDistPenalty);
    }

    function getStreakFireHue(streak) {
        // Map streak 10->100 to Hue 30 (Orange) -> 200 (Blue)
        const s = Math.max(10, Math.min(100, streak));
        const t = (s - 10) / 90;
        return 30 + (t * 170);
    }

    function getCurrentVz() {
        if (isGroundedShot) {
            return 9 - (groundShotTimer * 0.5);
        }
        return player3D.vz;
    }

    function getReleaseTargetVz(maxVz) {
        // 0: Jump (Early) -> 40% of max velocity left
        // 1: Setpoint (Mid) -> 25%
        // 2: Push (Late-Mid) -> 10%
        // 3: Release (Apex) -> 0%
        const timing = (playerData.releaseTiming !== undefined) ? playerData.releaseTiming : 3;
        if (timing === 0) return maxVz * 0.40;
        if (timing === 1) return maxVz * 0.25;
        if (timing === 2) return maxVz * 0.10;
        return 0;
    }

    function drawShotMeter(cx, cy, radius, s, progress, greenStart, shape, greenEnd) {
        if (greenEnd === undefined) greenEnd = 1.0;
        ctx.lineCap = 'round';
        let color = '#FF4500';
        if (progress >= greenStart && progress <= greenEnd) color = '#00FF00';
        else if (progress > 0.6) color = '#FFFF00';

        if (shape === 'vertical') {
            const h = radius * 3;
            const w = 15 * s;
            const x = cx + radius;
            const y = cy - h/2;
            ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = w; ctx.moveTo(x, y + h); ctx.lineTo(x, y); ctx.stroke();
            ctx.beginPath(); ctx.strokeStyle = 'rgba(0,255,0,0.4)'; ctx.lineWidth = w;
            ctx.moveTo(x, y + h * (1-greenStart)); ctx.lineTo(x, y + h * (1-greenEnd)); ctx.stroke();
            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = w * 0.8; ctx.moveTo(x, y + h); ctx.lineTo(x, y + h * (1-progress)); ctx.stroke();
        }
        else if (shape === 'horizontal') {
            const w = radius * 3;
            const h = 15 * s;
            const x = cx - w/2;
            const y = cy + radius;
            ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = h; ctx.moveTo(x, y); ctx.lineTo(x + w, y); ctx.stroke();
            ctx.beginPath(); ctx.strokeStyle = 'rgba(0,255,0,0.4)'; ctx.lineWidth = h;
            ctx.moveTo(x + w * greenStart, y); ctx.lineTo(x + w * greenEnd, y); ctx.stroke();
            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = h * 0.8; ctx.moveTo(x, y); ctx.lineTo(x + w * progress, y); ctx.stroke();
        }
        else if (shape === 'orb') {
            ctx.lineWidth = 6 * s;
            ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.strokeStyle = 'rgba(0,255,0,0.3)';
            ctx.arc(cx, cy, radius, -Math.PI/2 + (Math.PI*2*greenStart), -Math.PI/2 + (Math.PI*2*greenEnd), false); ctx.stroke();
            ctx.beginPath(); ctx.strokeStyle = color; ctx.arc(cx, cy, radius, -Math.PI/2, -Math.PI/2 + (Math.PI*2*progress), false); ctx.stroke();
        }
        else if (shape === 'triangle') {
            const h = radius * 2.5; const w = radius * 2;
            const x = cx + radius * 1.5; const y = cy + h/2;
            ctx.fillStyle='rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x+w/2, y-h); ctx.lineTo(x-w/2, y-h); ctx.fill();
            const fh = h * progress; const fw = w * progress;
            ctx.fillStyle = color; ctx.beginPath();
            ctx.moveTo(x, y); ctx.lineTo(x + fw/2, y - fh); ctx.lineTo(x - fw/2, y - fh); ctx.fill();
            // Band
            const gy1 = y - h * greenStart;
            const gy2 = y - h * greenEnd;
            ctx.fillStyle = 'rgba(0,255,0,0.5)'; ctx.beginPath();
            // Trapezoid logic? Triangle width at height h is w * (h/totalH).
            const w1 = w * greenStart; const w2 = w * greenEnd;
            ctx.moveTo(x - w1/2, gy1); ctx.lineTo(x + w1/2, gy1);
            ctx.lineTo(x + w2/2, gy2); ctx.lineTo(x - w2/2, gy2);
            ctx.fill();
        }
        else if (shape === 'diamond') {
            const size = radius * 1.2;
            const x = cx + size * 1.5; const y = cy;
            ctx.save(); ctx.translate(x, y); ctx.rotate(Math.PI/4);
            ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.fillRect(-size, -size, size*2, size*2);
            ctx.fillStyle = color;
            const s2 = size * progress;
            ctx.fillRect(-s2, -s2, s2*2, s2*2);
            const mid = size * ((greenStart + greenEnd)/2);
            const thick = Math.max(2, size * (greenEnd - greenStart));
            ctx.strokeStyle = 'rgba(0,255,0,0.5)'; ctx.lineWidth=thick; ctx.strokeRect(-mid, -mid, mid*2, mid*2);
            ctx.restore();
        }
        else if (shape === 'ring') {
            ctx.lineWidth = 8 * s;
            ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.strokeStyle = color;
            ctx.arc(cx, cy, radius, -Math.PI/2, -Math.PI/2 + (Math.PI*2*progress), false); ctx.stroke();
            const a1 = -Math.PI/2 + (Math.PI*2*greenStart);
            const a2 = -Math.PI/2 + (Math.PI*2*greenEnd);
            ctx.beginPath(); ctx.strokeStyle = '#00FF00'; ctx.lineWidth=4*s;
            ctx.arc(cx, cy, radius*1.2, a1, a2); ctx.stroke();
        }
        else if (shape === 'chevron') {
            const w = radius * 2; const h = radius * 0.8;
            const x = cx + radius; const y = cy + radius;
            const gap = 5*s;
            const count = 5;
            for(let i=0; i<count; i++) {
                const pct = (i+1)/count;
                const py = y - (i * (h+gap));
                ctx.fillStyle = (progress >= pct) ? color : 'rgba(255,255,255,0.2)';
                const mid = (i+0.5)/count;
                if (mid >= greenStart && mid <= greenEnd) ctx.fillStyle = 'rgba(0,255,0,0.5)';
                ctx.beginPath();
                ctx.moveTo(x, py); ctx.lineTo(x + w/2, py - h); ctx.lineTo(x, py - h*0.5); ctx.lineTo(x - w/2, py - h);
                ctx.fill();
            }
        }
        else {
            ctx.beginPath(); ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 10*s;
            ctx.arc(cx, cy, radius, 0, -Math.PI / 2, true); ctx.stroke();
            ctx.beginPath(); ctx.strokeStyle = 'rgba(0,255,0,0.4)'; ctx.lineWidth = 10*s;
            ctx.arc(cx, cy, radius, -Math.PI/2 * Math.max(0, greenStart), -Math.PI/2 * greenEnd, true); ctx.stroke();
            ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 8*s;
            ctx.arc(cx, cy, radius, 0, -Math.PI/2 * progress, true); ctx.stroke();
        }
    }

    let _lastScaleDist = -1;
    let _lastScaleObj = null;
    function getScaleObject(dist) {
        if (dist === _lastScaleDist) return _lastScaleObj;
        _lastScaleDist = dist;
        _lastScaleObj = SCALE_OBJECTS.find(o => dist < o.limit) || SCALE_OBJECTS[SCALE_OBJECTS.length-1];
        return _lastScaleObj;
    }

    let _lastCourtDist = -1;
    let _lastCourtObj = null;
    function getCourtDetails(dist) {
        if (dist === _lastCourtDist) return _lastCourtObj;
        _lastCourtDist = dist;
        _lastCourtObj = COURT_ZONES.find(z => dist < z.limit) || COURT_ZONES[COURT_ZONES.length-1];
        return _lastCourtObj;
    }

    function getJoint(x, y, length, angle) { return { x: x + Math.cos(angle) * length, y: y + Math.sin(angle) * length }; }
    function invalidateBackgroundCache() {
        bgCache = null;
        if(mountainLayers) mountainLayers.forEach(l => l.gradient = null);
    }

    function resizeGame() {
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        // Target 16:9 ratio (1066x600)
        // If we want NO gap, we should cover. But "filling up" often implies "contain" without bars if ratio matches.
        // The user said "16:9 equivalent ... no distortion ... filling up screen".
        // Since most phones are wider than 16:9, we should stick to CONTAIN logic (Math.min) to ensure everything is visible.
        // However, removing the 0.95 margin (done previously) is key.
        const scale = Math.min(winW / 1066, winH / 600);
        container.style.transform = `translate(-50%, -50%) scale(${scale})`;
        invalidateBackgroundCache();
    }
    window.addEventListener('resize', resizeGame);

    function project(x, y, z, cache) {
        let rotation, sinRot, cosRot;

        if (cache) {
            rotation = cache.rotation;
            sinRot = cache.sinRot;
            cosRot = cache.cosRot;
            cameraZoom = cache.cameraZoom;
            cameraHeight = cache.cameraHeight;
        } else if (g_camCache) {
            rotation = g_camCache.rotation;
            sinRot = g_camCache.sinRot;
            cosRot = g_camCache.cosRot;
            cameraZoom = g_camCache.cameraZoom;
            cameraHeight = g_camCache.cameraHeight;
        } else {
            const dxToHoop = HOOP_POS.x - player3D.x;
            const dyToHoop = HOOP_POS.y - player3D.y;
            cameraZoom = 698;
            cameraHeight = 84000 / cameraZoom;
            const angleToHoop = Math.atan2(dyToHoop, dxToHoop);
            rotation = -angleToHoop - Math.PI/2;
            sinRot = Math.sin(rotation);
            cosRot = Math.cos(rotation);
        }

        const dx = x - player3D.x; const dy = y - player3D.y;
        const rx = dx * cosRot - dy * sinRot;
        const ry = dx * sinRot + dy * cosRot;
        const cameraOffset = 400; const depth = cameraOffset - ry;
        if (depth <= 0) return null;
        const scale = cameraZoom / depth;
        const screenX = canvas.width / 2 + (rx * scale);
        const horizonY = (canvas.height - 120) * 0.5;
        const screenY = horizonY + (cameraHeight - z) * scale;
        return { x: screenX, y: screenY, scale: scale, depth: depth };
    }

    // --- 4. DRAWING FUNCTIONS ---
    // Weather System
    class WeatherSystem {
        constructor() {
            this.particles = [];
            this.type = 'NONE'; // 'NONE', 'RAIN', 'SNOW'
            this.intensity = 0;
        }

        update(dt) {
            // Determine weather type based on court zone
            if (playerData.graphics === 'LOW') { this.type = 'NONE'; this.particles = []; return; }

            const dist = 10 + (distanceLevel * 5);
            const court = getCourtDetails(dist);

            // Logic for weather type
            let targetType = 'NONE';
            if (court.name.includes("PATINOIRE") || court.name.includes("MONT") || court.name.includes("ANTARCTIQUE") || court.name.includes("BOR√âALE")) {
                targetType = 'SNOW';
            } else if (court.name.includes("FLEUVE") || court.name.includes("PLUIE")) {
                targetType = 'RAIN';
            }

            // Space levels have stars instead (handled in background)
            if (court.type === 'space') targetType = 'NONE';

            this.type = targetType;

            if (this.type === 'NONE') { this.particles = []; return; }

            // Spawn Particles
            const spawnRate = (this.type === 'RAIN') ? 2 : 0.5;
            if (Math.random() < spawnRate * dt) {
                for(let i=0; i<3; i++) {
                    this.particles.push({
                        x: (Math.random() - 0.5) * 3000 + player3D.x,
                        y: (Math.random() - 0.5) * 3000 + player3D.y,
                        z: 1000 + Math.random() * 500,
                        vx: (this.type === 'RAIN') ? 20 : 5,
                        vy: (this.type === 'RAIN') ? 10 : 2,
                        vz: (this.type === 'RAIN') ? -150 : -30,
                        life: 100
                    });
                }
            }

            // Update Particles
            for (let i = this.particles.length - 1; i >= 0; i--) {
                let p = this.particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.z += p.vz * dt;

                // Ground collision
                if (p.z <= 0) {
                    p.z = 0;
                    this.particles[i] = this.particles[this.particles.length - 1];
                    this.particles.pop();
                    continue;
                }

                // Cull far
                if (p.z < 0 || Math.abs(p.x - player3D.x) > 2000) {
                    this.particles[i] = this.particles[this.particles.length - 1];
                    this.particles.pop();
                }
            }
        }

        draw(projFunc) {
            if (this.type === 'NONE' || playerData.graphics === 'LOW') return;

            ctx.lineWidth = (this.type === 'RAIN') ? 2 : 0;
            ctx.fillStyle = '#FFF';
            ctx.strokeStyle = 'rgba(180, 200, 255, 0.6)';

            for (let p of this.particles) {
                // Optimization: Simple 3D projection inline or use cache?
                // Weather particles are many, let's use the provided projFunc or simplified version.
                // We reuse the global project function but need to be careful about performance.
                const proj = projFunc(p.x, p.y, p.z, g_camCache);
                if (!proj) continue;

                if (this.type === 'RAIN') {
                    // Draw line for streak
                    const proj2 = projFunc(p.x - p.vx*2, p.y - p.vy*2, p.z - p.vz*2, g_camCache);
                    if (proj2) {
                        ctx.beginPath();
                        ctx.moveTo(proj.x, proj.y);
                        ctx.lineTo(proj2.x, proj2.y);
                        ctx.stroke();
                    }
                } else if (this.type === 'SNOW') {
                    const s = proj.scale;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 4 * s, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }
    }

    const weather = new WeatherSystem();

    function drawBroadcastLowerThird() {
        const h = 120;
        const y = canvas.height - h;

        // 1. Background Bar (Glossy Dark)
        const bgGrad = ctx.createLinearGradient(0, y, 0, canvas.height);
        bgGrad.addColorStop(0, '#2a2a2a');
        bgGrad.addColorStop(0.5, '#151515');
        bgGrad.addColorStop(1, '#0a0a0a');
        ctx.fillStyle = bgGrad;
        ctx.fillRect(0, y, canvas.width, h);

        // Top Border (Gold)
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(0, y, canvas.width, 4);

        // 2. Content Logic
        const dist = 10 + (distanceLevel * 5);
        const scaleObj = getScaleObject(dist);

        // Fonts (using Canvas fonts that match CSS imports)
        const fontTitle = "bold 14px 'Roboto Condensed', 'Arial Narrow', sans-serif";
        const fontValue = "bold 36px 'Russo One', 'Impact', sans-serif";
        const fontIcon = "50px Arial";

        // Center Separator
        ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(canvas.width / 2, y + 20); ctx.lineTo(canvas.width / 2, canvas.height - 20); ctx.stroke();

        if (currentGameMode === 'CLASSIC') {
            // LEFT SIDE: Record & Current Distance
            // Record
            ctx.textAlign = "right";
            ctx.fillStyle = "#aaa"; ctx.font = fontTitle;
            ctx.fillText("RECORD", canvas.width / 2 - 250, y + 45);
            ctx.fillStyle = "#FFD700"; ctx.font = fontValue;
            ctx.fillText(playerData.highScore + " ft", canvas.width / 2 - 250, y + 85);

            // Current Distance
            ctx.textAlign = "right";
            ctx.fillStyle = "#aaa"; ctx.font = fontTitle;
            ctx.fillText("CURRENT DISTANCE", canvas.width / 2 - 25, y + 45);
            ctx.fillStyle = "#fff"; ctx.font = fontValue;
            ctx.fillText(dist + " ft", canvas.width / 2 - 25, y + 85);

            // RIGHT SIDE: Comparison
            ctx.textAlign = "left";
            ctx.fillStyle = "#aaa"; ctx.font = fontTitle;
            ctx.fillText("SCALE EQUIVALENT", canvas.width / 2 + 25, y + 45);

            // Icon
            ctx.textAlign = "center"; ctx.font = fontIcon;
            const iconX = canvas.width / 2 + 65;
            ctx.fillText(scaleObj.icon, iconX, y + 90);

            // Name
            ctx.textAlign = "left";
            ctx.fillStyle = "#FFD700"; // Gold
            ctx.font = "bold 24px 'Roboto Condensed', sans-serif";
            ctx.fillText(scaleObj.name.toUpperCase(), iconX + 40, y + 85);
        }
        else if (currentGameMode === 'CONTEST') {
            // Contest Stats
            ctx.textAlign = "center";
            ctx.fillStyle = "#FFD700"; ctx.font = fontValue;
            ctx.fillText("3-POINT CONTEST", canvas.width / 2, y + 75);
            ctx.fillStyle = "#aaa"; ctx.font = fontTitle;
            ctx.fillText("QUEBEC EDITION", canvas.width / 2, y + 40);
        }
        else if (currentGameMode === 'TIME_ATTACK') {
            // Time Attack Stats
            ctx.textAlign = "center";
            ctx.fillStyle = "#FF4500"; ctx.font = fontValue;
            ctx.fillText("TIME ATTACK MODE", canvas.width / 2, y + 75);
            ctx.fillStyle = "#aaa"; ctx.font = fontTitle;
            ctx.fillText("SCORE AS FAST AS YOU CAN", canvas.width / 2, y + 40);
        }

        // Live Indicator
        ctx.fillStyle = "#D32F2F"; ctx.fillRect(20, y + 20, 8, 8);
        ctx.fillStyle = "#fff"; ctx.font = "bold 10px sans-serif"; ctx.textAlign = "left";
        ctx.fillText("LIVE", 35, y + 28);
    }

    function drawBallSprite(x, y, scale, isFire = false, rotation = 0) {
        let color1 = '#ff6600'; let color2 = '#cc5500';
        let key = 'ball_default';

        if(currentGameMode === 'CONTEST' && contestData.ballsInRack === 4) {
            color1 = '#FFFFFF'; color2 = '#0000FF'; key = 'ball_money';
        } else if (isFire) {
            color1 = '#FFFF00'; color2 = '#FF0000'; key = 'ball_fire';
        }

        // Bloom Effect (High Graphics)
        if (isFire && playerData.graphics === 'HIGH') {
            ctx.shadowColor = '#FF4500';
            ctx.shadowBlur = 20 * scale;
        }

        const fillStyle = getCachedPattern(key, (gradCtx, size) => {
            const r = size / 2;
            const grad = gradCtx.createRadialGradient(r*0.8, r*0.8, 1, r, r, r);
            grad.addColorStop(0, color1);
            grad.addColorStop(1, color2);
            gradCtx.fillStyle = grad;
            gradCtx.fillRect(0, 0, size, size);
        });

        ctx.fillStyle = fillStyle;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1 * scale;

        // Base Circle
        ctx.beginPath(); ctx.arc(x, y, 8 * scale, 0, Math.PI*2); ctx.fill(); ctx.stroke();

        // Setup Lines
        ctx.save();
        ctx.beginPath(); ctx.arc(x, y, 8 * scale, 0, Math.PI*2); ctx.clip(); // Clip lines to ball

        if(currentGameMode === 'CONTEST' && contestData.ballsInRack === 4) { ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 2 * scale; }
        else if (isFire) { ctx.strokeStyle = '#FFFF00'; ctx.lineWidth = 2 * scale; }
        else { ctx.strokeStyle = 'rgba(0,0,0,0.6)'; ctx.lineWidth = 1.5 * scale; }

        // Draw Rotated Geometry
        const radius = 8 * scale;
        const cosR = Math.cos(rotation);
        const sinR = Math.sin(rotation);

        if (g_ballGeo && g_ballGeo.length > 0) {
            g_ballGeo.forEach(path => {
                ctx.beginPath();
                for(let i=0; i<path.length; i++) {
                    const p = path[i];
                    // Rotate around X-axis (Backspin: Texture moves Down)
                    // y' = y*cos - z*sin
                    // z' = y*sin + z*cos
                    // We render (x, y')

                    const ry = p.y * cosR - p.z * sinR;
                    // For z-depth cull (optional, not strictly needed for wireframe on sphere)
                    // const rz = p.y * sinR + p.z * cosR;

                    const px = x + p.x * radius;
                    const py = y + ry * radius;

                    if (i===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            });
        }

        ctx.restore();
        ctx.shadowBlur = 0; // Reset
    }

    function drawBall(p, ballRef) {
        if (!p) return;
        const targetBall = ballRef || ball; // Fallback for safety

        // Draw Trail (High Graphics)
        if (targetBall.isFire && targetBall.trail && targetBall.trail.length > 1 && playerData.graphics === 'HIGH') {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            for (let i = 0; i < targetBall.trail.length - 1; i++) {
                const pt1 = targetBall.trail[i];
                const pt2 = targetBall.trail[i+1];

                // Project both points
                const proj1 = project(pt1.x, pt1.y, pt1.z, g_camCache);
                const proj2 = project(pt2.x, pt2.y, pt2.z, g_camCache);

                if (proj1 && proj2) {
                    const ratio = i / targetBall.trail.length; // 0 (oldest) to 1 (newest)
                    const alpha = ratio * 0.6;
                    ctx.lineWidth = (5 + 15 * ratio) * proj1.scale;

                    // Fire Gradient color
                    // Newest: Yellow/White, Middle: Orange, Oldest: Red/Trans
                    let r = 255;
                    let g = Math.floor(ratio * 200); // 0 to 200
                    let b = 0;
                    if(ratio > 0.8) { g = 255; b = Math.floor((ratio-0.8)*5 * 255); } // White hot tip

                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;

                    // Add glow to trail
                    ctx.shadowColor = `rgba(${r}, ${Math.floor(g/2)}, 0, 1)`;
                    ctx.shadowBlur = 10 * proj1.scale;

                    ctx.beginPath();
                    ctx.moveTo(proj1.x, proj1.y);
                    ctx.lineTo(proj2.x, proj2.y);
                    ctx.stroke();

                    ctx.shadowBlur = 0;
                }
            }
        }

        drawBallSprite(p.x, p.y, p.scale, targetBall.isFire, targetBall.rotationX);
    }

    function drawDetachedBall(p, s, torsoY, bodyH, headY) {
         try {
             const isDetachedStyle = ['airbud', 'telekinesis'].includes(playerData.currentStyle);
             if (isDetachedStyle && state !== 'SHOOTING' && state !== 'GAMEOVER') {
                 let bx = p.x;
                 let by = torsoY + bodyH * 0.5;

                 let lift = 0;
                 if (state === 'JUMPING') {
                     const sObj = getCurrentStyle();
                     const maxVz = (sObj.modifiers.jumpVelocity !== undefined) ? sObj.modifiers.jumpVelocity : 9;
                     const div = (maxVz < 1) ? 9 : maxVz;
                     lift = Math.min(1.0, Math.max(0, (div - getCurrentVz()) / div));
                 }

                 if (playerData.currentStyle === 'airbud') {
                     const startX = p.x + (playerData.isLefty ? -10*s : 10*s);
                     const startY = torsoY + bodyH * 0.5;
                     const endX = p.x;
                     const endY = headY - 80*s;

                     bx = startX + (endX - startX) * lift;
                     by = startY + (endY - startY) * lift;
                     // 135*s ensures a high lob that peaks ~160 units above the head, visually falling onto the nose
                     by -= Math.sin(lift * Math.PI) * 135 * s;
                 }
                 else if (playerData.currentStyle === 'telekinesis') {
                     const startY = torsoY + bodyH * 0.2;
                     const endY = headY - 45*s;
                     bx = p.x;
                     by = startY + (endY - startY) * lift;
                     if (lift > 0.8) {
                         bx += (Math.random() - 0.5) * 4 * s;
                         by += (Math.random() - 0.5) * 4 * s;
                     }
                 }

                 drawBallSprite(bx, by, s, (currentStreak >= 5), 0);
             }
         } catch(e) {
             console.error("Error drawing detached ball:", e);
         }
    }

    function drawSmoke(p, alpha, color) {
        const s = p.scale;
        ctx.fillStyle = color || `rgba(220, 220, 220, ${alpha * 0.6})`;
        ctx.beginPath(); ctx.arc(p.x, p.y, 15 * s, 0, Math.PI*2); ctx.fill();
    }

    // --- FUR & ANATOMY HELPERS ---
    function drawFuzzyPath(points, color, scale, close = true, seed = 1, justPath = false) {
        if(points.length < 2) return;
        ctx.beginPath();
        const fuzz = 3 * scale;

        for (let i = 0; i < points.length; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % points.length];
            if (!close && i === points.length - 1) break;

            const dist = Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
            const segments = Math.max(2, Math.floor(dist / (4 * scale)));

            if(i===0) ctx.moveTo(p1.x, p1.y);

            // Using LUT for performance optimization
            let idxX = (seed + i * 100) & (NOISE_LUT_SIZE - 1);
            let idxY = (seed + i * 100 + 5000) & (NOISE_LUT_SIZE - 1);

            for(let j=1; j<=segments; j++) {
                const t = j / segments;
                const tx = p1.x + (p2.x - p1.x) * t;
                const ty = p1.y + (p2.y - p1.y) * t;

                // Advance LUT indices
                idxX = (idxX + 1) & (NOISE_LUT_SIZE - 1);
                idxY = (idxY + 1) & (NOISE_LUT_SIZE - 1);

                const noiseX = (g_noiseLUT[idxX] - 0.5) * fuzz;
                const noiseY = (g_noiseLUT[idxY] - 0.5) * fuzz;
                ctx.lineTo(tx + noiseX, ty + noiseY);
            }
        }
        if(close) ctx.closePath();

        if (justPath) return;

        ctx.fillStyle = color;
        ctx.fill();
        // Add texture
        ctx.save();
        ctx.clip();
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.lineWidth = 1 * scale;
        const b = getBounds(points);
        const area = (b.maxX - b.minX) * (b.maxY - b.minY);
        const dens = Math.floor(area / (100 * scale * scale)); // Approximate density
        ctx.beginPath();

        const rangeX = b.maxX - b.minX;
        const rangeY = b.maxY - b.minY;

        // LUT indices for texture
        let lutIdx1 = (seed + 200) & (NOISE_LUT_SIZE - 1);
        let lutIdx2 = (seed + 300) & (NOISE_LUT_SIZE - 1);
        let lutIdx3 = (seed + 400) & (NOISE_LUT_SIZE - 1);

        for(let k=0; k<dens; k++) {
            const r1 = g_noiseLUT[lutIdx1];
            const r2 = g_noiseLUT[lutIdx2];

            // Prime steps to avoid sync
            lutIdx1 = (lutIdx1 + 13) & (NOISE_LUT_SIZE - 1);
            lutIdx2 = (lutIdx2 + 17) & (NOISE_LUT_SIZE - 1);

            const rx = b.minX + r1 * rangeX;
            const ry = b.minY + r2 * rangeY;

            ctx.moveTo(rx, ry);
            const r3 = g_noiseLUT[lutIdx3];
            lutIdx3 = (lutIdx3 + 19) & (NOISE_LUT_SIZE - 1);
            ctx.lineTo(rx + (r3-0.5)*5*scale, ry + 5*scale);
        }
        ctx.stroke();
        ctx.restore();
    }

    function getBounds(points) {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        points.forEach(p => { if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; });
        return {minX, minY, maxX, maxY};
    }

    // --- OPTIMIZATION: Render Pools ---
    const CIRCLE_SEGS = 16;
    const g_circlePoints = [];
    for(let i=0; i<CIRCLE_SEGS; i++) { g_circlePoints.push({x: 0, y: 0}); }

    const g_limbPoints = [{x:0,y:0}, {x:0,y:0}, {x:0,y:0}, {x:0,y:0}];

    const drawFuzzyCircle = (cx, cy, r, c, seed = 50, scale = 1.0, furry = true) => {
        if(!furry) { ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fillStyle = c; ctx.fill(); return; }

        for(let i=0; i<CIRCLE_SEGS; i++) {
            const a = (i/CIRCLE_SEGS)*Math.PI*2;
            const p = g_circlePoints[i];
            p.x = cx + Math.cos(a)*r;
            p.y = cy + Math.sin(a)*r;
        }
        drawFuzzyPath(g_circlePoints, c, scale, true, seed);
    };

    function drawFuzzyLimb(x1, y1, x2, y2, width, color, scale, isFurry, seed = 1) {
        if(!isFurry) {
            drawLimb(x1, y1, x2, y2, width, color);
            return;
        }
        // Construct polygon for limb
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const dx = Math.sin(angle) * (width / 2);
        const dy = Math.cos(angle) * (width / 2);

        // Use Pool
        const p1 = g_limbPoints[0]; p1.x = x1 - dx; p1.y = y1 + dy;
        const p2 = g_limbPoints[1]; p2.x = x2 - dx; p2.y = y2 + dy;
        const p3 = g_limbPoints[2]; p3.x = x2 + dx; p3.y = y2 - dy;
        const p4 = g_limbPoints[3]; p4.x = x1 + dx; p4.y = y1 - dy;

        drawFuzzyPath(g_limbPoints, color, scale, true, seed);

        // Add shadow gradient overlay for depth
        ctx.save();
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.lineTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y); ctx.closePath();
        ctx.clip();
        const grad = ctx.createLinearGradient(x1, y1, x2, y2);
        grad.addColorStop(0, 'rgba(0,0,0,0)'); grad.addColorStop(1, 'rgba(0,0,0,0.3)');
        ctx.fillStyle = grad; ctx.fill();
        ctx.restore();
    }

    function drawAnatomicBody(cx, topY, w, h, scale, color, isFurry, seed = 1, options = {}) {
        const waistScale = options.waistScale || 0.85;
        const roundness = options.roundness || 0;

        // Hourglass / Tapered shape
        const sW = w * 1.1;
        const hW = w * 1.0; // Hips
        const wW = w * waistScale; // Waist

        const shoulderY = topY;
        const waistY = topY + h * 0.55;
        const hipY = topY + h;

        let points = [];

        if (options.bodyShape === 'bear_new') {
             // "Big Tall Oval" - Human-like but fat
             const shoulderW = w * 1.1; // Wide square shoulders
             const bellyW = w * 1.45; // Fat belly
             const hipW = w * 1.25; // Rounded bottom
             const bellyY = topY + h * 0.55;
             const hipY_adj = hipY - h*0.05; // Slightly up to round bottom

             // Dense Points for Smoothness (Fuzzy & Poly fallback)
             points = [];
             // Top (Flat)
             points.push({x: cx - shoulderW/2, y: shoulderY});
             points.push({x: cx + shoulderW/2, y: shoulderY});

             // Right Curve (Shoulder -> Belly -> Hip)
             points.push({x: cx + shoulderW/2 + (bellyW - shoulderW)*0.25, y: shoulderY + (bellyY - shoulderY)*0.3});
             points.push({x: cx + shoulderW/2 + (bellyW - shoulderW)*0.7, y: shoulderY + (bellyY - shoulderY)*0.7});
             points.push({x: cx + bellyW/2, y: bellyY}); // Apex
             points.push({x: cx + bellyW/2 - (bellyW - hipW)*0.2, y: bellyY + (hipY_adj - bellyY)*0.5});
             points.push({x: cx + hipW/2, y: hipY_adj});

             // Bottom Round
             points.push({x: cx + hipW/4, y: hipY});
             points.push({x: cx - hipW/4, y: hipY});
             points.push({x: cx - hipW/2, y: hipY_adj});

             // Left Curve (Hip -> Belly -> Shoulder)
             points.push({x: cx - bellyW/2 + (bellyW - hipW)*0.2, y: bellyY + (hipY_adj - bellyY)*0.5});
             points.push({x: cx - bellyW/2, y: bellyY}); // Apex
             points.push({x: cx - shoulderW/2 - (bellyW - shoulderW)*0.7, y: shoulderY + (bellyY - shoulderY)*0.7});
             points.push({x: cx - shoulderW/2 - (bellyW - shoulderW)*0.25, y: shoulderY + (bellyY - shoulderY)*0.3});
        }
        else if (options.bodyShape === 'round') {
             // Pig/Cow Shape: Narrow shoulders, wide belly/hips (Pear / Triangle)
             const shoulderW = w * 0.6;
             const bellyW = w * 1.9;
             const hipW = w * 1.8;
             const bellyY = topY + h * 0.7;

             points = [
                 {x: cx - shoulderW/2, y: shoulderY}, // Top Left
                 {x: cx + shoulderW/2, y: shoulderY}, // Top Right
                 // Right Side (Sloping down to belly)
                 {x: cx + w*0.8, y: topY + h*0.3}, // Chest tuck
                 {x: cx + bellyW/2, y: bellyY},
                 {x: cx + hipW/2, y: hipY},
                 // Bottom
                 {x: cx - hipW/2, y: hipY},
                 // Left Side
                 {x: cx - bellyW/2, y: bellyY},
                 {x: cx - w*0.8, y: topY + h*0.3} // Chest tuck
             ];
        }
        else if (options.bodyShape === 'oval') {
             // Small Animal (Rat, Cat, etc.) - Simple Ovalish body
             const shoulderW = w * 0.9;
             const midW = w * 1.2;
             const hipW = w * 1.0;
             const midY = topY + h * 0.5;

             points = [
                 {x: cx - shoulderW/2, y: shoulderY},
                 {x: cx + shoulderW/2, y: shoulderY},
                 {x: cx + midW/2, y: midY},
                 {x: cx + hipW/2, y: hipY},
                 {x: cx - hipW/2, y: hipY},
                 {x: cx - midW/2, y: midY}
             ];
        }
        else if (options.bodyShape === 'athletic_animal') {
             // Dog, Wolf, Lion - V-Shape but softer than human
             points = [
                {x: cx - w*0.6, y: shoulderY},
                {x: cx + w*0.6, y: shoulderY},
                {x: cx + w*0.5, y: waistY},
                {x: cx + w*0.55, y: hipY},
                {x: cx - w*0.55, y: hipY},
                {x: cx - w*0.5, y: waistY}
            ];
        }
        else {
            // Default Humanoid (Hourglass/Trapezoid)
            points = [
                {x: cx - sW/2, y: shoulderY},     // 0: Top Left
                {x: cx + sW/2, y: shoulderY},     // 1: Top Right
                {x: cx + wW/2, y: waistY},        // 2: Waist Right
                {x: cx + hW/2, y: hipY},          // 3: Hip Right
                {x: cx - hW/2, y: hipY},          // 4: Hip Left
                {x: cx - wW/2, y: waistY}         // 5: Waist Left
            ];

            if (isFurry && roundness > 0) {
                 const rOffset = w * roundness;
                 const midR1 = { x: cx + wW/2 + rOffset, y: (shoulderY + waistY)/2 };
                 const midR2 = { x: cx + hW/2 + rOffset*0.5, y: (waistY + hipY)/2 };
                 const midL1 = { x: cx - hW/2 - rOffset*0.5, y: (waistY + hipY)/2 };
                 const midL2 = { x: cx - wW/2 - rOffset, y: (shoulderY + waistY)/2 };
                 points = [ points[0], points[1], midR1, points[2], midR2, points[3], points[4], midL1, points[5], midL2 ];
            }
        }

        if (isFurry) {
            drawFuzzyPath(points, color, scale, true, seed);
        } else {
            ctx.beginPath();

            // Generic Polygon Path for Custom Shapes (Animals)
            if (options.bodyShape && options.bodyShape !== 'human') {
                ctx.moveTo(points[0].x, points[0].y);
                for(let i=1; i<points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
            } else {
                // Humanoid Bezier Logic (Hourglass/Trapezoid specific)
                ctx.moveTo(points[0].x + 10*scale, points[0].y);
                ctx.lineTo(points[1].x - 10*scale, points[1].y);
                ctx.quadraticCurveTo(points[1].x, points[1].y, points[1].x, points[1].y + 10*scale);

                // Right
                if (roundness > 0) {
                    const rOffset = w * roundness;
                    ctx.quadraticCurveTo(cx + wW/2 + rOffset, (shoulderY + waistY)/2, points[2].x, points[2].y);
                    ctx.quadraticCurveTo(cx + hW/2 + rOffset*0.5, (waistY + hipY)/2, points[3].x, points[3].y - 10*scale);
                } else {
                    ctx.lineTo(points[2].x, points[2].y);
                    ctx.lineTo(points[3].x, points[3].y - 10*scale);
                }
                ctx.quadraticCurveTo(points[3].x, points[3].y, points[3].x - 10*scale, points[3].y);
                ctx.lineTo(points[4].x + 10*scale, points[4].y);
                ctx.quadraticCurveTo(points[4].x, points[4].y, points[4].x, points[4].y - 10*scale);

                // Left
                if (roundness > 0) {
                    const rOffset = w * roundness;
                    ctx.quadraticCurveTo(cx - hW/2 - rOffset*0.5, (waistY + hipY)/2, points[5].x, points[5].y);
                    ctx.quadraticCurveTo(cx - wW/2 - rOffset, (shoulderY + waistY)/2, points[0].x, points[0].y + 10*scale);
                } else {
                    ctx.lineTo(points[5].x, points[5].y);
                    ctx.lineTo(points[0].x, points[0].y + 10*scale);
                }
                ctx.quadraticCurveTo(points[0].x, points[0].y, points[0].x + 10*scale, points[0].y);
            }

            ctx.closePath();

            let fillStyle = color;
            if (options.isJersey) {
                 const meshKey = `mesh_${color}`;
                 fillStyle = getCachedPattern(meshKey, (c, size) => {
                      c.fillStyle = color;
                      c.fillRect(0,0,size,size);
                      c.fillStyle = 'rgba(0,0,0,0.15)';
                      const spacing = 4;
                      for(let y=0; y<size; y+=spacing) {
                          for(let x=0; x<size; x+=spacing) {
                              if ((Math.floor(x/spacing) + Math.floor(y/spacing)) % 2 === 0) c.fillRect(x,y,1,1);
                          }
                      }
                      // Gradient overlay
                      const grad = c.createLinearGradient(0,0,size,0);
                      grad.addColorStop(0, 'rgba(0,0,0,0.2)');
                      grad.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                      grad.addColorStop(1, 'rgba(0,0,0,0.2)');
                      c.fillStyle = grad;
                      c.fillRect(0,0,size,size);
                 });

                 // Apply pattern transform
                 if (fillStyle.setTransform && typeof DOMMatrix !== 'undefined') {
                     const matrix = new DOMMatrix();
                     matrix.translateSelf(cx, topY);
                     fillStyle.setTransform(matrix);
                 }
            } else {
                 const cacheKey = `anatomic_body_${color}`;
                 fillStyle = getCachedPattern(cacheKey, (gradCtx, size) => {
                    gradCtx.fillStyle = color;
                    gradCtx.fillRect(0, 0, size, size);
                    const grad = gradCtx.createRadialGradient(size/2, size/2, 5, size/2, size/2, size/2);
                    grad.addColorStop(0, 'rgba(255,255,255,0.1)');
                    grad.addColorStop(1, 'rgba(0,0,0,0.3)');
                    gradCtx.fillStyle = grad;
                    gradCtx.fillRect(0, 0, size, size);
                });
            }

            ctx.fillStyle = fillStyle;
            ctx.fill();

            // Muscle Definition (High Graphics)
            if (!options.isJersey && playerData.graphics === 'HIGH' && !isFurry) {
                 ctx.fillStyle = 'rgba(0,0,0,0.08)';
                 // Pectorals
                 const chestY = shoulderY + h * 0.25;
                 const chestW = w * 0.4;
                 ctx.beginPath();
                 // Left Pec
                 ctx.ellipse(cx - chestW*0.6, chestY, chestW*0.8, h*0.15, 0.2, 0, Math.PI*2);
                 ctx.fill();
                 // Right Pec
                 ctx.beginPath();
                 ctx.ellipse(cx + chestW*0.6, chestY, chestW*0.8, h*0.15, -0.2, 0, Math.PI*2);
                 ctx.fill();

                 // Abs (6-pack)
                 const absY = chestY + h * 0.25;
                 const absW = w * 0.25;
                 const absH = h * 0.35;
                 ctx.fillStyle = 'rgba(0,0,0,0.05)';

                 const gap = 2*scale;
                 const cellW = (absW - gap)/2;
                 const cellH = (absH - gap*2)/3;

                 for(let r=0; r<3; r++) {
                     ctx.fillRect(cx - absW/2, absY + r*(cellH+gap), cellW, cellH);
                     ctx.fillRect(cx + gap/2, absY + r*(cellH+gap), cellW, cellH);
                 }
            }

            // Rim Light
            ctx.save();
            ctx.clip();
            const rimGrad = ctx.createLinearGradient(cx - w, 0, cx + w, 0);
            rimGrad.addColorStop(0, 'rgba(255,255,255,0.0)');
            rimGrad.addColorStop(0.8, 'rgba(255,255,255,0.0)');
            rimGrad.addColorStop(1, 'rgba(255,255,255,0.3)');
            ctx.fillStyle = rimGrad;
            ctx.fill();
            ctx.restore();

            ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 1; ctx.stroke();
        }

        if (options.chestStripeColor) {
            ctx.save();
            if (isFurry) {
                drawFuzzyPath(points, null, scale, true, seed, true);
            } else {
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                if (roundness > 0) {
                    const rOffset = w * roundness;
                    ctx.quadraticCurveTo(cx + wW/2 + rOffset, (shoulderY + waistY)/2, points[2].x, points[2].y);
                    ctx.quadraticCurveTo(cx + hW/2 + rOffset*0.5, (waistY + hipY)/2, points[3].x, points[3].y);
                    ctx.lineTo(points[4].x, points[4].y);
                    ctx.quadraticCurveTo(cx - hW/2 - rOffset*0.5, (waistY + hipY)/2, points[5].x, points[5].y);
                    ctx.quadraticCurveTo(cx - wW/2 - rOffset, (shoulderY + waistY)/2, points[0].x, points[0].y);
                } else {
                    points.forEach((p, i) => { if(i>0) ctx.lineTo(p.x, p.y); });
                }
                ctx.closePath();
            }
            ctx.clip();
            ctx.fillStyle = options.chestStripeColor;
            ctx.fillRect(cx - w*2, topY, w*4, h * 0.25);
            ctx.restore();
        }
    }

    function drawLimb(x1, y1, x2, y2, width, color) {
        const len = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
        const angle = Math.atan2(y2 - y1, x2 - x1);

        ctx.save();
        ctx.translate(x1, y1);
        ctx.rotate(angle);

        // Base Color
        ctx.fillStyle = color;

        ctx.beginPath();

        if (playerData.graphics === 'HIGH') {
            // Curvy "Muscle" Limb
            const bulge = width * 0.15;

            // Start (Shoulder/Hip)
            ctx.arc(0, 0, width/2, Math.PI/2, -Math.PI/2);
            // Top Edge (Bicep/Quad bulge)
            ctx.quadraticCurveTo(len*0.5, -width/2 - bulge, len, -width*0.4);
            // End Cap (Elbow/Knee - narrower)
            ctx.arc(len, 0, width*0.4, -Math.PI/2, Math.PI/2);
            // Bottom Edge
            ctx.quadraticCurveTo(len*0.5, width/2 + bulge*0.5, 0, width/2);
        } else {
            ctx.arc(0, 0, width/2, Math.PI/2, -Math.PI/2);
            ctx.lineTo(len, -width/2);
            ctx.arc(len, 0, width/2, -Math.PI/2, Math.PI/2);
            ctx.lineTo(0, width/2);
        }
        ctx.fill();

        // Cylindrical Shading Overlay
        const grad = ctx.createLinearGradient(0, -width/2, 0, width/2);
        grad.addColorStop(0, 'rgba(0,0,0,0.3)');
        grad.addColorStop(0.2, 'rgba(255,255,255,0.1)');
        grad.addColorStop(0.5, 'rgba(0,0,0,0)');
        grad.addColorStop(0.9, 'rgba(0,0,0,0.4)');

        ctx.fillStyle = grad;
        ctx.fill();

        ctx.restore();
    }

    function drawJoint(x, y, radius, color, isMechanical) {
        if (!isMechanical) return;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI*2);
        ctx.fillStyle = color;
        ctx.fill();

        const grad = ctx.createRadialGradient(x - radius*0.3, y - radius*0.3, 0, x, y, radius);
        grad.addColorStop(0, 'rgba(255,255,255,0.2)');
        grad.addColorStop(1, 'rgba(0,0,0,0.4)');
        ctx.fillStyle = grad;
        ctx.fill();

        // Slight Outline
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    function drawRoundedRect(x, y, w, h, r, color) {
        const cacheKey = `rounded_rect_${color}`;
        const fillStyle = getCachedPattern(cacheKey, (gradCtx, size) => {
            gradCtx.fillStyle = color;
            gradCtx.fillRect(0, 0, size, size);
            const grad = gradCtx.createRadialGradient(size/2, size/2, 5, size/2, size/2, size/2);
            grad.addColorStop(0, 'rgba(255,255,255,0.2)');
            grad.addColorStop(1, 'rgba(0,0,0,0.3)');
            gradCtx.fillStyle = grad;
            gradCtx.fillRect(0, 0, size, size);
        });

        ctx.beginPath();
        ctx.moveTo(x+r, y);
        ctx.arcTo(x+w, y, x+w, y+h, r);
        ctx.arcTo(x+w, y+h, x, y+h, r);
        ctx.arcTo(x, y+h, x, y, r);
        ctx.arcTo(x, y, x+w, y, r);
        ctx.closePath();

        ctx.fillStyle = fillStyle;
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    function drawDecor(p, type, variant, seed) {
        if (!p) return;
        const s = p.scale;
        if(type === 'grass') {
             // Realistic Grass Tuft
             // Base Shadow
             ctx.fillStyle = 'rgba(0,0,0,0.2)';
             ctx.beginPath(); ctx.ellipse(p.x, p.y, 15*s, 5*s, 0, 0, Math.PI*2); ctx.fill();

             // Blades
             ctx.strokeStyle = '#32CD32';
             ctx.lineWidth = 2 * s;
             ctx.lineCap = 'round';
             ctx.beginPath();
             for(let i=0; i<5; i++) {
                 const angle = -Math.PI/2 + (i-2)*0.3;
                 const len = 15 * s + Math.random() * 10 * s;
                 const bx = p.x + (i-2)*3*s;
                 const by = p.y;
                 ctx.moveTo(bx, by);
                 ctx.quadraticCurveTo(bx + Math.cos(angle)*5*s, by - len*0.5, bx + Math.cos(angle)*len, by - len);
             }
             ctx.stroke();

             // Small Flower
             if (seed > 0.7) {
                 ctx.fillStyle = '#FFF';
                 ctx.beginPath(); ctx.arc(p.x, p.y - 15*s, 3*s, 0, Math.PI*2); ctx.fill();
                 ctx.fillStyle = '#FFD700';
                 ctx.beginPath(); ctx.arc(p.x, p.y - 15*s, 1.5*s, 0, Math.PI*2); ctx.fill();
             }
        }
        else if(type === 'tree') {
            const isHigh = playerData.graphics === 'HIGH';

            if (variant === 'pine') {
                // Realistic Pine
                ctx.fillStyle = '#3E2723'; // Trunk
                ctx.fillRect(p.x - 4*s, p.y, 8*s, -20*s);

                const drawLayer = (yBase, w, h, color) => {
                    if (isHigh) {
                        const grad = ctx.createLinearGradient(p.x, yBase - h, p.x, yBase);
                        grad.addColorStop(0, color); // Top lighter
                        grad.addColorStop(1, '#1B5E20'); // Bottom darker
                        ctx.fillStyle = grad;
                    } else {
                        ctx.fillStyle = color;
                    }

                    ctx.beginPath();
                    ctx.moveTo(p.x - w, yBase);
                    ctx.lineTo(p.x, yBase - h);
                    ctx.lineTo(p.x + w, yBase);
                    // Jagged bottom
                    for(let i=1; i<=4; i++) {
                        ctx.lineTo(p.x + w - (2*w*(i/4)), yBase - (i%2==0 ? 0 : 5*s));
                    }
                    ctx.closePath();
                    ctx.fill();
                };

                drawLayer(p.y - 15*s, 30*s, 60*s, '#2E7D32'); // Bottom
                drawLayer(p.y - 45*s, 25*s, 50*s, '#388E3C'); // Mid
                drawLayer(p.y - 70*s, 15*s, 40*s, '#4CAF50'); // Top
            } else {
                // Realistic Oak
                ctx.fillStyle = '#5D4037'; // Trunk
                // Trunk Shading
                if (isHigh) {
                    const tGrad = ctx.createLinearGradient(p.x - 6*s, 0, p.x + 6*s, 0);
                    tGrad.addColorStop(0, '#3E2723'); tGrad.addColorStop(0.5, '#5D4037'); tGrad.addColorStop(1, '#3E2723');
                    ctx.fillStyle = tGrad;
                }

                ctx.beginPath();
                ctx.moveTo(p.x - 6*s, p.y);
                ctx.lineTo(p.x - 6*s, p.y - 30*s);
                ctx.lineTo(p.x + 6*s, p.y - 30*s);
                ctx.lineTo(p.x + 6*s, p.y);
                ctx.fill();

                // Roots
                ctx.beginPath(); ctx.moveTo(p.x - 6*s, p.y); ctx.lineTo(p.x - 10*s, p.y + 5*s); ctx.lineTo(p.x, p.y); ctx.fill();
                ctx.beginPath(); ctx.moveTo(p.x + 6*s, p.y); ctx.lineTo(p.x + 10*s, p.y + 5*s); ctx.lineTo(p.x, p.y); ctx.fill();

                // Canopy (Clustered)
                const drawLeafCircle = (dx, dy, r, color) => {
                    ctx.fillStyle = color;
                    ctx.beginPath(); ctx.arc(p.x + dx*s, p.y - 30*s + dy*s, r*s, 0, Math.PI*2); ctx.fill();
                    // Shadow arc
                    ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 2*s;
                    ctx.beginPath(); ctx.arc(p.x + dx*s, p.y - 30*s + dy*s, r*s, 0.5, 2.5); ctx.stroke();
                };

                drawLeafCircle(-20, -10, 25, '#228B22');
                drawLeafCircle(20, -10, 25, '#228B22');
                drawLeafCircle(0, -40, 30, '#32CD32');
                drawLeafCircle(0, -10, 25, '#2E8B57'); // Front center
            }
        }
        else if (type === 'water') {
             ctx.fillStyle = '#1E90FF';
             ctx.beginPath();
             const r = 20 * s;
             ctx.moveTo(p.x + r, p.y);
             for(let i=1; i<8; i++) {
                 const angle = (i/8) * Math.PI * 2;
                 const varR = r * (0.8 + 0.4 * Math.sin(seed * 10 + i * 132));
                 ctx.lineTo(p.x + Math.cos(angle)*varR, p.y + Math.sin(angle)*varR * 0.3);
             }
             ctx.closePath();
             ctx.fill();
             ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = 2*s;
             ctx.beginPath(); ctx.moveTo(p.x - 10*s, p.y - 2*s); ctx.lineTo(p.x - 5*s, p.y - 2*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x + 2*s, p.y + 2*s); ctx.lineTo(p.x + 8*s, p.y + 2*s); ctx.stroke();
        }
        else if (type === 'castle') { // Now Residential Houses
            const wallColors = ['#F5F5DC', '#FFFACD', '#E0FFFF', '#FFC0CB', '#98FB98', '#D3D3D3', '#F0E68C', '#ADD8E6'];
            const roofColors = ['#8B4513', '#A52A2A', '#2F4F4F', '#696969', '#800000', '#556B2F'];

            // Deterministic selection
            const wallColor = wallColors[Math.floor(Math.abs(Math.sin(seed * 1234)) * wallColors.length)];
            const roofColor = roofColors[Math.floor(Math.abs(Math.sin(seed * 5678)) * roofColors.length)];

            const w = 50 * s;
            const h = 50 * s;

            // Body
            ctx.fillStyle = wallColor;
            ctx.fillRect(p.x - w/2, p.y - h, w, h);

            // Roof (Pitched)
            ctx.fillStyle = roofColor;
            ctx.beginPath();
            ctx.moveTo(p.x - w/2 - 5*s, p.y - h);
            ctx.lineTo(p.x + w/2 + 5*s, p.y - h);
            ctx.lineTo(p.x, p.y - h - 30*s);
            ctx.fill();

            // Door
            ctx.fillStyle = '#4E342E';
            ctx.fillRect(p.x - 8*s, p.y - 20*s, 16*s, 20*s);
            // Knob
            ctx.fillStyle = '#FFD700';
            ctx.beginPath(); ctx.arc(p.x + 4*s, p.y - 10*s, 1.5*s, 0, Math.PI*2); ctx.fill();

            // Windows
            ctx.fillStyle = '#87CEEB';
            // Window 1
            ctx.fillRect(p.x - w/2 + 5*s, p.y - h + 10*s, 12*s, 12*s);
            // Window 2
            ctx.fillRect(p.x + w/2 - 17*s, p.y - h + 10*s, 12*s, 12*s);

            // Window Frames
            ctx.strokeStyle = '#FFF'; ctx.lineWidth = 1*s;
            // Cross 1
            ctx.beginPath(); ctx.moveTo(p.x - w/2 + 11*s, p.y - h + 10*s); ctx.lineTo(p.x - w/2 + 11*s, p.y - h + 22*s); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(p.x - w/2 + 5*s, p.y - h + 16*s); ctx.lineTo(p.x - w/2 + 17*s, p.y - h + 16*s); ctx.stroke();
            // Cross 2
            ctx.beginPath(); ctx.moveTo(p.x + w/2 - 11*s, p.y - h + 10*s); ctx.lineTo(p.x + w/2 - 11*s, p.y - h + 22*s); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(p.x + w/2 - 17*s, p.y - h + 16*s); ctx.lineTo(p.x + w/2 - 5*s, p.y - h + 16*s); ctx.stroke();
        }
        else if (type === 'mountain') {
            ctx.fillStyle = '#757575';
            ctx.beginPath();
            ctx.moveTo(p.x - 25*s, p.y);
            ctx.lineTo(p.x - 15*s, p.y - 40*s);
            ctx.lineTo(p.x, p.y - 60*s);
            ctx.lineTo(p.x + 20*s, p.y - 30*s);
            ctx.lineTo(p.x + 30*s, p.y);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.moveTo(p.x - 11*s, p.y - 50*s);
            ctx.lineTo(p.x, p.y - 60*s);
            ctx.lineTo(p.x + 7*s, p.y - 50*s);
            ctx.lineTo(p.x, p.y - 45*s);
            ctx.fill();
        }
        else if (type === 'space') {
            // Grounded objects (Rocks & Craters) replacing floating planets
            if (seed > 0.6) {
                // Craters
                ctx.fillStyle = '#333'; // Inner dark hole
                ctx.beginPath();
                ctx.ellipse(p.x, p.y, 25*s, 6*s, 0, 0, Math.PI*2);
                ctx.fill();

                // Rim
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2*s;
                ctx.stroke();

            } else {
                // Space Rocks (Grounded)
                const isRed = (seed > 0.3 && seed < 0.45);
                ctx.fillStyle = isRed ? '#8B4513' : '#696969'; // Mars-ish or Grey

                ctx.beginPath();
                const r = 20 * s;
                const segments = 7;
                // Draw a jagged dome sitting on the ground (p.y)
                for(let i=0; i<=segments; i++) {
                    const theta = Math.PI + (i/segments) * Math.PI; // PI (Left) to 2PI (Right)
                    const noise = 0.8 + 0.4 * Math.sin(seed * 50 + i * 13);
                    const d = r * noise;

                    const px = p.x + Math.cos(theta) * d;
                    const py = p.y + Math.sin(theta) * d * 0.7; // Flattened y-axis

                    if(i===0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath(); // Closes bottom flat
                ctx.fill();

                // Shadow/Texture detail
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.arc(p.x - 5*s, p.y - 8*s, 5*s, 0, Math.PI*2);
                ctx.fill();
            }
        }
        else if (type === 'tacocat') {
             const s = p.scale;
             // Taco Shell
             ctx.fillStyle = '#F4C430';
             ctx.beginPath(); ctx.arc(p.x, p.y - 10*s, 25*s, 0, Math.PI, true); ctx.fill(); // Shell
             ctx.strokeStyle = '#D4A017'; ctx.lineWidth = 2*s; ctx.stroke();

             // Cat Head (Peeking out)
             const hy = p.y - 25*s;
             ctx.fillStyle = '#808080';
             ctx.beginPath(); ctx.arc(p.x, hy, 12*s, 0, Math.PI*2); ctx.fill();
             // Ears
             ctx.beginPath(); ctx.moveTo(p.x-10*s, hy-5*s); ctx.lineTo(p.x-15*s, hy-18*s); ctx.lineTo(p.x-4*s, hy-10*s); ctx.fill();
             ctx.beginPath(); ctx.moveTo(p.x+10*s, hy-5*s); ctx.lineTo(p.x+15*s, hy-18*s); ctx.lineTo(p.x+4*s, hy-10*s); ctx.fill();
             // Face
             ctx.fillStyle = '#FFF';
             ctx.beginPath(); ctx.arc(p.x-4*s, hy-2*s, 3*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x+4*s, hy-2*s, 3*s, 0, Math.PI*2); ctx.fill();
             ctx.fillStyle = '#000';
             ctx.beginPath(); ctx.arc(p.x-4*s, hy-2*s, 1.5*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x+4*s, hy-2*s, 1.5*s, 0, Math.PI*2); ctx.fill();

             // Fillings (Foreground)
             ctx.fillStyle = '#8B4513'; ctx.beginPath(); ctx.ellipse(p.x, p.y - 10*s, 20*s, 6*s, 0, 0, Math.PI*2); ctx.fill();
             ctx.fillStyle = '#32CD32';
             ctx.beginPath(); ctx.arc(p.x-10*s, p.y-12*s, 6*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x+10*s, p.y-12*s, 6*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x, p.y-14*s, 6*s, 0, Math.PI*2); ctx.fill();
        }
        else if (type === 'crowd') {
             const s = p.scale;
             const w = 200 * s;
             const h = 80 * s;

             // Simple Grandstand
             ctx.fillStyle = '#222';
             ctx.fillRect(p.x - w/2, p.y - h, w, h);
             ctx.strokeStyle = '#444'; ctx.lineWidth = 2*s; ctx.strokeRect(p.x - w/2, p.y - h, w, h);

             // Crowd Blobs
             const dens = variant.density || 0.5;
             const rows = 3 + Math.floor(dens * 4);
             const cols = 8;

             ctx.textAlign = 'center';
             ctx.textBaseline = 'middle';
             ctx.font = `${12 * s}px Arial`;

             for(let r=0; r<rows; r++) {
                 for(let c=0; c<cols; c++) {
                     // Deterministic "Random" based on seed and position
                     const cellSeed = (seed * 1000) + (r * 31) + (c * 17);
                     const rand = Math.abs(Math.sin(cellSeed)); // 0..1 deterministic

                     if (rand > 0.8) continue; // Deterministic gap

                     const hx = (p.x - w/2) + (c * (w/cols)) + ((Math.cos(cellSeed)*5)*s); // Static X offset

                     // Bounce ONLY if cheering
                     let bounce = 0;
                     if (crowdCheerTimer > 0) {
                         const time = Date.now() * 0.02;
                         bounce = Math.sin(time + rand * 10) * 5 * s;
                     }
                     const hy = (p.y - h) + (r * (h/rows)) + bounce;

                     // Emoji
                     const emojiIndex = Math.floor(rand * CROWD_EMOJIS.length);
                     ctx.fillText(CROWD_EMOJIS[emojiIndex], hx, hy);
                 }
             }
        }

        else if (type.startsWith('landmark_')) {
             const s = p.scale;
             const color = variant.color || '#888';
             ctx.fillStyle = color;

             if (type === 'landmark_pyramid') {
                 const w = 400 * s; const h = 300 * s;
                 ctx.fillStyle = '#D2B48C';
                 ctx.beginPath(); ctx.moveTo(p.x, p.y - h); ctx.lineTo(p.x + w/2, p.y); ctx.lineTo(p.x - w/2, p.y); ctx.fill();
                 // Shadow side
                 ctx.fillStyle = 'rgba(0,0,0,0.2)';
                 ctx.beginPath(); ctx.moveTo(p.x, p.y - h); ctx.lineTo(p.x + w/2, p.y); ctx.lineTo(p.x, p.y); ctx.fill();
             }
             else if (type === 'landmark_tower') { // Eiffel
                 const w = 150 * s; const h = 500 * s;
                 ctx.strokeStyle = '#555'; ctx.lineWidth = 5*s;
                 ctx.beginPath(); ctx.moveTo(p.x - w/2, p.y); ctx.quadraticCurveTo(p.x, p.y - h*0.6, p.x, p.y - h); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(p.x + w/2, p.y); ctx.quadraticCurveTo(p.x, p.y - h*0.6, p.x, p.y - h); ctx.stroke();
                 // Levels
                 ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(p.x - w*0.4, p.y - h*0.3); ctx.lineTo(p.x + w*0.4, p.y - h*0.3); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(p.x - w*0.2, p.y - h*0.6); ctx.lineTo(p.x + w*0.2, p.y - h*0.6); ctx.stroke();
             }
             else if (type === 'landmark_building' || type === 'landmark_needle') { // Skyscraper/Needle
                 const w = (type==='landmark_needle'?60:150) * s;
                 const h = (type==='landmark_needle'?600:800) * s;

                 ctx.fillRect(p.x - w/2, p.y - h, w, h);
                 // Windows
                 if(type === 'landmark_building') {
                     ctx.fillStyle = 'rgba(255,255,255,0.3)';
                     for(let i=0; i<20; i++) {
                         for(let j=0; j<4; j++) {
                             // Deterministic Windows
                             const winSeed = Math.sin(seed * 999 + i * 13 + j * 7);
                             if(winSeed > 0) ctx.fillRect(p.x - w/2 + 10*s + j*30*s, p.y - h + 20*s + i*40*s, 15*s, 20*s);
                         }
                     }
                 } else {
                     // Needle Top
                     ctx.fillStyle = color;
                     ctx.beginPath(); ctx.ellipse(p.x, p.y - h*0.8, w*2, 20*s, 0, 0, Math.PI*2); ctx.fill();
                 }
             }
             else if (type === 'landmark_leaning') { // Pisa
                 const w = 100 * s; const h = 400 * s;
                 ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(0.1); // Lean
                 ctx.fillStyle = '#EEE'; ctx.fillRect(-w/2, -h, w, h);
                 // Arches
                 ctx.fillStyle = '#CCC';
                 for(let i=0; i<8; i++) ctx.fillRect(-w/2, -h + i*50*s, w, 5*s);
                 ctx.restore();
             }
             else if (type === 'landmark_statue') { // Liberty
                 const h = 300 * s;
                 ctx.fillStyle = '#2E8B57';
                 ctx.fillRect(p.x - 40*s, p.y - h, 80*s, h); // Body
                 ctx.beginPath(); ctx.arc(p.x, p.y - h - 30*s, 30*s, 0, Math.PI*2); ctx.fill(); // Head
                 // Arm
                 ctx.lineWidth = 15*s; ctx.strokeStyle = '#2E8B57';
                 ctx.beginPath(); ctx.moveTo(p.x + 20*s, p.y - h); ctx.lineTo(p.x + 60*s, p.y - h - 80*s); ctx.stroke();
                 // Torch
                 ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(p.x + 60*s, p.y - h - 90*s, 10*s, 0, Math.PI*2); ctx.fill();
             }
             else if (type === 'landmark_castle') {
                 // Reuse simple castle logic but bigger?
                 const w = 300 * s; const h = 200 * s;
                 ctx.fillStyle = '#A52A2A';
                 ctx.fillRect(p.x - w/2, p.y - h/2, w, h/2); // Base
                 ctx.fillRect(p.x - w/2, p.y - h, w/4, h); // Tower L
                 ctx.fillRect(p.x + w/4, p.y - h, w/4, h); // Tower R
                 ctx.fillStyle = '#8B0000'; // Roofs
                 ctx.beginPath(); ctx.moveTo(p.x - w/2 - 20*s, p.y - h); ctx.lineTo(p.x - w/2 + w/4 + 20*s, p.y - h); ctx.lineTo(p.x - w/2 + w/8, p.y - h - 50*s); ctx.fill();
                 ctx.beginPath(); ctx.moveTo(p.x + w/4 - 20*s, p.y - h); ctx.lineTo(p.x + w/4 + w/4 + 20*s, p.y - h); ctx.lineTo(p.x + w/4 + w/8, p.y - h - 50*s); ctx.fill();
             }
        }
    }

    function drawShadow(p) {
        if(!p) return;

        // Low Quality / Fallback
        if (playerData.graphics === 'LOW') {
            ctx.fillStyle='rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(p.x, p.y, 25*p.scale, 8*p.scale, 0, 0, Math.PI*2);
            ctx.fill();
            return;
        }

        const s = p.scale;
        const z = player3D.z;

        // Fade out shadow as player jumps high
        const alpha = Math.max(0.1, 0.4 - (z / 600));
        // Blur increases with height
        const blur = Math.min(20, 5 + (z / 15));

        ctx.save();
        ctx.translate(p.x, p.y);

        // Directional offset (Sun is roughly top-right 700,80)
        // Cast shadow to bottom-left relative to light
        // Simple rotation/skew
        ctx.rotate(0.15);

        // Main Soft Shadow
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = blur;
        ctx.fillStyle = `rgba(0,0,0,${alpha})`;

        ctx.beginPath();
        // Slightly larger and wider ellipse
        ctx.ellipse(-5*s, 0, 30*s, 12*s, 0, 0, Math.PI*2);
        ctx.fill();

        // Contact Shadows (Feet) - Only when close to ground
        if (z < 40) {
            ctx.shadowBlur = 2; // Sharp contact
            const contactAlpha = (1 - (z/40)) * 0.6;
            ctx.fillStyle = `rgba(0,0,0,${contactAlpha})`;

            // Left Foot Area
            ctx.beginPath();
            ctx.ellipse(-10*s, 2*s, 7*s, 4*s, 0, 0, Math.PI*2);
            ctx.fill();

            // Right Foot Area
            ctx.beginPath();
            ctx.ellipse(10*s, 2*s, 7*s, 4*s, 0, 0, Math.PI*2);
            ctx.fill();
        }

        ctx.restore();
    }

    function drawHoop(p) {
        if (!p) return;
        const s = p.scale;
        const baseP = project(HOOP_POS.x, HOOP_POS.y, 0);
        if(baseP) { ctx.fillStyle = '#444'; ctx.fillRect(p.x - 2*s, p.y, 4*s, baseP.y - p.y); }
        const bbW = 60 * s; const bbH = 40 * s; const bbX = p.x - bbW/2; const bbY = p.y - bbH - 10*s;
        ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(bbX, bbY, bbW, bbH);
        ctx.strokeStyle = '#333'; ctx.lineWidth = 2*s; ctx.strokeRect(bbX, bbY, bbW, bbH);
        ctx.fillStyle = '#CE1126'; ctx.fillRect(bbX + bbW*0.35, bbY + bbH*0.6, bbW*0.3, bbH*0.3);
        ctx.beginPath(); ctx.ellipse(p.x, p.y, 18 * s, 5 * s, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'none'; ctx.strokeStyle = 'orange'; ctx.lineWidth = 4 * s; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(p.x - 15*s, p.y); ctx.lineTo(p.x - 10*s, p.y + 20*s); ctx.lineTo(p.x + 10*s, p.y + 20*s); ctx.lineTo(p.x + 15*s, p.y);
        ctx.strokeStyle = 'white'; ctx.lineWidth = 1*s; ctx.stroke();
    }

    function drawMuscleLimb(x1, y1, x2, y2, width, color, type, s) {
        // type: 'thigh' or 'calf' or 'standard'
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const len = Math.sqrt((x2-x1)**2 + (y2-y1)**2);
        
        ctx.save();
        ctx.translate(x1, y1);
        ctx.rotate(angle);
        
        const w = width / 2;
        let startW = w;
        let endW = w;

        if (type === 'thigh') {
            endW = w * 0.7;
        } else if (type === 'calf') {
            startW = w * 0.7;
            endW = w * 0.5;
        }

        ctx.beginPath();

        // Start Cap
        ctx.arc(0, 0, startW, Math.PI/2, -Math.PI/2);
        
        if (type === 'thigh') {
            // Thigh
            if (playerData.graphics === 'HIGH') {
                 ctx.quadraticCurveTo(len*0.4, -w*1.3, len, -endW);
                 ctx.arc(len, 0, endW, -Math.PI/2, Math.PI/2);
                 ctx.quadraticCurveTo(len*0.4, w*1.3, 0, startW);
            } else {
                 ctx.lineTo(len, -endW);
                 ctx.arc(len, 0, endW, -Math.PI/2, Math.PI/2);
                 ctx.lineTo(0, startW);
            }
        } else if (type === 'calf') {
            // Calf
            ctx.quadraticCurveTo(len * 0.3, -w * 1.4, len, -endW);
            ctx.arc(len, 0, endW, -Math.PI/2, Math.PI/2);
            ctx.quadraticCurveTo(len * 0.3, w * 1.4, 0, startW);
        } else {
            // Standard
            ctx.lineTo(len, -endW);
            ctx.arc(len, 0, endW, -Math.PI/2, Math.PI/2);
            ctx.lineTo(0, startW);
        }
        
        ctx.closePath();
        
        // 1. Base Color Fill
        ctx.fillStyle = color;
        ctx.fill();

        // 2. 3D Volume Gradient (Cylinder Effect)
        // Vertical gradient relative to the limb (y from -w to w)
        const grad = ctx.createLinearGradient(0, -w, 0, w);
        grad.addColorStop(0, 'rgba(0,0,0,0.5)');       // Top Shadow (Deep)
        grad.addColorStop(0.15, 'rgba(0,0,0,0.2)');    // Soft Shadow
        grad.addColorStop(0.4, 'rgba(255,255,255,0.25)'); // Specular Highlight (Shinier)
        grad.addColorStop(0.6, 'rgba(255,255,255,0.05)'); // Soft Light
        grad.addColorStop(0.85, 'rgba(0,0,0,0.2)');    // Soft Shadow
        grad.addColorStop(1, 'rgba(0,0,0,0.5)');       // Bottom Shadow (Deep)

        ctx.fillStyle = grad;
        ctx.fill();
        
        // 3. Muscle Definition Highlights (Bulge Accent)
        // If High Graphics, add specific muscle curve accents
        if (playerData.graphics === 'HIGH') {
             // Top Highlight (Bicep/Quad)
             ctx.strokeStyle = 'rgba(255,255,255,0.15)';
             ctx.lineWidth = w * 0.3;
             ctx.lineCap = 'round';
             ctx.beginPath();
             ctx.moveTo(len * 0.2, -w * 0.5);
             ctx.quadraticCurveTo(len * 0.5, -w * 0.8, len * 0.8, -w * 0.5);
             ctx.stroke();

             // Bottom Shadow (Tricep/Hamstring)
             ctx.strokeStyle = 'rgba(0,0,0,0.2)';
             ctx.beginPath();
             ctx.moveTo(len * 0.2, w * 0.5);
             ctx.quadraticCurveTo(len * 0.5, w * 0.8, len * 0.8, w * 0.5);
             ctx.stroke();
        }
        
        ctx.restore();
    }

    function drawRealisticShoe(x, y, w, h, color, isRight) {
        // Detailed sneaker
        // Sole
        ctx.fillStyle = '#DDD'; 
        ctx.beginPath();
        ctx.ellipse(x, y + h*0.2, w, h*0.4, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = '#999'; ctx.lineWidth=1; ctx.stroke();
        
        // Upper
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y - h*0.2, w*0.9, 0, Math.PI*2); // Main foot
        ctx.fill();
        
        // Detail lines (laces area)
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.moveTo(x - w*0.5, y - h*0.5); ctx.lineTo(x + w*0.5, y - h*0.5); ctx.stroke();
    }

    // --- OPTIMIZATION: Gradient Caching ---
    const GRAD_CANVAS_SIZE = 64; // Power of 2 for performance
    const g_gradientCache = {};

    function getCachedPattern(key, generator) {
        if (g_gradientCache[key]) {
            return g_gradientCache[key];
        }

        const gradCanvas = document.createElement('canvas');
        gradCanvas.width = GRAD_CANVAS_SIZE;
        gradCanvas.height = GRAD_CANVAS_SIZE;
        const gradCtx = gradCanvas.getContext('2d');

        generator(gradCtx, GRAD_CANVAS_SIZE);

        const pattern = ctx.createPattern(gradCanvas, 'repeat');
        g_gradientCache[key] = pattern;
        return pattern;
    }

    function drawJersey(cx, topY, w, h, scale, skinObj) {
        // V-Taper Jersey
        const color = skinObj.jerseyColor || '#FFF';
        const shoulderW = w * 1.6;
        const waistW = w * 0.9;
        
        const shoulderY = topY;
        const armpitY = topY + h * 0.4;
        const bottomY = topY + h;
        
        ctx.beginPath();
        ctx.moveTo(cx - shoulderW/2, shoulderY); 
        ctx.lineTo(cx + shoulderW/2, shoulderY);
        
        // Right side
        ctx.lineTo(cx + shoulderW/2, armpitY);
        ctx.quadraticCurveTo(cx + waistW*0.6, (armpitY+bottomY)/2, cx + waistW/2, bottomY);
        
        // Bottom curve (Tuck)
        ctx.quadraticCurveTo(cx, bottomY + 3*scale, cx - waistW/2, bottomY);
        
        // Left side
        ctx.quadraticCurveTo(cx - waistW*0.6, (armpitY+bottomY)/2, cx - shoulderW/2, armpitY);
        ctx.lineTo(cx - shoulderW/2, shoulderY);
        
        ctx.closePath();
        
        // Fill
        const grad = ctx.createLinearGradient(cx - shoulderW/2, topY, cx + shoulderW/2, topY);
        grad.addColorStop(0, color); 
        grad.addColorStop(0.5, 'rgba(255,255,255,0.05)');
        grad.addColorStop(1, color); 
        
        ctx.fillStyle = color;
        ctx.fill();
        ctx.fillStyle = grad; 
        ctx.globalCompositeOperation = 'source-atop';
        ctx.fill();

        // --- PATTERNS ---
        // Pinstripes
        if(skinObj.pinstripesColor) {
            ctx.strokeStyle = skinObj.pinstripesColor;
            ctx.lineWidth = 1 * scale;
            const step = 4 * scale;
            for(let dx = -shoulderW/2; dx <= shoulderW/2; dx += step) {
                if(Math.abs(dx) < 2*scale) continue; // Skip spine
                ctx.beginPath();
                ctx.moveTo(cx + dx, shoulderY);
                ctx.lineTo(cx + dx * 0.7, bottomY); // Taper in
                ctx.stroke();
            }
        }

        // Side Panels
        if(skinObj.sideStripesColor) {
            ctx.fillStyle = skinObj.sideStripesColor;
            const stripeW = 3 * scale;

            // Left Panel
            ctx.beginPath();
            ctx.moveTo(cx - shoulderW/2, armpitY);
            ctx.quadraticCurveTo(cx - waistW*0.6, (armpitY+bottomY)/2, cx - waistW/2, bottomY);
            ctx.lineTo(cx - waistW/2 + stripeW, bottomY);
            ctx.quadraticCurveTo(cx - waistW*0.6 + stripeW, (armpitY+bottomY)/2, cx - shoulderW/2 + stripeW, armpitY);
            ctx.fill();

            // Right Panel
            ctx.beginPath();
            ctx.moveTo(cx + shoulderW/2, armpitY);
            ctx.quadraticCurveTo(cx + waistW*0.6, (armpitY+bottomY)/2, cx + waistW/2, bottomY);
            ctx.lineTo(cx + waistW/2 - stripeW, bottomY);
            ctx.quadraticCurveTo(cx + waistW*0.6 - stripeW, (armpitY+bottomY)/2, cx + shoulderW/2 - stripeW, armpitY);
            ctx.fill();
        }

        ctx.globalCompositeOperation = 'source-over';

        // Spine/Back Detail
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.beginPath();
        ctx.moveTo(cx, topY + h*0.2);
        ctx.lineTo(cx + 1*scale, topY + h*0.7);
        ctx.lineTo(cx - 1*scale, topY + h*0.7);
        ctx.fill();
        
        // Mesh Texture
        ctx.save();
        ctx.clip();
        ctx.fillStyle = 'rgba(0,0,0,0.05)';
        for(let i=0; i<h; i+=4*scale) {
            if (i%8===0) ctx.fillRect(cx - shoulderW, topY + i, shoulderW*2, 1*scale);
        }
        ctx.restore();

        // --- TRIM (Over Texture) ---
        if(skinObj.trimColor) {
            ctx.strokeStyle = skinObj.trimColor;
            ctx.lineWidth = 2 * scale;
            // Neck
            ctx.beginPath();
            ctx.moveTo(cx - shoulderW/2, shoulderY);
            ctx.lineTo(cx + shoulderW/2, shoulderY);
            ctx.stroke();
            // Armholes
            ctx.beginPath();
            ctx.moveTo(cx - shoulderW/2, shoulderY);
            ctx.lineTo(cx - shoulderW/2, armpitY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cx + shoulderW/2, shoulderY);
            ctx.lineTo(cx + shoulderW/2, armpitY);
            ctx.stroke();
        }
        
        // Tuck Shadow at bottom
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.moveTo(cx - waistW/2, bottomY);
        ctx.quadraticCurveTo(cx, bottomY + 3*scale, cx + waistW/2, bottomY);
        ctx.lineTo(cx + waistW/2, bottomY - 4*scale);
        ctx.quadraticCurveTo(cx, bottomY - 1*scale, cx - waistW/2, bottomY - 4*scale);
        ctx.fill();
    }

    function drawShorts(cx, waistY, w, h, scale, skinObj) {
        // Baggy Shorts
        const color = skinObj.shortsColor || '#FFF';
        const waistW = w * 1.0; 
        const hipW = w * 1.3;
        const legW = w * 0.6; // Width of one leg hole

        const bottomY = waistY + h;
        const crotchY = waistY + h * 0.45;

        // --- Get Base Pattern (Color + Shading) ---
        const cacheKey = `shorts_base_${color}`;
        let fillStyle = getCachedPattern(cacheKey, (gradCtx, size) => {
            // Base Color
            gradCtx.fillStyle = color;
            gradCtx.fillRect(0, 0, size, size);
            // Gradient Overlay
            const grad = gradCtx.createLinearGradient(0, 0, size, 0);
            grad.addColorStop(0, 'rgba(0,0,0,0.1)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.05)');
            grad.addColorStop(1, 'rgba(0,0,0,0.1)');
            gradCtx.fillStyle = grad;
            gradCtx.fillRect(0, 0, size, size);
        });
        if (!fillStyle) fillStyle = color;

        // --- Draw Main Shape ---
        ctx.beginPath();
        ctx.moveTo(cx - waistW/2, waistY); ctx.lineTo(cx + waistW/2, waistY);
        ctx.quadraticCurveTo(cx + hipW/2, waistY + h*0.2, cx + hipW/2, bottomY);
        ctx.lineTo(cx + hipW/2 - legW, bottomY);
        ctx.quadraticCurveTo(cx, crotchY + h*0.2, cx, crotchY);
        ctx.quadraticCurveTo(cx, crotchY + h*0.2, cx - hipW/2 + legW, bottomY);
        ctx.lineTo(cx - hipW/2, bottomY);
        ctx.quadraticCurveTo(cx - hipW/2, waistY + h*0.2, cx - waistW/2, waistY);
        ctx.closePath();
        
        ctx.fillStyle = fillStyle;
        ctx.fill();

        // --- Draw Stripes Dynamically (to preserve curves) ---
        if(skinObj.sideStripesColor) {
            ctx.save();
            ctx.clip(); // Clip to the shorts path just drawn

            ctx.fillStyle = skinObj.sideStripesColor;
            const stripeW = 4 * scale;

            // Left Stripe Path
            ctx.beginPath();
            ctx.moveTo(cx - hipW/2, waistY);
            ctx.quadraticCurveTo(cx - hipW/2, waistY + h*0.5, cx - hipW/2, bottomY);
            ctx.lineTo(cx - hipW/2 + stripeW, bottomY);
            ctx.quadraticCurveTo(cx - hipW/2 + stripeW, waistY + h*0.5, cx - hipW/2 + stripeW, waistY);
            ctx.closePath();
            ctx.fill();

            // Right Stripe Path
            ctx.beginPath();
            ctx.moveTo(cx + hipW/2, waistY);
            ctx.quadraticCurveTo(cx + hipW/2, waistY + h*0.5, cx + hipW/2, bottomY);
            ctx.lineTo(cx + hipW/2 - stripeW, bottomY);
            ctx.quadraticCurveTo(cx + hipW/2 - stripeW, waistY + h*0.5, cx + hipW/2 - stripeW, waistY);
            ctx.closePath();
            ctx.fill();

            ctx.restore(); // Remove clipping mask
        }

        // --- Details (on top of everything) ---
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(cx - waistW/2, waistY, waistW, 5*scale);
        
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 1*scale;
        ctx.beginPath(); ctx.moveTo(cx - hipW/2, waistY); ctx.quadraticCurveTo(cx - hipW/2, waistY + h*0.5, cx - hipW/2, bottomY); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx + hipW/2, waistY); ctx.quadraticCurveTo(cx + hipW/2, waistY + h*0.5, cx + hipW/2, bottomY); ctx.stroke();

        if(skinObj.trimColor) {
            ctx.strokeStyle = skinObj.trimColor;
            ctx.lineWidth = 2 * scale;
            ctx.beginPath(); ctx.moveTo(cx - hipW/2, bottomY); ctx.lineTo(cx - hipW/2 + legW, bottomY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(cx + hipW/2 - legW, bottomY); ctx.lineTo(cx + hipW/2, bottomY); ctx.stroke();
        }
    }

    function drawHybridHead(p, headY, headRadius, s, type, skinObj) {
        const skinTone = skinObj.skinTone || skinObj.furColor || '#8d5524';
        const furColor = skinObj.furColor || skinTone;

        if (type === 'bull') {
            drawFuzzyCircle(p.x, headY, headRadius * 1.2, furColor, 200, s, true);
            ctx.fillStyle = '#3E2723';
            ctx.beginPath(); ctx.ellipse(p.x, headY + 5*s, 8*s, 6*s, 0, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#FFF';
            ctx.beginPath(); ctx.moveTo(p.x - 10*s, headY - 5*s); ctx.quadraticCurveTo(p.x - 20*s, headY - 10*s, p.x - 15*s, headY - 25*s); ctx.lineTo(p.x - 12*s, headY - 5*s); ctx.fill();
            ctx.beginPath(); ctx.moveTo(p.x + 10*s, headY - 5*s); ctx.quadraticCurveTo(p.x + 20*s, headY - 10*s, p.x + 15*s, headY - 25*s); ctx.lineTo(p.x + 12*s, headY - 5*s); ctx.fill();
            ctx.fillStyle = furColor;
            ctx.beginPath(); ctx.ellipse(p.x - 15*s, headY, 6*s, 3*s, 0.2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(p.x + 15*s, headY, 6*s, 3*s, -0.2, 0, Math.PI*2); ctx.fill();
        }
        else if (type === 'jackal') {
            ctx.fillStyle = furColor;
            ctx.beginPath(); ctx.moveTo(p.x - 5*s, headY - 10*s); ctx.lineTo(p.x - 15*s, headY - 25*s); ctx.lineTo(p.x - 15*s, headY - 5*s); ctx.fill();
            ctx.beginPath(); ctx.moveTo(p.x + 5*s, headY - 10*s); ctx.lineTo(p.x + 15*s, headY - 25*s); ctx.lineTo(p.x + 15*s, headY - 5*s); ctx.fill();
            drawFuzzyCircle(p.x, headY, headRadius, furColor, 201, s, true);
            ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.x, headY + 5*s, 4*s, 0, Math.PI*2); ctx.fill();
        }
        else if (type === 'bandicoot') {
            ctx.fillStyle = furColor;
            ctx.beginPath(); ctx.moveTo(p.x - 5*s, headY - 10*s); ctx.lineTo(p.x - 12*s, headY - 20*s); ctx.lineTo(p.x - 10*s, headY); ctx.fill();
            ctx.beginPath(); ctx.moveTo(p.x + 5*s, headY - 10*s); ctx.lineTo(p.x + 12*s, headY - 20*s); ctx.lineTo(p.x + 10*s, headY); ctx.fill();
            drawFuzzyCircle(p.x, headY - 2*s, headRadius, furColor, 202, s, true);
            ctx.fillStyle = '#FF00FF';
            for(let i=0; i<4; i++) {
                ctx.beginPath(); ctx.arc(p.x, headY - 15*s - i*5*s, 5*s, 0, Math.PI*2); ctx.fill();
            }
        }
        else if (type === 'yeti') {
            drawFuzzyCircle(p.x, headY, headRadius * 1.3, '#FFF', 203, s, true);
            ctx.fillStyle = '#ADD8E6';
            ctx.beginPath(); ctx.arc(p.x, headY, 8*s, 0, Math.PI*2); ctx.fill();
        }
        else if (type === 'cyclops') {
            ctx.fillStyle = skinTone;
            ctx.beginPath(); ctx.arc(p.x, headY, headRadius * 1.2, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#333';
            ctx.fillRect(p.x - 15*s, headY - 5*s, 30*s, 5*s);
        }
    }

    function drawRealisticHuman(p, s, skinObj) {
        const isMechanical = isMechanicalSkin(skinObj.id);
        // Base Setup
        const sizeMod = {
            w: skinObj.widthScale || 0.9,
            h: skinObj.heightScale || 1.1,
            head: 0.9,
            armWidth: skinObj.armWidthScale || (skinObj.widthScale || 0.9),
            legWidth: skinObj.legWidthScale || (skinObj.widthScale || 0.9)
        };
        const skinTone = skinObj.skinTone || '#8d5524';
        
        // Body Dimensions
        const bodyW = 20 * s * sizeMod.w; 
        const bodyH = 40 * s * sizeMod.h;
        const legLen = 30 * s * sizeMod.h;
        let torsoY = p.y - legLen - bodyH;
        let headY = torsoY - (10 * s * sizeMod.head);
        const headRadius = 12 * s * sizeMod.head;

        // Super Saiyan Aura
        if (currentStreak >= 10) {
             const hue = getStreakFireHue(currentStreak);
             ctx.save();
             // Outer Glow
             ctx.shadowBlur = 30 * s;
             ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
             ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.1)`;
             ctx.beginPath();
             ctx.ellipse(p.x, torsoY + bodyH*0.5, bodyW * 2.5, bodyH * 2.0, 0, 0, Math.PI*2);
             ctx.fill();
             // Inner Core
             ctx.shadowBlur = 15 * s;
             ctx.fillStyle = `hsla(${hue}, 100%, 80%, 0.15)`;
             ctx.beginPath();
             ctx.ellipse(p.x, torsoY + bodyH*0.5, bodyW * 1.5, bodyH * 1.5, 0, 0, Math.PI*2);
             ctx.fill();
             ctx.restore();
        }

        // 0. Calculate Arm Configuration EARLY (needed for Ball Placement)
        const currentStyle = playerData.currentStyle || 'classic';
        const anim = ANIM_DATA[currentStyle] || ANIM_DATA['classic'];
        const idle = DEFAULT_IDLE;
        
        let r_la, r_ra, r_lfa, r_rfa, r_w;
        if (state === 'SHOOTING') {
            r_la = anim.release.la; r_ra = anim.release.ra;
            r_lfa = anim.release.lfa; r_rfa = anim.release.rfa;
            r_w = anim.release.w;
        } else if (state === 'JUMPING') {
            let lift = Math.max(0, (9 - getCurrentVz()) / 9);
            lift = Math.min(1.0, lift);
            const startPose = anim.ready || idle;
            const lerpAngle = (a, b, t) => {
                if (Math.abs(b - a) > Math.PI) { if (b > a) a += 2 * Math.PI; else b += 2 * Math.PI; }
                return a + (b - a) * t;
            };
            const lerp = (a, b, t) => a + (b - a) * t;
            r_la = lerpAngle(startPose.la, anim.set.la, lift);
            r_ra = lerpAngle(startPose.ra, anim.set.ra, lift);
            r_lfa = lerpAngle(startPose.lfa, anim.set.lfa, lift);
            r_rfa = lerpAngle(startPose.rfa, anim.set.rfa, lift);
            r_w = lerp(startPose.w, anim.set.w, lift);
        } else {
            r_la = idle.la; r_ra = idle.ra;
            r_lfa = idle.lfa; r_rfa = idle.rfa;
            r_w = idle.w;
        }

        let leftArmAngle, rightArmAngle, leftForeArmAngle, rightForeArmAngle, wristAngle;
        if (playerData.isLefty) {
            leftArmAngle = Math.PI - r_ra; rightArmAngle = Math.PI - r_la;
            leftForeArmAngle = Math.PI - r_rfa; rightForeArmAngle = Math.PI - r_lfa;
            wristAngle = -r_w;
        } else {
            leftArmAngle = r_la; rightArmAngle = r_ra;
            leftForeArmAngle = r_lfa; rightForeArmAngle = r_rfa;
            wristAngle = r_w;
        }

        let shoulderY = torsoY + (5*s);
        let leftShoulderX = p.x - 16*s; let rightShoulderX = p.x + 16*s; // Move arms out
        const upperArmLen = 20 * s * sizeMod.h * 1.05;
        const foreArmLen = 20 * s * sizeMod.h * 1.05;

        // 0b. Detached Ball Rendering
        drawDetachedBall(p, s, torsoY, bodyH, headY);

        if (playerData.currentStyle === 'airbud' && state === 'SHOOTING') {
             const t = airbudJumpTime;
             const maxT = 30;
             if (t < maxT) {
                 const jumpHeight = 60 * s * sizeMod.h;
                 const nt = t / maxT;
                 const offset = 4 * jumpHeight * nt * (1 - nt);
                 p.y -= offset;
                 torsoY = p.y - legLen - bodyH;
                 headY = torsoY - (10 * s * sizeMod.head);
                 shoulderY = torsoY + (5*s);
                 // Recalculate shoulders for Human
                 leftShoulderX = p.x - 16*s; rightShoulderX = p.x + 16*s;
             }
        }

        // 0c. HELD BALL RENDERING (Layer 0 - Before Body)
        const isDetachedStyle = ['airbud', 'telekinesis'].includes(playerData.currentStyle);
        if (!isDetachedStyle && state !== 'SHOOTING' && state !== 'GAMEOVER') {
            const isRightHand = !playerData.isLefty;
            const shootUAngle = isRightHand ? rightArmAngle : leftArmAngle;
            const shootFAngle = isRightHand ? rightForeArmAngle : leftForeArmAngle;
            const shootSX = isRightHand ? rightShoulderX : leftShoulderX;

            let elbow = getJoint(shootSX, shoulderY, upperArmLen, shootUAngle);
            let wrist = getJoint(elbow.x, elbow.y, foreArmLen, shootFAngle);

            // Calculate Ball Position based on wrist transform
            // In drawHumanArm: ctx.rotate(angle2 + (isShootingSide ? wristAngle : 0));
            // Ball is at (0, 5*s)
            let theta = shootFAngle + wristAngle;
            let ballX = wrist.x + Math.cos(theta) * 0 - Math.sin(theta) * 5 * s;
            let ballY = wrist.y + Math.sin(theta) * 0 + Math.cos(theta) * 5 * s;

            drawBallSprite(ballX, ballY, s, (currentStreak >= 5));
        }

        // 1. Colors
        const jerseyColor = skinObj.jerseyColor || '#FFF';
        const shortsColor = skinObj.shortsColor || '#FFF';
        const sleeveRight = skinObj.sleeveRight || skinObj.sleeveColor;
        const sleeveLeft = skinObj.sleeveLeft || skinObj.sleeveColor;
        const socksColor = skinObj.socksColor;
        const shoesColor = skinObj.shoesColor;

        // 2. Legs (Base implementation)
        const baseKneeY = p.y - (legLen * 0.5);
        const stanceModLegs = sizeMod.stance || 1.0;
        let lKneeX = p.x - 9*s*stanceModLegs, lKneeY = baseKneeY;
        let rKneeX = p.x + 9*s*stanceModLegs, rKneeY = baseKneeY;
        let lFootX = p.x - 10*s*stanceModLegs, lFootY = p.y;
        let rFootX = p.x + 10*s*stanceModLegs, rFootY = p.y;

        // Dirk Kick Logic
        if (state === 'JUMPING' && playerData.currentStyle === 'dirk') {
            const lift = Math.min(1.0, Math.max(0, (9 - getCurrentVz()) / 9));
            const kickH = 20 * s * lift;
            const kickW = 15 * s * lift;
            if (playerData.isLefty) {
                 lKneeY -= kickH; lKneeX -= kickW; lFootX -= kickW; lFootY -= kickH*0.8;
            } else {
                 rKneeY -= kickH; rKneeX += kickW; rFootX += kickW; rFootY -= kickH*0.8;
            }
        }

        const drawHumanArm = (sx, sy, isRight, angle1, angle2) => {
            const isShootingSide = (playerData.isLefty && !isRight) || (!playerData.isLefty && isRight);
            let uColor = skinTone, fColor = skinTone;
            let activeSleeveColor = null;
            
            if (skinObj.jerseyType === 'tshirt') uColor = jerseyColor;

            if (isRight && sleeveRight) activeSleeveColor = sleeveRight;
            if (!isRight && sleeveLeft) activeSleeveColor = sleeveLeft;

            if (activeSleeveColor) {
                fColor = activeSleeveColor;
            }

            // Shoulder Joint
            drawJoint(sx, sy, 7*s*sizeMod.armWidth * 0.7, uColor, isMechanical);

            let elbow = getJoint(sx, sy, upperArmLen, angle1);

            // Upper Arm (Deltoid to Elbow) - Base
            drawMuscleLimb(sx, sy, elbow.x, elbow.y, 8*s*sizeMod.armWidth, uColor, 'thigh', s);

            // Sleeve Overlay (Mid-Bicep to Elbow)
            if (activeSleeveColor) {
                 const midX = (sx + elbow.x) / 2;
                 const midY = (sy + elbow.y) / 2;
                 drawMuscleLimb(midX, midY, elbow.x, elbow.y, 8.2*s*sizeMod.armWidth, activeSleeveColor, 'thigh', s);
            }
            
            let wrist = getJoint(elbow.x, elbow.y, foreArmLen, angle2);
            // Forearm (Elbow to Wrist)
            drawMuscleLimb(elbow.x, elbow.y, wrist.x, wrist.y, 6*s*sizeMod.armWidth, fColor, 'thigh', s);

            // Elbow Joint
            drawJoint(elbow.x, elbow.y, 6*s*sizeMod.armWidth * 0.7, activeSleeveColor || uColor, isMechanical);

            // Hand
            ctx.save(); ctx.translate(wrist.x, wrist.y); ctx.rotate(angle2 + (isShootingSide ? wristAngle : 0));
            
            // Hand (Realistic)
            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.moveTo(-2*s, 0); ctx.lineTo(2*s, 0); ctx.lineTo(2.5*s, 6*s); ctx.lineTo(-2.5*s, 6*s); 
            ctx.fill();
            
            if (isShootingSide && state !== 'SHOOTING' && state !== 'GAMEOVER' && !isDetachedStyle) {
                // Ball is drawn in Layer 0 now. Just draw Fingers.
                // Fingers over ball
                ctx.fillStyle = skinTone;
                ctx.beginPath(); ctx.arc(-2*s, 6*s, 1.5*s, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(2*s, 6*s, 1.5*s, 0, Math.PI*2); ctx.fill();
            }
            ctx.restore();
        };

        // Arms First (Layer 1) - Arms behind legs
        drawHumanArm(leftShoulderX, shoulderY, false, leftArmAngle, leftForeArmAngle);
        drawHumanArm(rightShoulderX, shoulderY, true, rightArmAngle, rightForeArmAngle);

        // Draw Thighs (Skin tone - under shorts)
        // Hip Joints
        drawJoint(p.x - 7*s, p.y - legLen, 7*s*sizeMod.legWidth * 0.7, skinTone, isMechanical);
        drawJoint(p.x + 7*s, p.y - legLen, 7*s*sizeMod.legWidth * 0.7, skinTone, isMechanical);

        drawMuscleLimb(p.x - 7*s, p.y - legLen, lKneeX, lKneeY, 8*s*sizeMod.legWidth, skinTone, 'thigh', s);
        drawMuscleLimb(p.x + 7*s, p.y - legLen, rKneeX, rKneeY, 8*s*sizeMod.legWidth, skinTone, 'thigh', s);

        // 4. Torso & Shorts Layer
        const jerseyH = bodyH * 0.85;
        const reducedBodyW = bodyW * 0.9;
        const waistY = torsoY + bodyH * 0.85;
        let shortsLen = (0.5 * legLen) + (0.15 * bodyH) + 2*s;
        if (skinObj.shortsLength === 'short') { shortsLen = (0.25 * legLen) + (0.1 * bodyH); }

        // Shorts Next (Layer 2)
        drawShorts(p.x, waistY, reducedBodyW * 1.05, shortsLen, s, skinObj);

        // Torso Last (Layer 4) - Covers top of arms (Shoulders) and top of shorts
        if (skinObj.jerseyType === 'none') {
             // Bare Torso
             drawAnatomicBody(p.x, torsoY, reducedBodyW, jerseyH, s, skinTone, false, 0, { chestStripeColor: null });
             // Muscle Detail (Spine/Pecs)
             ctx.fillStyle = 'rgba(0,0,0,0.1)';
             ctx.beginPath(); ctx.moveTo(p.x, torsoY + 10*s); ctx.lineTo(p.x, torsoY + jerseyH*0.8); ctx.lineTo(p.x + 2*s, torsoY + jerseyH*0.8); ctx.lineTo(p.x + 2*s, torsoY + 10*s); ctx.fill();
        } else {
             drawJersey(p.x, torsoY, reducedBodyW, jerseyH, s, skinObj);
        }

        if (skinObj.clothingDetail === 'overalls') {
             const bibColor = skinObj.shortsColor || '#000080';
             ctx.fillStyle = bibColor;
             // Bib
             ctx.fillRect(p.x - reducedBodyW*0.35, torsoY + 15*s, reducedBodyW*0.7, jerseyH - 15*s);
             // Straps
             ctx.fillRect(p.x - reducedBodyW*0.35, torsoY, 4*s, 20*s);
             ctx.fillRect(p.x + reducedBodyW*0.35 - 4*s, torsoY, 4*s, 20*s);
             // Buttons
             ctx.fillStyle = '#FFD700';
             ctx.beginPath(); ctx.arc(p.x - reducedBodyW*0.35 + 2*s, torsoY + 18*s, 2*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x + reducedBodyW*0.35 - 2*s, torsoY + 18*s, 2*s, 0, Math.PI*2); ctx.fill();
        }

        // Draw Calves/Shoes
        const drawLowerLeg = (xTop, yTop, xBot, yBot, isRight) => {
             let calfCol = skinTone;
             if (skinObj.legType === 'pants') calfCol = shortsColor;
             drawMuscleLimb(xTop, yTop, xBot, yBot, 7*s*sizeMod.legWidth, calfCol, 'calf', s);
             // Socks
             if(socksColor) {
                 const sockH = 7 * s;
                 const sockY = yBot - 5*s - sockH;
                 const t = (sockY - yTop) / (yBot - yTop);
                 const sockTopX = xTop + (xBot - xTop) * t;
                 const ankleY = yBot - 5*s;
                 const t2 = (ankleY - yTop) / (yBot - yTop);
                 const ankleX = xTop + (xBot - xTop) * t2;
                 drawMuscleLimb(sockTopX, sockY, ankleX, ankleY, 6.5*s*sizeMod.legWidth, socksColor, 'standard', s);
                 // Ribs
                 ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.lineWidth = 1;
                 for(let i=0; i<3; i++) {
                     const ly = sockY + (i*2*s);
                     ctx.beginPath(); ctx.moveTo(sockTopX - 3*s, ly); ctx.lineTo(sockTopX + 3*s, ly); ctx.stroke();
                 }
             }
             // Shoes
             if(shoesColor) {
                 drawRealisticShoe(xBot, yBot, 5.5*s, 5.5*s, shoesColor, isRight);
             }
        };
        drawLowerLeg(lKneeX, lKneeY, lFootX, lFootY, false);
        drawLowerLeg(rKneeX, rKneeY, rFootX, rFootY, true);

        // NECK
        const neckW = 10 * s * sizeMod.w;
        const neckH = 10 * s;
        ctx.fillStyle = skinTone;
        ctx.beginPath();
        // Traps/Neck Base
        ctx.moveTo(p.x - neckW, torsoY + 2*s);
        ctx.quadraticCurveTo(p.x - neckW*0.6, torsoY - neckH*0.8, p.x - neckW*0.4, torsoY - neckH);
        ctx.lineTo(p.x + neckW*0.4, torsoY - neckH);
        ctx.quadraticCurveTo(p.x + neckW*0.6, torsoY - neckH*0.8, p.x + neckW, torsoY + 2*s);
        ctx.fill();
        
        // Neck Spine Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.beginPath(); ctx.rect(p.x - 1*s, torsoY - neckH + 2*s, 2*s, neckH); ctx.fill();

        // 5. Tail (Hybrids)
        if (skinObj.tailType) {
            const tx = p.x;
            const ty = waistY + 5*s; // Tail bone area
            const tailColor = skinObj.furColor || skinTone;
            const tW = 4*s;

            if (skinObj.tailType === 'bull') {
                 ctx.beginPath(); ctx.strokeStyle = tailColor; ctx.lineWidth = tW;
                 ctx.moveTo(tx, ty);
                 ctx.quadraticCurveTo(tx + 15*s, ty + 10*s, tx + 20*s, ty + 20*s); ctx.stroke();
                 // Tuft
                 drawFuzzyPath([{x: tx+20*s, y: ty+20*s}, {x: tx+28*s, y: ty+32*s}, {x: tx+12*s, y: ty+32*s}], '#3E2723', s, true, 901);
            }
            else if (skinObj.tailType === 'snake') {
                 ctx.beginPath(); ctx.strokeStyle = '#2E8B57'; ctx.lineWidth = 6*s;
                 ctx.moveTo(tx, ty);
                 ctx.quadraticCurveTo(tx - 15*s, ty + 10*s, tx - 25*s, ty + 5*s); ctx.stroke();
            }
            else if (skinObj.tailType === 'devil') {
                ctx.strokeStyle = '#8B0000'; ctx.lineWidth = 4 * s;
                ctx.beginPath(); ctx.moveTo(tx, ty);
                ctx.quadraticCurveTo(tx + 15*s, ty + 5*s, tx + 25*s, ty - 20*s); ctx.stroke();
                // Triangle Tip
                ctx.fillStyle = '#8B0000'; ctx.beginPath();
                const ttx = tx + 25*s, tty = ty - 20*s;
                ctx.moveTo(ttx, tty); ctx.lineTo(ttx - 5*s, tty + 10*s); ctx.lineTo(ttx + 5*s, tty + 10*s); ctx.fill();
            }
        }

        // 6. Head
        if (skinObj.headType && skinObj.headType !== 'human') {
            drawHybridHead(p, headY, headRadius, s, skinObj.headType, skinObj);
        } else {
            // Standard Human Head
            // Ears
            ctx.fillStyle = skinTone;
            ctx.beginPath();
            ctx.ellipse(p.x - headRadius*0.9, headY, 3*s, 5*s, -0.1, 0, Math.PI*2);
            ctx.ellipse(p.x + headRadius*0.9, headY, 3*s, 5*s, 0.1, 0, Math.PI*2);
            ctx.fill();
            if(skinObj.ears === 'elf') { // Elf Ears
                 ctx.beginPath(); ctx.moveTo(p.x - headRadius*0.9, headY-5*s); ctx.lineTo(p.x - headRadius*1.5, headY-8*s); ctx.lineTo(p.x - headRadius*0.9, headY+5*s); ctx.fill();
                 ctx.beginPath(); ctx.moveTo(p.x + headRadius*0.9, headY-5*s); ctx.lineTo(p.x + headRadius*1.5, headY-8*s); ctx.lineTo(p.x + headRadius*0.9, headY+5*s); ctx.fill();
            }
        
        // Skull
        ctx.beginPath(); 
        ctx.ellipse(p.x, headY - 1*s, headRadius * 0.95, headRadius * 1.05, 0, 0, Math.PI*2); 
        ctx.fill();
        
        if (playerData.graphics === 'HIGH') {
             // Enhanced Shading (Jawline/Neck)
             ctx.fillStyle = 'rgba(0,0,0,0.15)';
             ctx.beginPath();
             ctx.arc(p.x, headY + headRadius*0.6, 5*s, 0, Math.PI*2);
             ctx.fill();

             // Gradient for hair shadow
             const hGrad = ctx.createLinearGradient(0, headY - headRadius, 0, headY);
             hGrad.addColorStop(0, 'rgba(0,0,0,0.1)');
             hGrad.addColorStop(1, 'rgba(0,0,0,0)');
             ctx.fillStyle = hGrad;
             ctx.fill();
        } else {
             // Occipital Shadow (Base of skull)
             ctx.fillStyle = 'rgba(0,0,0,0.1)';
             ctx.beginPath(); ctx.arc(p.x, headY + headRadius*0.5, 4*s, 0, Math.PI*2); ctx.fill();
        }
        
        // Hair
        if(skinObj.hairStyle === 'afro') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             ctx.beginPath(); ctx.arc(p.x, headY - 2*s, headRadius * 1.5, 0, Math.PI*2); ctx.fill();
        }
        else if(skinObj.hairStyle === 'short') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             ctx.beginPath(); ctx.arc(p.x, headY - 1*s, headRadius * 1.02, 0, Math.PI*2); ctx.fill();
        }
        else if(skinObj.hairStyle === 'bald') {
             ctx.fillStyle = 'rgba(255,255,255,0.2)';
             ctx.beginPath(); ctx.arc(p.x + 5*s, headY - 5*s, 3*s, 0, Math.PI*2); ctx.fill();
        }
        else if(skinObj.hairStyle === 'cornrows') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             // Base
             ctx.beginPath(); ctx.arc(p.x, headY - 2*s, headRadius, Math.PI, 0); ctx.fill();

             // Defined Braids
             const braidColor = 'rgba(255,255,255,0.15)'; // Highlight
             const drawBraid = (x1, y1, x2, y2) => {
                 const dx = x2 - x1, dy = y2 - y1;
                 const len = Math.sqrt(dx*dx + dy*dy);
                 const segments = Math.floor(len / (3*s));
                 const ux = dx/len, uy = dy/len;

                 ctx.fillStyle = braidColor;
                 for(let k=0; k<segments; k++) {
                     const t = k / segments;
                     const bx = x1 + dx*t;
                     const by = y1 + dy*t;
                     ctx.beginPath();
                     // Alternate offset for braid effect
                     const off = (k%2 === 0) ? 1.5*s : -1.5*s;
                     ctx.ellipse(bx, by, 2*s, 2*s, 0, 0, Math.PI*2);
                     ctx.fill();
                 }
             };

             // Draw Rows
             drawBraid(p.x, headY, p.x, headY - 14*s); // Center
             for(let i=1; i<=3; i++) {
                 drawBraid(p.x - (i*5*s), headY, p.x - (i*2*s), headY - 14*s);
                 drawBraid(p.x + (i*5*s), headY, p.x + (i*2*s), headY - 14*s);
             }
        }
        else if(skinObj.hairStyle === 'pompadour') {
             ctx.fillStyle = skinObj.hairColor || '#5D4037';
             // Pompadour Shape
             ctx.beginPath();
             // Top volume (tall and slightly wider at top)
             ctx.ellipse(p.x, headY - 6*s, headRadius * 1.2, headRadius * 1.4, 0, Math.PI, 0);
             // Sides tapering down to nape
             ctx.lineTo(p.x + headRadius * 0.8, headY + 10*s);
             ctx.quadraticCurveTo(p.x, headY + 14*s, p.x - headRadius * 0.8, headY + 10*s);
             ctx.lineTo(p.x - headRadius * 1.2, headY - 6*s);
             ctx.fill();

             // Detail: Swirl or sheen on top
             ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 2*s;
             ctx.beginPath(); ctx.arc(p.x, headY - 8*s, headRadius * 0.8, Math.PI + 0.5, -0.5); ctx.stroke();
        }
        else if(skinObj.hairStyle === 'mohawk') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             ctx.beginPath(); ctx.ellipse(p.x, headY - 12*s, 4*s, 10*s, 0, 0, Math.PI*2); ctx.fill();
             for(let i=0; i<3; i++) { ctx.beginPath(); ctx.arc(p.x, headY - 15*s - (i*5*s), (4-i)*s, 0, Math.PI*2); ctx.fill(); }
        }
        else if(skinObj.hairStyle === 'long') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             ctx.beginPath(); ctx.moveTo(p.x - 12*s, headY - 5*s); ctx.lineTo(p.x - 15*s, headY + 15*s); ctx.lineTo(p.x + 15*s, headY + 15*s); ctx.lineTo(p.x + 12*s, headY - 5*s); ctx.arc(p.x, headY - 5*s, 12*s, 0, Math.PI, true); ctx.fill();
        }
        else if(skinObj.hairStyle === 'curly_long') {
             ctx.fillStyle = skinObj.hairColor || '#dcb98a';

             // Static Lion-like Mane
             const maneRadius = headRadius * 2.0;

             // Draw Mane (Static seed = 500)
             drawFuzzyCircle(p.x, headY + 5*s, maneRadius, ctx.fillStyle, 500, s, true);

             // Top/Forehead volume (Static seed = 501)
             drawFuzzyCircle(p.x, headY - headRadius * 0.5, headRadius * 1.2, ctx.fillStyle, 501, s, true);
        }
        else if(skinObj.hairStyle === 'spikes') {
             ctx.fillStyle = skinObj.hairColor || '#0000FF';
             ctx.beginPath(); ctx.arc(p.x, headY - 1*s, headRadius * 1.3, 0, Math.PI*2); ctx.fill();
             const numSpikes = 7;
             for(let i=0; i<numSpikes; i++) {
                 const angle = Math.PI + (i / (numSpikes-1)) * Math.PI; // Semicircle
                 const sx = p.x + Math.cos(angle) * 10*s;
                 const sy = (headY - 2*s) + Math.sin(angle) * 10*s;
                 const ex = p.x + Math.cos(angle) * 25*s;
                 const ey = (headY - 2*s) + Math.sin(angle) * 25*s;

                 ctx.beginPath();
                 ctx.moveTo(sx + Math.cos(angle+1.5)*6*s, sy + Math.sin(angle+1.5)*6*s);
                 ctx.lineTo(ex, ey);
                 ctx.lineTo(sx + Math.cos(angle-1.5)*6*s, sy + Math.sin(angle-1.5)*6*s);
                 ctx.fill();
             }
        }
        else if(skinObj.hairStyle === 'snakes') {
             ctx.strokeStyle = skinObj.hairColor || '#006400';
             ctx.lineWidth = 3*s;
             ctx.lineCap = 'round';
             const numSnakes = 8;
             for(let i=0; i<numSnakes; i++) {
                 const angle = Math.PI + (i / (numSnakes-1)) * Math.PI;
                 const sx = p.x + Math.cos(angle) * 8*s;
                 const sy = (headY - 5*s) + Math.sin(angle) * 8*s;

                 ctx.beginPath();
                 ctx.moveTo(sx, sy);
                 // Wavy snake
                 const cp1x = sx + Math.cos(angle) * 10*s + Math.random()*5*s;
                 const cp1y = sy + Math.sin(angle) * 10*s;
                 const cp2x = sx + Math.cos(angle) * 20*s - Math.random()*5*s;
                 const cp2y = sy + Math.sin(angle) * 20*s;
                 const ex = sx + Math.cos(angle) * 25*s;
                 const ey = sy + Math.sin(angle) * 25*s;

                 ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
                 ctx.stroke();

                 // Snake Head
                 ctx.fillStyle = skinObj.hairColor || '#006400';
                 ctx.beginPath(); ctx.arc(ex, ey, 2.5*s, 0, Math.PI*2); ctx.fill();
             }
        }

        if(skinObj.beard) {
             ctx.fillStyle = skinObj.beardColor || '#000';
             ctx.beginPath(); ctx.arc(p.x, headY, 12*s, 0.2, Math.PI - 0.2); ctx.lineTo(p.x, headY + 15*s); ctx.closePath(); ctx.fill();
        }

        // Headband
        if(skinObj.hairStyle === 'headband') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             ctx.beginPath(); ctx.arc(p.x, headY - 2*s, headRadius, Math.PI, 0); ctx.fill();
             ctx.strokeStyle = skinObj.headbandColor || '#FFF'; ctx.lineWidth = 4*s;
             ctx.beginPath(); ctx.moveTo(p.x-11*s, headY-5*s); ctx.lineTo(p.x+11*s, headY-5*s); ctx.stroke();
        }

        } // End of Standard Human Specifics (Ears, Hair)

        // 7. Shared Head Accessories
        if (skinObj.headAccessory === 'sombrero') {
            ctx.fillStyle = skinObj.hatColor || '#1a1a1a';
            ctx.beginPath(); ctx.ellipse(p.x, headY - 5*s, 30*s, 8*s, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(p.x, headY - 15*s, 10*s, Math.PI, 0); ctx.fill();
        }
        else if (skinObj.headAccessory === 'crown') {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath(); ctx.moveTo(p.x-8*s, headY-10*s); ctx.lineTo(p.x-4*s, headY-18*s); ctx.lineTo(p.x, headY-10*s);
            ctx.lineTo(p.x+4*s, headY-18*s); ctx.lineTo(p.x+8*s, headY-10*s); ctx.lineTo(p.x+8*s, headY-5*s); ctx.lineTo(p.x-8*s, headY-5*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'wizard_hat') {
            ctx.fillStyle = skinObj.hatColor || '#000080';
            ctx.beginPath(); ctx.moveTo(p.x-10*s, headY-5*s); ctx.lineTo(p.x+10*s, headY-5*s); ctx.lineTo(p.x, headY-30*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'chef_hat') {
             ctx.fillStyle = '#FFF'; ctx.fillRect(p.x-8*s, headY-25*s, 16*s, 15*s);
        }
        else if (skinObj.headAccessory === 'hat') {
             ctx.fillStyle = skinObj.hatColor || '#5D4037';
             ctx.beginPath(); ctx.ellipse(p.x, headY - 5*s, headRadius * 1.8, 4*s, 0, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x, headY - 10*s, headRadius * 0.9, Math.PI, 0); ctx.fill();
        }
        else if (skinObj.headAccessory === 'helmet') {
             ctx.fillStyle = skinObj.hatColor || '#87CEEB';
             ctx.beginPath(); ctx.arc(p.x, headY, headRadius + 1*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'horns') {
             ctx.fillStyle = 'red';
             ctx.beginPath(); ctx.moveTo(p.x-5*s, headY-10*s); ctx.lineTo(p.x-8*s, headY-18*s); ctx.lineTo(p.x-2*s, headY-10*s); ctx.fill();
             ctx.beginPath(); ctx.moveTo(p.x+5*s, headY-10*s); ctx.lineTo(p.x+8*s, headY-18*s); ctx.lineTo(p.x+2*s, headY-10*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'halo') {
             ctx.strokeStyle='#FFD700'; ctx.lineWidth=2*s; ctx.beginPath(); ctx.ellipse(p.x, headY-15*s, 8*s, 3*s, 0, 0, Math.PI*2); ctx.stroke();
        }
        else if (skinObj.headAccessory === 'beanie') {
             ctx.fillStyle = skinObj.hatColor || '#FF0000'; ctx.fillRect(p.x-10*s, headY-12*s, 20*s, 6*s);
        }
        else if (skinObj.headAccessory === 'red_nose') {
             ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(p.x, headY, 3*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'eyepatch') {
             ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(p.x+3*s, headY-2*s, 3*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'laurel') {
            ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 2*s;
            ctx.beginPath(); ctx.arc(p.x, headY - 5*s, headRadius * 1.1, Math.PI, 0); ctx.stroke();
        }
        else if (skinObj.headAccessory === 'gold_bands') {
             ctx.fillStyle = '#FFD700';
             ctx.fillRect(p.x - 10*s, headY - 10*s, 20*s, 5*s);
             ctx.fillStyle = '#000080';
             ctx.fillRect(p.x - 10*s, headY - 10*s, 5*s, 5*s);
             ctx.fillRect(p.x + 5*s, headY - 10*s, 5*s, 5*s);
        }

        if (skinObj.headDetail === 'tattoo_stripe') {
             ctx.strokeStyle = '#FF0000'; ctx.lineWidth = 3*s;
             ctx.beginPath(); ctx.moveTo(p.x - 2*s, headY - 12*s); ctx.lineTo(p.x - 4*s, headY + 10*s); ctx.stroke();
        }

        if (skinObj.headDetail === 'visor') {
             ctx.fillStyle = '#FFD700';
             ctx.fillRect(p.x - 10*s, headY - 5*s, 20*s, 6*s);
        }

        // Back Props (Cape, Wings, etc.)
        if (skinObj.backAccessory === 'cape') {
            ctx.fillStyle = skinObj.backColor || '#000';
            ctx.fillRect(p.x - bodyW/1.5, torsoY + 5*s, bodyW*1.3, bodyH*0.8);
        }
        if (skinObj.backAccessory === 'wings') {
            ctx.fillStyle = skinObj.backColor || '#FFF';
            ctx.beginPath(); ctx.ellipse(p.x - 20*s, torsoY + 10*s, 10*s, 20*s, -0.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(p.x + 20*s, torsoY + 10*s, 10*s, 20*s, 0.5, 0, Math.PI*2); ctx.fill();
        }
        if (skinObj.backAccessory === 'backpack') {
             ctx.fillStyle = skinObj.backColor || '#555';
             ctx.fillRect(p.x - bodyW/2, torsoY + 10*s, bodyW, bodyH*0.6);
             // Straps
             ctx.fillStyle = '#5D4037';
             ctx.fillRect(p.x - bodyW/2, torsoY + 15*s, bodyW, 5*s);
        }

        if (skinObj.backProp === 'quiver') {
             ctx.fillStyle = '#8B4513';
             ctx.beginPath(); ctx.moveTo(p.x + 5*s, torsoY); ctx.lineTo(p.x - 10*s, torsoY + 30*s); ctx.lineTo(p.x - 5*s, torsoY + 30*s); ctx.lineTo(p.x + 10*s, torsoY); ctx.fill();
             // Arrows
             ctx.fillStyle = '#FFF';
             ctx.beginPath(); ctx.arc(p.x + 8*s, torsoY - 5*s, 2*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x + 5*s, torsoY - 8*s, 2*s, 0, Math.PI*2); ctx.fill();
        }
        if (skinObj.backProp === 'spartan_gear') {
             // Shield on back? Or just shoulder pad? Let's do a shoulder pad/strap
             ctx.fillStyle = '#8B4513'; // Leather strap
             ctx.beginPath(); ctx.moveTo(p.x + bodyW/2, torsoY); ctx.lineTo(p.x - bodyW/2, torsoY + bodyH); ctx.lineTo(p.x - bodyW/2 + 5*s, torsoY + bodyH); ctx.lineTo(p.x + bodyW/2 + 5*s, torsoY); ctx.fill();
        }

        // New Props
        if (skinObj.backProp) {
             const bp = skinObj.backProp;
             const centerX = p.x;
             const centerY = torsoY + bodyH * 0.4;

             if (bp === 'axe') {
                 ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 4*s;
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 ctx.fillStyle = '#AAA';
                 ctx.beginPath();
                 ctx.moveTo(centerX - 15*s, centerY - 15*s);
                 ctx.lineTo(centerX - 20*s, centerY - 20*s);
                 ctx.quadraticCurveTo(centerX - 10*s, centerY - 25*s, centerX - 5*s, centerY - 15*s);
                 ctx.fill();
             }
             if (bp === 'guitar') {
                 ctx.fillStyle = '#8B4513';
                 ctx.beginPath();
                 ctx.ellipse(centerX, centerY, 12*s, 18*s, -0.2, 0, Math.PI*2);
                 ctx.fill();
                 ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(centerX, centerY, 5*s, 0, Math.PI*2); ctx.fill();
                 ctx.fillStyle = '#5D4037';
                 ctx.fillRect(centerX - 3*s, centerY - 30*s, 6*s, 20*s);
             }
             if (bp === 'oxygen_tank') {
                 ctx.fillStyle = '#FFF'; ctx.strokeStyle = '#AAA'; ctx.lineWidth = 1*s;
                 ctx.fillRect(centerX - 12*s, centerY - 15*s, 24*s, 35*s);
                 ctx.strokeRect(centerX - 12*s, centerY - 15*s, 24*s, 35*s);
                 ctx.strokeStyle = '#CCC'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX, centerY - 15*s); ctx.quadraticCurveTo(centerX, centerY - 25*s, centerX - 10*s, centerY - 20*s); ctx.stroke();
             }
             if (bp === 'katanas') {
                 ctx.strokeStyle = '#333'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX + 15*s, centerY - 15*s); ctx.lineTo(centerX - 15*s, centerY + 15*s); ctx.stroke();
                 ctx.fillStyle = '#000';
                 ctx.fillRect(centerX - 18*s, centerY - 18*s, 5*s, 5*s);
                 ctx.fillRect(centerX + 13*s, centerY - 18*s, 5*s, 5*s);
             }
             if (bp === 'sword') {
                 ctx.strokeStyle = '#555'; ctx.lineWidth = 4*s;
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(centerX - 15*s, centerY - 15*s, 5*s, 0, Math.PI*2); ctx.fill();
             }
             if (bp === 'hockey_sticks') {
                 ctx.strokeStyle = '#D2B48C'; ctx.lineWidth = 3*s; 
                 ctx.beginPath(); ctx.moveTo(centerX - 10*s, centerY - 20*s); ctx.lineTo(centerX + 10*s, centerY + 20*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX + 10*s, centerY - 20*s); ctx.lineTo(centerX - 10*s, centerY + 20*s); ctx.stroke();
                 ctx.fillStyle = '#000'; 
                 ctx.fillRect(centerX + 8*s, centerY + 18*s, 8*s, 4*s);
                 ctx.fillRect(centerX - 16*s, centerY + 18*s, 8*s, 4*s);
             }
             if (bp === 'staff') {
                 ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX + 15*s, centerY - 30*s); ctx.lineTo(centerX - 15*s, centerY + 30*s); ctx.stroke();
                 // Orb (Optimized)
                 const orbX = centerX + 15*s;
                 const orbY = centerY - 30*s;
                 const orbR = 5*s;
                 const glowR = orbR + 15;
                 const orbGrad = ctx.createRadialGradient(orbX, orbY, 0, orbX, orbY, glowR);
                 orbGrad.addColorStop(0, '#00FFFF');
                 orbGrad.addColorStop(orbR/glowR, '#00FFFF');
                 orbGrad.addColorStop(1, 'rgba(0, 255, 255, 0)');
                 ctx.fillStyle = orbGrad;
                 ctx.beginPath(); ctx.arc(orbX, orbY, glowR, 0, Math.PI*2); ctx.fill();
             }
             if (bp === 'windup_key') {
                 ctx.strokeStyle = '#C0C0C0'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(centerX, centerY + 10*s); ctx.stroke();
                 ctx.lineWidth = 2*s;
                 ctx.beginPath(); ctx.arc(centerX - 5*s, centerY, 5*s, 0, Math.PI*2); ctx.stroke();
                 ctx.beginPath(); ctx.arc(centerX + 5*s, centerY, 5*s, 0, Math.PI*2); ctx.stroke();
             }
             if (bp === 'barrel') {
                 ctx.fillStyle = '#8B4513'; ctx.strokeStyle = '#000'; ctx.lineWidth = 2*s;
                 ctx.fillRect(centerX - 12*s, centerY - 15*s, 24*s, 30*s);
                 ctx.strokeRect(centerX - 12*s, centerY - 15*s, 24*s, 30*s);
                 ctx.beginPath(); ctx.moveTo(centerX - 12*s, centerY - 5*s); ctx.lineTo(centerX + 12*s, centerY - 5*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX - 12*s, centerY + 5*s); ctx.lineTo(centerX + 12*s, centerY + 5*s); ctx.stroke();
             }
             if (bp === 'basket') {
                 ctx.fillStyle = '#D2B48C';
                 // Woven texture hint
                 ctx.fillRect(centerX - 10*s, centerY - 10*s, 20*s, 20*s);
                 ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 1*s;
                 ctx.strokeRect(centerX - 10*s, centerY - 10*s, 20*s, 20*s);
                 ctx.beginPath(); ctx.moveTo(centerX, centerY-10*s); ctx.lineTo(centerX, centerY+10*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX-10*s, centerY); ctx.lineTo(centerX+10*s, centerY); ctx.stroke();
                 // Eggs?
                 ctx.fillStyle = '#FFC0CB'; ctx.beginPath(); ctx.arc(centerX - 5*s, centerY - 12*s, 4*s, 0, Math.PI*2); ctx.fill();
                 ctx.fillStyle = '#00FFFF'; ctx.beginPath(); ctx.arc(centerX + 5*s, centerY - 12*s, 4*s, 0, Math.PI*2); ctx.fill();
             }
        }

        // Number
        if (skinObj.number) {
            ctx.fillStyle = skinObj.numberColor || "#FFF";
            ctx.font = `bold ${12 * s}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText(skinObj.number, p.x, torsoY + bodyH * 0.6);
        }

        // Shot Meter
        if (state === 'JUMPING') {
            const style = getCurrentStyle();
            let maxVz = (style.modifiers.jumpVelocity !== undefined) ? style.modifiers.jumpVelocity : 9;
            if (maxVz <= 0.5) maxVz = 9;

            const curVz = getCurrentVz();
            const targetVz = getReleaseTargetVz(maxVz);
            const dist = maxVz - targetVz;

            // Reversal Logic: Fill to target (1.0), then empty
            let progress = 1.0 - (Math.abs(curVz - targetVz) / dist);
            progress = Math.max(0, Math.min(1, progress));

            const groundY = p.y + (player3D.z * s);
            const meterY = groundY - (130 * s * sizeMod.h);
            const cx = p.x + (60 * s); const radius = 50 * s;

            const thresh = calculateShotThreshold();
            const greenWidth = thresh / dist;

            // Green zone at the top (100%)
            let gStart = 1.0 - greenWidth;
            let gEnd = 1.0;
            gStart = Math.max(0, gStart);

            if (playerData.meterEnabled) {
                 drawShotMeter(cx, meterY, radius * (playerData.meterScale || 1.0), s, progress, gStart, playerData.meterShape || 'arc', gEnd);
            }
        }
    }

    let g_cachedSkinId = null;
    let g_cachedSkinObj = null;

    function drawPlayer(p) {
        if (!p) return;
        const s = p.scale;
        const skin = playerData.currentSkin;

        let skinObj;
        if (skin === g_cachedSkinId && g_cachedSkinObj) {
            skinObj = g_cachedSkinObj;
        } else {
            skinObj = SKINS_DB.find(x => x.id === skin);
            if(!skinObj) skinObj = SKINS_DB[0];
            g_cachedSkinId = skin;
            g_cachedSkinObj = skinObj;
        }

        const isMechanical = isMechanicalSkin(skinObj.id);
        const currentAnimal = skinObj.animal;
        
        if (currentAnimal === 'human') {
            drawRealisticHuman(p, s, skinObj);
            return;
        }

        let sizeMod = { w: 1, h: 1, head: 1, stance: 1.0, limbLen: 1.0, armWidth: 1.0, legWidth: 1.0 };
        switch(currentAnimal) {
            case 'rat': sizeMod = { w: 0.7, h: 0.7, head: 0.8, stance: 0.8, limbLen: 0.85 }; break;
            case 'cat': sizeMod = { w: 0.8, h: 0.8, head: 0.9, stance: 0.9, limbLen: 0.9 }; break;
            case 'rabbit': sizeMod = { w: 0.8, h: 0.8, head: 0.9, stance: 0.9, limbLen: 0.9 }; break;
            case 'dog': sizeMod = { w: 1.0, h: 1.0, head: 1.0, stance: 1.0, limbLen: 1.0 }; break;
            case 'moose': sizeMod = { w: 1.2, h: 1.3, head: 1.1, stance: 1.1, limbLen: 1.1 }; break;
            case 'bear': sizeMod = { w: 1.4, h: 1.3, head: 1.2, stance: 1.6, limbLen: 0.9, armWidth: 1.3, legWidth: 1.3 }; break;
            case 'human': sizeMod = { w: 0.9, h: 1.1, head: 0.9, stance: 1.0, limbLen: 1.0 }; break;
            case 'fox': sizeMod = { w: 0.9, h: 0.9, head: 0.95, stance: 0.95, limbLen: 0.95 }; break;
            case 'wolf': sizeMod = { w: 1.1, h: 1.1, head: 1.1, stance: 1.05, limbLen: 1.05 }; break;
            case 'lion': sizeMod = { w: 1.3, h: 1.2, head: 1.25, stance: 1.2, limbLen: 1.05 }; break;
            case 'tiger': sizeMod = { w: 1.3, h: 1.2, head: 1.2, stance: 1.2, limbLen: 1.05 }; break;
            case 'pig': sizeMod = { w: 1.1, h: 0.9, head: 1.0, stance: 1.5, limbLen: 0.8, armWidth: 1.2, legWidth: 1.2 }; break;
            case 'cow': sizeMod = { w: 1.3, h: 1.3, head: 1.2, stance: 1.5, limbLen: 0.9 }; break;
            case 'monkey': sizeMod = { w: 0.85, h: 0.9, head: 0.9, stance: 1.0, limbLen: 1.2 }; break;
            case 'penguin': sizeMod = { w: 1.0, h: 0.8, head: 0.9, stance: 1.1, limbLen: 0.7 }; break;
        }

        // Fill defaults if missing
        if (!sizeMod.armWidth) sizeMod.armWidth = sizeMod.w;
        if (!sizeMod.legWidth) sizeMod.legWidth = sizeMod.w;

        // Determine if Furry
        let isFurry = !skin.includes('robot') && !skin.includes('astronaut') && !skin.includes('alien') && !skin.includes('ninja');
        if (currentAnimal === 'human') isFurry = false;
        if (currentAnimal === 'penguin') isFurry = false; // Smooth feathers

        // 1. Setup Base Colors
        let furColor = '#555', tailColor = '#FFC0CB', torsoColor = '#555', legColor = '#555', armColor = '#555';
        let thighColor = '#555', calfColor = '#555';
        let bellyColor = null, hasSpots = false, hasBlackEars = false;

        if (skin === 'bear_panda') hasBlackEars = true;

        if(currentAnimal === 'rat') { furColor = '#696969'; tailColor = '#FFC0CB'; }
        else if(currentAnimal === 'cat') { furColor = '#808080'; tailColor = '#808080'; }
        else if(currentAnimal === 'dog') { furColor = '#8B4513'; tailColor = '#8B4513'; }
        else if(currentAnimal === 'bear') { furColor = '#4B3621'; tailColor = '#4B3621'; }
        else if(currentAnimal === 'rabbit') { furColor = '#fff'; tailColor = '#fff'; }
        else if(currentAnimal === 'moose') { furColor = '#5D4037'; tailColor = '#5D4037'; }
        else if(currentAnimal === 'fox') { furColor = '#D2691E'; tailColor = '#D2691E'; }
        else if(currentAnimal === 'wolf') { furColor = '#808080'; tailColor = '#808080'; }
        else if(currentAnimal === 'lion') { furColor = '#DAA520'; tailColor = '#DAA520'; }
        else if(currentAnimal === 'tiger') { furColor = '#FFA500'; tailColor = '#FFA500'; }
        else if(currentAnimal === 'pig') { furColor = '#FFC0CB'; tailColor = '#FFC0CB'; }
        else if(currentAnimal === 'cow') { furColor = '#FFF'; tailColor = '#FFF'; }
        else if(currentAnimal === 'monkey') { furColor = '#8B4513'; tailColor = '#8B4513'; }
        else if(currentAnimal === 'penguin') { furColor = '#000'; tailColor = '#000'; }
        else if(currentAnimal === 'human') {
            furColor = skinObj.skinTone || '#8d5524';
            tailColor = 'transparent';
        }

        // 2. Apply Skin Overrides (Data Driven)
        // Biological overrides first
        if (skinObj.furColor) { furColor = skinObj.furColor; tailColor = skinObj.furColor; }
        if (skinObj.hasSpots) hasSpots = true;

        if (skin.includes('alien')) { furColor = '#32CD32'; tailColor = '#32CD32'; }
        if (skin.includes('zombie')) { furColor = '#98FB98'; }
        if (skin.includes('robot')) { furColor = '#C0C0C0'; }

        // Default clothes to fur color (naked)
        torsoColor = furColor; legColor = furColor; armColor = furColor;
        thighColor = legColor; calfColor = legColor;

        // Clothing overrides
        torsoColor = skinObj.jerseyColor || furColor;
        thighColor = skinObj.shortsColor || furColor;
        calfColor = furColor; // Default exposed calf

        // Arms: Default to fur, check for sleeves
        armColor = furColor;
        if (skinObj.sleeveColor) armColor = skinObj.sleeveColor;

        // Legs: If "trousers" (long pants), calf follows thigh color
        if (skinObj.legType === 'pants') calfColor = thighColor;

        // Panda Logic (Black limbs)
        if (skinObj.legType === 'panda_limbs') {
            legColor = '#000'; thighColor = '#000'; calfColor = '#000'; armColor = '#000';
        }

        // 0. Calculate Arm Config EARLY
        const currentStyle = playerData.currentStyle || 'classic';
        const anim = ANIM_DATA[currentStyle] || ANIM_DATA['classic'];
        const idle = DEFAULT_IDLE;
        const lerp = (a, b, t) => a + (b - a) * t;

        // Calculate generic (Right-Handed) angles first
        let r_la, r_ra, r_lfa, r_rfa, r_w;

        if (state === 'SHOOTING') {
            r_la = anim.release.la; r_ra = anim.release.ra;
            r_lfa = anim.release.lfa; r_rfa = anim.release.rfa;
            r_w = anim.release.w;
        } else if (state === 'JUMPING') {
            let lift = Math.max(0, (9 - getCurrentVz()) / 9);
            lift = Math.min(1.0, lift); // Clamp
            const startPose = anim.ready || idle;
            const lerpAngle = (a, b, t) => {
                if (Math.abs(b - a) > Math.PI) {
                    if (b > a) a += 2 * Math.PI;
                    else b += 2 * Math.PI;
                }
                return a + (b - a) * t;
            };
            r_la = lerpAngle(startPose.la, anim.set.la, lift);
            r_ra = lerpAngle(startPose.ra, anim.set.ra, lift);
            r_lfa = lerpAngle(startPose.lfa, anim.set.lfa, lift);
            r_rfa = lerpAngle(startPose.rfa, anim.set.rfa, lift);
            r_w = lerp(startPose.w, anim.set.w, lift);
        } else {
            r_la = idle.la; r_ra = idle.ra;
            r_lfa = idle.lfa; r_rfa = idle.rfa;
            r_w = idle.w;
        }

        let leftArmAngle, rightArmAngle, leftForeArmAngle, rightForeArmAngle, wristAngle;
        const isLefty = playerData.isLefty;
        if (isLefty) {
            leftArmAngle = Math.PI - r_ra; rightArmAngle = Math.PI - r_la;
            leftForeArmAngle = Math.PI - r_rfa; rightForeArmAngle = Math.PI - r_lfa;
            wristAngle = -r_w;
        } else {
            leftArmAngle = r_la; rightArmAngle = r_ra;
            leftForeArmAngle = r_lfa; rightForeArmAngle = r_rfa;
            wristAngle = r_w;
        }

        let bodyW = 20 * s * sizeMod.w; let bodyH = 40 * s * sizeMod.h;
        if(currentAnimal === 'bear') bodyW = 30 * s * sizeMod.w;

        let legLen = 30 * s * sizeMod.h * (sizeMod.limbLen || 1.0);
        let torsoY = p.y - legLen - bodyH;
        let headY = torsoY - (10 * s * sizeMod.head);
        let headRadius = 12 * s * sizeMod.head;

        // Super Saiyan Aura
        if (currentStreak >= 10) {
             const hue = getStreakFireHue(currentStreak);
             ctx.save();
             // Outer Glow
             ctx.shadowBlur = 30 * s;
             ctx.shadowColor = `hsl(${hue}, 100%, 60%)`;
             ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.2)`;
             ctx.beginPath();
             ctx.ellipse(p.x, torsoY + bodyH*0.5, bodyW * 2.5, bodyH * 2.0, 0, 0, Math.PI*2);
             ctx.fill();
             // Inner Core
             ctx.shadowBlur = 15 * s;
             ctx.fillStyle = `hsla(${hue}, 100%, 80%, 0.3)`;
             ctx.beginPath();
             ctx.ellipse(p.x, torsoY + bodyH*0.5, bodyW * 1.5, bodyH * 1.5, 0, 0, Math.PI*2);
             ctx.fill();
             ctx.restore();
        }

        let shoulderY = torsoY + (5*s);
        // Stance modifier for shoulder width and hip width
        const stanceMod = sizeMod.stance || 1.0;
        let leftShoulderX = p.x - 12*s * stanceMod; let rightShoulderX = p.x + 12*s * stanceMod;

        let armLenMod = sizeMod.limbLen || 1.0;
        if (currentAnimal === 'bear') armLenMod = 0.95; // Bears have slightly shorter arms but not too short to break shooting
        let upperArmLen = 20 * s * sizeMod.h * 1.05 * armLenMod; let foreArmLen = 20 * s * sizeMod.h * 1.05 * armLenMod;

        const drawSegmentedArm = (sx, sy, isRight, angle1, angle2) => {
            const armFurry = isFurry && (armColor === furColor);
            const seedBase = isRight ? 10 : 20;
            const isShootingSide = (isLefty && !isRight) || (!isLefty && isRight);

            let thisUpperColor = armColor;
            let thisForeColor = armColor;
            let activeSleeveColor = null;

            // T-Shirt Logic
            if(skinObj.jerseyType === 'tshirt') {
                thisUpperColor = torsoColor;
            }

            // Sleeve Logic (Physical side based)
            if(isRight && skinObj.sleeveRight) {
                activeSleeveColor = skinObj.sleeveRight;
            }
            if(!isRight && skinObj.sleeveLeft) {
                activeSleeveColor = skinObj.sleeveLeft;
            }

            if (activeSleeveColor) {
                thisForeColor = activeSleeveColor;
            }

            let elbow = getJoint(sx, sy, upperArmLen, angle1);

            // Shoulder Joint (Radius increased to 0.7)
            if(!armFurry) drawJoint(sx, sy, 7*s*sizeMod.armWidth * 0.7, thisUpperColor, isMechanical);
            else drawFuzzyCircle(sx, sy, 7*s*sizeMod.armWidth * 0.7, thisUpperColor, seedBase, s, true);

            // Upper Arm
            drawFuzzyLimb(sx, sy, elbow.x, elbow.y, 6*s*sizeMod.armWidth, thisUpperColor, s, armFurry, seedBase);

            // Arm Sleeve Upper Segment (Mid-Bicep to Elbow)
            if (activeSleeveColor) {
                const midX = (sx + elbow.x) / 2;
                const midY = (sy + elbow.y) / 2;
                drawFuzzyLimb(midX, midY, elbow.x, elbow.y, 6.2*s*sizeMod.armWidth, activeSleeveColor, s, false, seedBase);
            }

            let wrist = getJoint(elbow.x, elbow.y, foreArmLen, angle2);

            // Forearm
            drawFuzzyLimb(elbow.x, elbow.y, wrist.x, wrist.y, 5*s*sizeMod.armWidth, thisForeColor, s, activeSleeveColor ? false : armFurry, seedBase + 1);

            // Elbow Joint (Radius 0.7, Drawn AFTER limbs to cap the connection)
            let elbowColor = thisUpperColor;
            if (activeSleeveColor) {
                elbowColor = activeSleeveColor;
            } else if (thisForeColor === furColor && thisUpperColor !== furColor) {
                elbowColor = thisUpperColor; // Sleeve covers elbow
            } else if (thisUpperColor === furColor) {
                elbowColor = furColor;
            }

            const elbowFurry = activeSleeveColor ? false : armFurry;
            if(!elbowFurry) drawJoint(elbow.x, elbow.y, 6*s*sizeMod.armWidth * 0.7, elbowColor, isMechanical);
            else drawFuzzyCircle(elbow.x, elbow.y, 6*s*sizeMod.armWidth * 0.7, elbowColor, seedBase+2, s, true);

            ctx.save(); ctx.translate(wrist.x, wrist.y); ctx.rotate(angle2 + (isShootingSide ? wristAngle : 0));
            ctx.fillStyle = furColor; ctx.beginPath(); ctx.arc(0, 0, 5*s, 0, Math.PI*2); ctx.fill();
            if (wristAngle > 0.5 && isShootingSide) {
                 if(skin.includes('hockey')) { ctx.strokeStyle='#8B4513'; ctx.lineWidth=3*s; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0, 40*s); ctx.lineTo(10*s, 45*s); ctx.stroke(); }
            }

            // Ball removed (drawn earlier)
            ctx.restore();
        };

        // Arms First (Layer 1) - Arms behind legs
        drawSegmentedArm(leftShoulderX, shoulderY, false, leftArmAngle, leftForeArmAngle);
        drawSegmentedArm(rightShoulderX, shoulderY, true, rightArmAngle, rightForeArmAngle);

        // 0b. Detached Ball Rendering
        drawDetachedBall(p, s, torsoY, bodyH, headY);

        if (playerData.currentStyle === 'airbud' && state === 'SHOOTING') {
             const t = airbudJumpTime;
             const maxT = 30;
             if (t < maxT) {
                 const jumpHeight = 60 * s * sizeMod.h;
                 const nt = t / maxT;
                 const offset = 4 * jumpHeight * nt * (1 - nt);
                 p.y -= offset;
                 torsoY = p.y - legLen - bodyH;
                 headY = torsoY - (10 * s * sizeMod.head);
                 shoulderY = torsoY + (5*s);
                 // Recalculate shoulders
                 leftShoulderX = p.x - 12*s; rightShoulderX = p.x + 12*s;
             }
        }

        // 0c. HELD BALL RENDERING (Layer 0)
        const isDetachedStyle = ['airbud', 'telekinesis'].includes(playerData.currentStyle);
        if (!isDetachedStyle && state !== 'SHOOTING' && state !== 'GAMEOVER') {
             const isRightHand = !isLefty;
             const shootUAngle = isRightHand ? rightArmAngle : leftArmAngle;
             const shootFAngle = isRightHand ? rightForeArmAngle : leftForeArmAngle;
             const shootSX = isRightHand ? rightShoulderX : leftShoulderX;

             let elbow = getJoint(shootSX, shoulderY, upperArmLen, shootUAngle);
             let wrist = getJoint(elbow.x, elbow.y, foreArmLen, shootFAngle);

             let theta = shootFAngle + wristAngle;
             let ballX = wrist.x + Math.cos(theta) * 0 - Math.sin(theta) * 5 * s;
             let ballY = wrist.y + Math.sin(theta) * 0 + Math.cos(theta) * 5 * s;

             drawBallSprite(ballX, ballY, s, (currentStreak >= 5), 0);
        }

        // 2. Legs (Base implementation)
        const baseKneeY = p.y - (legLen * 0.5);
        let lKneeX = p.x - 9*s*stanceMod, lKneeY = baseKneeY;
        let rKneeX = p.x + 9*s*stanceMod, rKneeY = baseKneeY;
        let lFootX = p.x - 10*s*stanceMod, lFootY = p.y;
        let rFootX = p.x + 10*s*stanceMod, rFootY = p.y;

        // Dirk Kick Logic
        if (state === 'JUMPING' && playerData.currentStyle === 'dirk') {
            const lift = Math.min(1.0, Math.max(0, (9 - getCurrentVz()) / 9));
            const kickH = 20 * s * lift;
            const kickW = 15 * s * lift;
            if (playerData.isLefty) {
                 lKneeY -= kickH; lKneeX -= kickW; lFootX -= kickW; lFootY -= kickH*0.8;
            } else {
                 rKneeY -= kickH; rKneeX += kickW; rFootX += kickW; rFootY -= kickH*0.8;
            }
        }


        const legFurry = isFurry && (legColor === furColor);
        const hipX = 8 * s * stanceMod;

        // Hip Joints
        if(!legFurry) {
            drawJoint(p.x - hipX, p.y - legLen, 7*s*sizeMod.legWidth * 0.7, thighColor, isMechanical);
            drawJoint(p.x + hipX, p.y - legLen, 7*s*sizeMod.legWidth * 0.7, thighColor, isMechanical);
        } else {
            drawFuzzyCircle(p.x - hipX, p.y - legLen, 7*s*sizeMod.legWidth * 0.7, thighColor, 10, s, true);
            drawFuzzyCircle(p.x + hipX, p.y - legLen, 7*s*sizeMod.legWidth * 0.7, thighColor, 30, s, true);
        }

        drawFuzzyLimb(p.x - hipX, p.y - legLen, lKneeX, lKneeY, 7*s*sizeMod.legWidth, thighColor, s, legFurry, 1); // Left Thigh
        drawFuzzyLimb(p.x + hipX, p.y - legLen, rKneeX, rKneeY, 7*s*sizeMod.legWidth, thighColor, s, legFurry, 3); // Right Thigh

        // Calves & Socks/Shoes
        const drawLowerLeg = (xTop, yTop, xBot, yBot, isRight) => {
             const calfBaseColor = calfColor;

             // Draw Base Calf
             drawFuzzyLimb(xTop, yTop, xBot, yBot, 6*s*sizeMod.legWidth, calfBaseColor, s, legFurry, isRight?4:2);

             // Knee Joint (Radius 0.7, Drawn AFTER calf but theoretically overlaps thigh bottom)
             // Thigh was drawn before this function.
             if(!legFurry) drawJoint(xTop, yTop, 7*s*sizeMod.legWidth * 0.7, thighColor, isMechanical);
             else drawFuzzyCircle(xTop, yTop, 7*s*sizeMod.legWidth * 0.7, thighColor, isRight?40:20, s, true);

             // Socks & Shoes Overlay
             if(skinObj.socksColor || skinObj.shoesColor) {
                 const shoeH = 5 * s; const sockH = 7 * s;
                 // Calculate local Y relative to the foot Y
                 const ankleY = yBot - shoeH; const sockY = ankleY - sockH;

                 // Interpolate X/Y
                 const getXAtY = (y) => {
                     const t = (y - yTop) / (yBot - yTop);
                     return xTop + (xBot - xTop) * t;
                 };

                 if(skinObj.socksColor) {
                     const sockTopX = getXAtY(sockY);
                     const ankleX = getXAtY(ankleY);
                     drawFuzzyLimb(sockTopX, sockY, ankleX, ankleY, 5.8*s*sizeMod.legWidth, skinObj.socksColor, s, false, 0);
                 }
                 if(skinObj.shoesColor) {
                     const ankleX = getXAtY(ankleY);
                     drawFuzzyLimb(ankleX, ankleY, xBot, yBot, 6*s*sizeMod.legWidth, skinObj.shoesColor, s, false, 0);
                     // Shoe Foot
                     ctx.fillStyle = skinObj.shoesColor;
                     ctx.beginPath(); ctx.ellipse(xBot, yBot + 1*s, 4.5*s, 2.5*s, 0, 0, Math.PI*2); ctx.fill();
                 }
             }
        };

        drawLowerLeg(lKneeX, lKneeY, lFootX, lFootY, false); // Left
        drawLowerLeg(rKneeX, rKneeY, rFootX, rFootY, true); // Right

        // 6. Draw Body (Layer 2)
        const bodyFurry = isFurry && (torsoColor === furColor);
        let bodyOptions = {};

        // Define Body Shapes for Animals
        if (currentAnimal === 'bear') { bodyOptions.bodyShape = 'bear_new'; }
        else if (['rat', 'cat', 'rabbit', 'fox', 'monkey'].includes(currentAnimal)) {
            bodyOptions.bodyShape = 'oval'; // Small animals
        }
        else if (['dog', 'wolf', 'lion', 'tiger'].includes(currentAnimal)) {
            bodyOptions.bodyShape = 'athletic_animal'; // Leaner, standing
        }
        else if (['pig', 'cow', 'moose'].includes(currentAnimal)) {
            bodyOptions.bodyShape = 'round'; // Chunky
            bodyOptions.waistScale = 1.1;
            bodyOptions.roundness = 0.2;
        }

        if (skin === 'bear_panda') bodyOptions.chestStripeColor = '#000';

        // Auto-detect Jersey
        if (!bodyFurry && torsoColor !== furColor && !skinObj.pattern) {
            bodyOptions.isJersey = true;
        }

        drawAnatomicBody(p.x, torsoY, bodyW, bodyH, s, torsoColor, bodyFurry, 40, bodyOptions);

        if(currentAnimal === 'penguin' && torsoColor === furColor) {
             ctx.fillStyle = '#FFF';
             ctx.beginPath(); ctx.ellipse(p.x, torsoY + bodyH * 0.55, bodyW * 0.7, bodyH * 0.4, 0, 0, Math.PI*2); ctx.fill();
        }
        if(skinObj.pattern === 'tiger_stripes') {
             ctx.strokeStyle = '#000'; ctx.lineWidth = 2*s;
             // Body stripes
             ctx.beginPath(); ctx.moveTo(p.x - bodyW/2, torsoY + 10*s); ctx.lineTo(p.x - bodyW/4, torsoY + 15*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x + bodyW/2, torsoY + 10*s); ctx.lineTo(p.x + bodyW/4, torsoY + 15*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x - bodyW/2, torsoY + 25*s); ctx.lineTo(p.x - bodyW/4, torsoY + 30*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x + bodyW/2, torsoY + 25*s); ctx.lineTo(p.x + bodyW/4, torsoY + 30*s); ctx.stroke();
        }
        if(skinObj.pattern === 'cow_spots') {
             ctx.fillStyle = (skin === 'cow_strawberry') ? '#FF69B4' : '#000';
             ctx.beginPath(); ctx.arc(p.x - 5*s, torsoY + 10*s, 6*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x + 8*s, torsoY + 25*s, 5*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x - 2*s, torsoY + 30*s, 4*s, 0, Math.PI*2); ctx.fill();
        }

        if(hasSpots) { ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.x, torsoY + 20*s, 4*s, 0, Math.PI*2); ctx.fill(); }
        if(skin.includes('tabby')) { ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 2*s; ctx.beginPath(); ctx.moveTo(p.x-5*s, torsoY+10*s); ctx.lineTo(p.x+5*s, torsoY+10*s); ctx.stroke(); }
        // Pattern Rendering
        if(skinObj.pattern === 'plaid') {
             ctx.strokeStyle = '#000'; ctx.lineWidth = 1*s;
             ctx.beginPath(); ctx.moveTo(p.x-bodyW/2, torsoY+10*s); ctx.lineTo(p.x+bodyW/2, torsoY+10*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x-bodyW/2, torsoY+20*s); ctx.lineTo(p.x+bodyW/2, torsoY+20*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x-bodyW/2, torsoY+30*s); ctx.lineTo(p.x+bodyW/2, torsoY+30*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x, torsoY); ctx.lineTo(p.x, torsoY+bodyH); ctx.stroke();
        }
        else if(skinObj.pattern === 'stripes') { // Referee or Bandit
             ctx.fillStyle = '#000';
             ctx.fillRect(p.x-5*s, torsoY, 10*s, bodyH); // Center stripe
             ctx.fillRect(p.x-15*s, torsoY, 5*s, bodyH); // Left stripe
             ctx.fillRect(p.x+10*s, torsoY, 5*s, bodyH); // Right stripe
        }
        else if(skinObj.pattern === 'suit') { // Tuxedo button
             ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.x, torsoY + 15*s, 2*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x, torsoY + 25*s, 2*s, 0, Math.PI*2); ctx.fill();
             // Bowtie
             ctx.fillStyle = 'red';
             ctx.beginPath(); ctx.moveTo(p.x, torsoY+5*s); ctx.lineTo(p.x-5*s, torsoY+2*s); ctx.lineTo(p.x-5*s, torsoY+8*s); ctx.fill();
             ctx.beginPath(); ctx.moveTo(p.x, torsoY+5*s); ctx.lineTo(p.x+5*s, torsoY+2*s); ctx.lineTo(p.x+5*s, torsoY+8*s); ctx.fill();
        }
        else if(skinObj.pattern === 'suit_jacket') { // Back view of a suit
             ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 1*s;
             // Center seam (Vent)
             ctx.beginPath(); ctx.moveTo(p.x, torsoY + bodyH * 0.7); ctx.lineTo(p.x, torsoY + bodyH); ctx.stroke();
             // Shoulder seams
             ctx.beginPath();
             ctx.moveTo(p.x - bodyW/2 + 5*s, torsoY + 5*s);
             ctx.quadraticCurveTo(p.x, torsoY + 8*s, p.x + bodyW/2 - 5*s, torsoY + 5*s);
             ctx.stroke();
        }

        // Clothing Details (New Layer)
        if(skinObj.clothingDetail === 'suspenders') {
             ctx.fillStyle = '#1a1a1a'; // Dark suspenders
             // Left
             ctx.fillRect(p.x - bodyW/2 + 2*s, torsoY, 3*s, bodyH);
             // Right
             ctx.fillRect(p.x + bodyW/2 - 5*s, torsoY, 3*s, bodyH);
        }
        if(skinObj.clothingDetail === 'apron_ties') {
             ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2*s;
             ctx.beginPath();
             ctx.moveTo(p.x, torsoY + bodyH*0.6);
             ctx.lineTo(p.x - 10*s, torsoY + bodyH*0.6 + 5*s); // Left hanging
             ctx.moveTo(p.x, torsoY + bodyH*0.6);
             ctx.lineTo(p.x + 10*s, torsoY + bodyH*0.6 + 5*s); // Right hanging
             // Knot
             ctx.fillStyle='#FFF'; ctx.beginPath(); ctx.arc(p.x, torsoY+bodyH*0.6, 3*s, 0, Math.PI*2); ctx.fill();
             ctx.stroke();
        }
        if(skinObj.clothingDetail === 'overalls') {
             ctx.fillStyle = skinObj.shortsColor || '#000080';
             // Bib
             ctx.fillRect(p.x - bodyW*0.3, torsoY + bodyH*0.3, bodyW*0.6, bodyH*0.4);
             // Straps
             ctx.fillRect(p.x - bodyW*0.3, torsoY, bodyW*0.1, bodyH*0.3);
             ctx.fillRect(p.x + bodyW*0.2, torsoY, bodyW*0.1, bodyH*0.3);
        }
        if(skinObj.clothingDetail === 'stitches') {
             ctx.strokeStyle = '#000'; ctx.lineWidth = 1*s;
             // Random stitches
             ctx.beginPath(); ctx.moveTo(p.x-5*s, torsoY+10*s); ctx.lineTo(p.x-5*s, torsoY+15*s); ctx.moveTo(p.x-8*s, torsoY+12*s); ctx.lineTo(p.x-2*s, torsoY+12*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x+5*s, torsoY+25*s); ctx.lineTo(p.x+5*s, torsoY+30*s); ctx.moveTo(p.x+2*s, torsoY+27*s); ctx.lineTo(p.x+8*s, torsoY+27*s); ctx.stroke();
             // Head stitch
             ctx.beginPath(); ctx.moveTo(p.x, headY-headRadius); ctx.lineTo(p.x, headY-headRadius+5*s); ctx.moveTo(p.x-3*s, headY-headRadius+2*s); ctx.lineTo(p.x+3*s, headY-headRadius+2*s); ctx.stroke();
        }

        // 7. Draw Tail (Layer 3)
        if(currentAnimal !== 'bear' && currentAnimal !== 'human' && !skin.includes('astronaut') && !skin.includes('robot')) {
            const tx = p.x; const ty = p.y - legLen - 5*s;
            if (skinObj.tailType === 'devil') {
                ctx.strokeStyle = '#8B0000'; ctx.lineWidth = 4 * s;
                ctx.beginPath(); ctx.moveTo(tx, ty);
                ctx.quadraticCurveTo(tx + 15*s, ty + 5*s, tx + 25*s, ty - 20*s); ctx.stroke();
                // Triangle Tip
                ctx.fillStyle = '#8B0000'; ctx.beginPath();
                const ttx = tx + 25*s, tty = ty - 20*s;
                ctx.moveTo(ttx, tty); ctx.lineTo(ttx - 5*s, tty + 10*s); ctx.lineTo(ttx + 5*s, tty + 10*s); ctx.fill();
            }
            else if (currentAnimal === 'fox' || currentAnimal === 'wolf' || skinObj.tailType === 'multi') {
                // Bushy Tail
                const tailPoints = [
                    {x: tx, y: ty},
                    {x: tx + 15*s, y: ty + 5*s},
                    {x: tx + 30*s, y: ty - 10*s}, // Tip
                    {x: tx + 15*s, y: ty - 15*s}
                ];
                let tColor = tailColor;
                if(skinObj.tailType === 'multi') { // Kitsune
                    for(let k=0; k<3; k++) {
                        const off = (k-1)*10*s;
                        drawFuzzyPath([{x:tx,y:ty},{x:tx+15*s+off,y:ty+5*s},{x:tx+30*s+off,y:ty-10*s},{x:tx+15*s+off,y:ty-15*s}], '#FFD700', s, true, 100+k);
                    }
                } else {
                    drawFuzzyPath(tailPoints, tColor, s, true, 99);
                    // White tip for classic fox
                    if(currentAnimal === 'fox' && skin === 'fox_classic') {
                        const tipPoints = [{x: tx + 20*s, y: ty - 5*s}, {x: tx + 30*s, y: ty - 10*s}, {x: tx + 20*s, y: ty - 12*s}];
                        drawFuzzyPath(tipPoints, '#FFF', s, true, 100);
                    }
                }
            }
            else if (currentAnimal === 'pig') {
                // Curly Tail
                ctx.beginPath(); ctx.strokeStyle = tailColor; ctx.lineWidth = 3 * s;
                ctx.moveTo(tx, ty);
                ctx.bezierCurveTo(tx + 10*s, ty - 5*s, tx + 10*s, ty + 10*s, tx + 20*s, ty);
                ctx.stroke();
            }
            else if (currentAnimal === 'lion' || currentAnimal === 'cow') {
                // Tufted Tail
                ctx.beginPath(); ctx.strokeStyle = tailColor; ctx.lineWidth = 3 * s;
                ctx.moveTo(tx, ty);
                ctx.quadraticCurveTo(tx + 15*s, ty + 10*s, tx + 25*s, ty + 5*s); ctx.stroke();
                // Tuft
                const tuftColor = (currentAnimal === 'lion') ? '#8B4513' : '#000';
                if(currentAnimal === 'cow' && skinObj.furColor === '#8B0000') tuftColor = '#8B0000'; // Highland
                drawFuzzyPath([{x: tx+25*s, y: ty+5*s}, {x: tx+35*s, y: ty+8*s}, {x: tx+35*s, y: ty+2*s}], tuftColor, s, true, 101);
            }
            else if (currentAnimal === 'penguin') {
                // Stubby Tail
                ctx.fillStyle = tailColor;
                ctx.beginPath(); ctx.moveTo(tx, ty); ctx.lineTo(tx + 10*s, ty + 5*s); ctx.lineTo(tx + 5*s, ty + 10*s); ctx.fill();
            }
            else {
                // Standard Thin Tail
                ctx.beginPath(); ctx.strokeStyle = tailColor; ctx.lineWidth = 4 * s;
                ctx.lineCap = 'round'; ctx.moveTo(tx, ty);
                ctx.quadraticCurveTo(tx + 15*s, ty + 5*s, tx + 20*s, ty - 10*s); ctx.stroke();
                if(currentAnimal === 'tiger' || skinObj.pattern === 'tiger_stripes') {
                    // Stripes on tail
                    ctx.strokeStyle = '#000'; ctx.lineWidth = 2*s;
                    ctx.beginPath(); ctx.moveTo(tx+5*s, ty); ctx.lineTo(tx+5*s, ty+3*s); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(tx+10*s, ty); ctx.lineTo(tx+10*s, ty+3*s); ctx.stroke();
                }
            }
        }

        // 8. Draw Head & Ears (Layer 4)
        ctx.fillStyle = (hasBlackEars) ? '#000' : furColor;
        if(skin.includes('alien')) ctx.fillStyle = '#32CD32';

        // EARS & HORNS
        if(currentAnimal === 'rat') {
            drawFuzzyCircle(p.x - 12*s, headY - 5*s, 7*s, ctx.fillStyle, 51, s, isFurry);
            drawFuzzyCircle(p.x + 12*s, headY - 5*s, 7*s, ctx.fillStyle, 52, s, isFurry);
        } else if (currentAnimal === 'cat') {
            const earL = [{x: p.x-5*s, y: headY-8*s}, {x: p.x-15*s, y: headY-20*s}, {x: p.x-15*s, y: headY}];
            const earR = [{x: p.x+5*s, y: headY-8*s}, {x: p.x+15*s, y: headY-20*s}, {x: p.x+15*s, y: headY}];
            drawFuzzyPath(earL, ctx.fillStyle, s, true, 53);
            drawFuzzyPath(earR, ctx.fillStyle, s, true, 54);
        } else if (currentAnimal === 'fox' || currentAnimal === 'wolf') {
            // Pointy Ears
            const h = (currentAnimal === 'wolf') ? 18*s : 22*s;
            const w = (currentAnimal === 'wolf') ? 10*s : 12*s;
            const earL = [{x: p.x-5*s, y: headY-8*s}, {x: p.x-12*s, y: headY-h}, {x: p.x-w-5*s, y: headY-5*s}];
            const earR = [{x: p.x+5*s, y: headY-8*s}, {x: p.x+12*s, y: headY-h}, {x: p.x+w+5*s, y: headY-5*s}];
            drawFuzzyPath(earL, ctx.fillStyle, s, true, 53);
            drawFuzzyPath(earR, ctx.fillStyle, s, true, 54);
            // Inner Ear (White/Pink)
            ctx.fillStyle = (currentAnimal === 'wolf') ? '#AAA' : '#FFF';
            ctx.beginPath(); ctx.moveTo(p.x-8*s, headY-10*s); ctx.lineTo(p.x-12*s, headY-h+5*s); ctx.lineTo(p.x-15*s, headY-10*s); ctx.fill();
            ctx.beginPath(); ctx.moveTo(p.x+8*s, headY-10*s); ctx.lineTo(p.x+12*s, headY-h+5*s); ctx.lineTo(p.x+15*s, headY-10*s); ctx.fill();
        } else if (currentAnimal === 'rabbit') {
             ctx.beginPath(); ctx.ellipse(p.x-8*s, headY-20*s, 5*s, 15*s, -0.2, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.ellipse(p.x+8*s, headY-20*s, 5*s, 15*s, 0.2, 0, Math.PI*2); ctx.fill();
        } else if (currentAnimal === 'bear' || currentAnimal === 'dog' || currentAnimal === 'lion' || currentAnimal === 'tiger' || currentAnimal === 'monkey') {
            let earY = headY - 8*s; let earX = 10*s; let earR = 5*s;
            if(currentAnimal === 'monkey') { earY = headY; earX = 14*s; earR = 4*s; }
            if(currentAnimal === 'lion' || currentAnimal === 'tiger') { earX = 12*s; earR = 6*s; }
            drawFuzzyCircle(p.x - earX, earY, earR, ctx.fillStyle, 55, s, isFurry);
            drawFuzzyCircle(p.x + earX, earY, earR, ctx.fillStyle, 56, s, isFurry);
        } else if (currentAnimal === 'pig' || currentAnimal === 'cow') {
            const earColor = ctx.fillStyle;
            ctx.beginPath(); ctx.ellipse(p.x - 14*s, headY - 2*s, 6*s, 4*s, 0.2, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(p.x + 14*s, headY - 2*s, 6*s, 4*s, -0.2, 0, Math.PI*2); ctx.fill();
        } else if (currentAnimal === 'human') {
            // Human Ears
            ctx.fillStyle = furColor;
            ctx.beginPath(); ctx.ellipse(p.x - 12*s, headY, 3*s, 6*s, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(p.x + 12*s, headY, 3*s, 6*s, 0, 0, Math.PI*2); ctx.fill();
            if(skinObj.hairStyle === 'afro') {
                 ctx.fillStyle = skinObj.hairColor || '#000';
                 ctx.beginPath(); ctx.arc(p.x, headY - 2*s, headRadius * 1.5, 0, Math.PI*2); ctx.fill();
            }
        }
        if(currentAnimal === 'moose') {
            ctx.strokeStyle = '#5D4037'; ctx.lineWidth = 4*s;
            ctx.beginPath(); ctx.moveTo(p.x-10*s, headY-10*s); ctx.lineTo(p.x-30*s, headY-25*s); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(p.x+10*s, headY-10*s); ctx.lineTo(p.x+30*s, headY-25*s); ctx.stroke();
        }
        if(currentAnimal === 'cow') {
            ctx.fillStyle = '#EEE';
            ctx.beginPath(); ctx.moveTo(p.x-5*s, headY-10*s); ctx.quadraticCurveTo(p.x-15*s, headY-20*s, p.x-12*s, headY-25*s); ctx.lineTo(p.x-8*s, headY-15*s); ctx.fill();
            ctx.beginPath(); ctx.moveTo(p.x+5*s, headY-10*s); ctx.quadraticCurveTo(p.x+15*s, headY-20*s, p.x+12*s, headY-25*s); ctx.lineTo(p.x+8*s, headY-15*s); ctx.fill();
        }

        // MANE (Lion)
        if(currentAnimal === 'lion' && skin !== 'lion_scar') {
             ctx.fillStyle = '#8B4513';
             if(skin === 'lion_white') ctx.fillStyle = '#EEE';
             if(skin === 'lion_classic') ctx.fillStyle = '#A0522D';
             drawFuzzyCircle(p.x, headY, headRadius * 1.6, ctx.fillStyle, 61, s, isFurry);
        }

        // Head Circle
        let headColor = furColor;
        if(skin.includes('alien')) headColor = '#32CD32';
        if(currentAnimal === 'penguin') headColor = '#000';
        if(currentAnimal === 'lion' && skin !== 'lion_scar') {
             if(skin === 'lion_white') headColor = '#EEE';
             else if(skin === 'lion_classic') headColor = '#A0522D';
             else headColor = '#8B4513';
        }

        drawFuzzyCircle(p.x, headY, headRadius, headColor, 60, s, isFurry);

        // FOREHEAD MANE (Lion) - Fix baldness
        if(currentAnimal === 'lion' && skin !== 'lion_scar') {
             ctx.fillStyle = '#8B4513';
             if(skin === 'lion_white') ctx.fillStyle = '#EEE';
             if(skin === 'lion_classic') ctx.fillStyle = '#A0522D';
             // Draw a smaller fuzzy circle slightly higher to cover the "bald" spot
             drawFuzzyCircle(p.x, headY - headRadius * 0.5, headRadius * 0.8, ctx.fillStyle, 62, s, isFurry);
        }

        // FACE DETAILS REMOVED - Back View Only

        if(skinObj.pattern === 'tiger_stripes') {
             ctx.strokeStyle = '#000'; ctx.lineWidth = 1*s;
             ctx.beginPath(); ctx.moveTo(p.x, headY - 10*s); ctx.lineTo(p.x, headY - 5*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x - 5*s, headY - 8*s); ctx.lineTo(p.x - 2*s, headY - 4*s); ctx.stroke();
             ctx.beginPath(); ctx.moveTo(p.x + 5*s, headY - 8*s); ctx.lineTo(p.x + 2*s, headY - 4*s); ctx.stroke();
        }

        // Head Details
        if(skinObj.headDetail === 'antenna') {
             ctx.strokeStyle = '#C0C0C0'; ctx.lineWidth = 2*s;
             ctx.beginPath(); ctx.moveTo(p.x, headY - headRadius); ctx.lineTo(p.x, headY - headRadius - 15*s); ctx.stroke();
             ctx.fillStyle = 'red'; ctx.beginPath(); ctx.arc(p.x, headY - headRadius - 15*s, 3*s, 0, Math.PI*2); ctx.fill();
        }
        if(skinObj.headDetail === 'bandana_ties') {
             ctx.fillStyle = 'red';
             ctx.beginPath(); ctx.moveTo(p.x + headRadius, headY);
             ctx.lineTo(p.x + headRadius + 10*s, headY + 5*s);
             ctx.lineTo(p.x + headRadius + 12*s, headY + 15*s);
             ctx.lineTo(p.x + headRadius, headY + 5*s);
             ctx.fill();
        }


        // Head Accessories
        if (skinObj.headAccessory === 'sombrero') {
            ctx.fillStyle = skinObj.hatColor || '#1a1a1a';
            ctx.beginPath(); ctx.ellipse(p.x, headY - 5*s, 30*s, 8*s, 0, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(p.x, headY - 15*s, 10*s, Math.PI, 0); ctx.fill();
        }
        else if (skinObj.headAccessory === 'crown') {
            ctx.fillStyle = '#FFD700';
            ctx.beginPath(); ctx.moveTo(p.x-8*s, headY-10*s); ctx.lineTo(p.x-4*s, headY-18*s); ctx.lineTo(p.x, headY-10*s);
            ctx.lineTo(p.x+4*s, headY-18*s); ctx.lineTo(p.x+8*s, headY-10*s); ctx.lineTo(p.x+8*s, headY-5*s); ctx.lineTo(p.x-8*s, headY-5*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'wizard_hat') {
            ctx.fillStyle = skinObj.hatColor || '#000080';
            ctx.beginPath(); ctx.moveTo(p.x-10*s, headY-5*s); ctx.lineTo(p.x+10*s, headY-5*s); ctx.lineTo(p.x, headY-30*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'chef_hat') {
             ctx.fillStyle = '#FFF'; ctx.fillRect(p.x-8*s, headY-25*s, 16*s, 15*s);
        }
        else if (skinObj.headAccessory === 'helmet') {
             ctx.strokeStyle = skinObj.hatColor || '#87CEEB'; ctx.lineWidth=2*s;
             ctx.beginPath(); ctx.arc(p.x, headY, headRadius-2*s, 0, Math.PI*2); ctx.stroke();
             if(skinObj.hatColor === '#FFF') { // Hockey mask fill
                 ctx.fillStyle='rgba(255,255,255,0.8)'; ctx.fill();
             }
        }
        else if (skinObj.headAccessory === 'horns') {
             ctx.fillStyle = 'red';
             ctx.beginPath(); ctx.moveTo(p.x-5*s, headY-10*s); ctx.lineTo(p.x-8*s, headY-18*s); ctx.lineTo(p.x-2*s, headY-10*s); ctx.fill();
             ctx.beginPath(); ctx.moveTo(p.x+5*s, headY-10*s); ctx.lineTo(p.x+8*s, headY-18*s); ctx.lineTo(p.x+2*s, headY-10*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'halo') {
             ctx.strokeStyle='#FFD700'; ctx.lineWidth=2*s; ctx.beginPath(); ctx.ellipse(p.x, headY-15*s, 8*s, 3*s, 0, 0, Math.PI*2); ctx.stroke();
        }
        else if (skinObj.headAccessory === 'beanie') {
             ctx.fillStyle = skinObj.hatColor || '#FF0000'; ctx.fillRect(p.x-10*s, headY-12*s, 20*s, 6*s);
        }
        else if (skinObj.headAccessory === 'red_nose') {
             ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(p.x, headY, 3*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'ear_muffs') {
             const col = skinObj.hatColor || '#FFF';
             ctx.fillStyle = col;
             ctx.beginPath(); ctx.arc(p.x - headRadius - 2*s, headY, 6*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x + headRadius + 2*s, headY, 6*s, 0, Math.PI*2); ctx.fill();
             ctx.strokeStyle = col; ctx.lineWidth = 3*s;
             ctx.beginPath(); ctx.arc(p.x, headY, headRadius + 4*s, Math.PI, 0); ctx.stroke();
        }
        else if (skinObj.headAccessory === 'collar') {
             ctx.fillStyle = skinObj.hatColor || '#FF0000';
             ctx.fillRect(p.x - headRadius, headY + headRadius - 2*s, headRadius * 2, 4*s);
             ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(p.x, headY + headRadius, 3*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'scarf') {
             ctx.strokeStyle = skinObj.hatColor || '#00008B'; ctx.lineWidth = 6*s;
             ctx.beginPath(); ctx.arc(p.x, headY + headRadius, 6*s, 0, Math.PI, false); ctx.stroke();
             // Dangling part
             ctx.fillStyle = skinObj.hatColor || '#00008B';
             ctx.fillRect(p.x + 4*s, headY + headRadius, 6*s, 15*s);
        }
        else if (skinObj.headAccessory === 'fez') {
             ctx.fillStyle = '#8B0000';
             ctx.beginPath(); ctx.moveTo(p.x - 6*s, headY - 8*s); ctx.lineTo(p.x + 6*s, headY - 8*s); ctx.lineTo(p.x + 4*s, headY - 18*s); ctx.lineTo(p.x - 4*s, headY - 18*s); ctx.fill();
             ctx.strokeStyle = '#FFD700'; ctx.lineWidth = 1*s; ctx.beginPath(); ctx.moveTo(p.x, headY - 18*s); ctx.lineTo(p.x + 2*s, headY - 12*s); ctx.stroke();
        }
        else if (skinObj.headAccessory === 'bow') {
             ctx.fillStyle = skinObj.hatColor || '#FFC0CB';
             ctx.beginPath();
             ctx.ellipse(p.x - 6*s, headY - 8*s, 6*s, 4*s, -0.2, 0, Math.PI*2); ctx.fill();
             ctx.beginPath();
             ctx.ellipse(p.x + 6*s, headY - 8*s, 6*s, 4*s, 0.2, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x, headY - 8*s, 2*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'flower') {
             ctx.fillStyle = '#FF69B4';
             const fx = p.x + headRadius; const fy = headY - 5*s;
             for(let i=0; i<5; i++) {
                 const a = (i/5)*Math.PI*2;
                 ctx.beginPath(); ctx.arc(fx + Math.cos(a)*4*s, fy + Math.sin(a)*4*s, 3*s, 0, Math.PI*2); ctx.fill();
             }
             ctx.fillStyle = '#FFFF00'; ctx.beginPath(); ctx.arc(fx, fy, 2*s, 0, Math.PI*2); ctx.fill();
        }
        else if (skinObj.headAccessory === 'algae') {
             ctx.fillStyle = '#2E8B57';
             drawFuzzyPath([{x:p.x-5*s,y:headY-10*s},{x:p.x+5*s,y:headY-12*s},{x:p.x+8*s,y:headY-5*s},{x:p.x-8*s,y:headY-4*s}], '#2E8B57', s, true, 200);
        }
        else if (skinObj.headAccessory === 'hat') {
             ctx.fillStyle = skinObj.hatColor || '#5D4037';
             // Brim
             ctx.beginPath(); ctx.ellipse(p.x, headY - 5*s, headRadius * 1.8, 4*s, 0, 0, Math.PI*2); ctx.fill();
             // Top
             ctx.beginPath(); ctx.arc(p.x, headY - 10*s, headRadius * 0.9, Math.PI, 0); ctx.fill();
        }
        else if (skinObj.headAccessory === 'top_hat') {
             ctx.fillStyle = '#111';
             // Brim
             ctx.beginPath(); ctx.ellipse(p.x, headY - 5*s, headRadius * 1.5, 3*s, 0, 0, Math.PI*2); ctx.fill();
             // Cylinder
             ctx.fillRect(p.x - headRadius * 0.8, headY - 25*s, headRadius * 1.6, 20*s);
        }
        else if (skinObj.headAccessory === 'headband') {
             ctx.fillStyle = skinObj.hatColor || '#FF0000'; // Default red
             if(skinObj.hatColor === '#FFF' && skin.includes('tiger_white')) ctx.fillStyle = '#000'; // Contrast for white tiger
             ctx.fillRect(p.x - headRadius, headY - 8*s, headRadius * 2, 6*s);
             // Knot/Tails
             ctx.beginPath(); ctx.moveTo(p.x + headRadius, headY - 5*s); ctx.lineTo(p.x + headRadius + 10*s, headY + 5*s); ctx.lineTo(p.x + headRadius + 10*s, headY - 5*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'bandana_neck') {
             ctx.fillStyle = '#FF0000';
             ctx.beginPath(); ctx.moveTo(p.x - 10*s, headY + 5*s); ctx.lineTo(p.x, headY + 15*s); ctx.lineTo(p.x + 10*s, headY + 5*s); ctx.fill();
        }
        else if (skinObj.headAccessory === 'feathers') {
             ctx.fillStyle = '#FFF';
             ctx.beginPath(); ctx.ellipse(p.x, headY - 15*s, 4*s, 10*s, 0, 0, Math.PI*2); ctx.fill();
             ctx.strokeStyle = '#000'; ctx.lineWidth = 1*s; ctx.stroke();
             ctx.fillStyle = '#FF0000';
             ctx.beginPath(); ctx.ellipse(p.x, headY - 15*s, 2*s, 5*s, 0, 0, Math.PI*2); ctx.fill();
        }

        // Head Details that act like accessories
        if(skinObj.headDetail === 'mohawk') {
             ctx.fillStyle = skinObj.hairColor || '#000';
             for(let i=0; i<5; i++) {
                 ctx.beginPath(); ctx.arc(p.x, headY - 10*s - (i*4*s), (5-i)*s + 2*s, 0, Math.PI*2); ctx.fill();
             }
        }
        if(skinObj.headDetail === 'visor') {
             ctx.fillStyle = '#FF0000'; ctx.shadowBlur = 5; ctx.shadowColor = '#FF0000';
             ctx.fillRect(p.x - 8*s, headY - 5*s, 16*s, 4*s);
             ctx.shadowBlur = 0;
        }
        if(skinObj.headDetail === 'yellow_neck') {
             ctx.fillStyle = '#FFD700';
             ctx.beginPath(); ctx.arc(p.x, headY + 5*s, 8*s, 0, Math.PI, false); ctx.fill();
        }

        // 11. Back Props (New Layer - Drawn on top of body for Back View)
        // Existing Back Accessories moved here
        if (skinObj.backAccessory === 'cape') {
            ctx.fillStyle = skinObj.backColor || '#000';
            ctx.fillRect(p.x - bodyW/1.5, torsoY + 5*s, bodyW*1.3, bodyH*0.8);
        }
        if (skinObj.backAccessory === 'wings') {
            ctx.fillStyle = skinObj.backColor || '#FFF';
            ctx.beginPath(); ctx.ellipse(p.x - 20*s, torsoY + 10*s, 10*s, 20*s, -0.5, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(p.x + 20*s, torsoY + 10*s, 10*s, 20*s, 0.5, 0, Math.PI*2); ctx.fill();
        }
        if (skinObj.backAccessory === 'backpack') {
             ctx.fillStyle = skinObj.backColor || '#555';
             ctx.fillRect(p.x - bodyW/2, torsoY + 10*s, bodyW, bodyH*0.6);
        }

        // New Props
        if (skinObj.backProp) {
             const bp = skinObj.backProp;
             const centerX = p.x;
             const centerY = torsoY + bodyH * 0.4;

             if (bp === 'axe') {
                 // Axe handle diagonal
                 ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 4*s;
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 // Axe head
                 ctx.fillStyle = '#AAA';
                 ctx.beginPath();
                 ctx.moveTo(centerX - 15*s, centerY - 15*s);
                 ctx.lineTo(centerX - 20*s, centerY - 20*s);
                 ctx.quadraticCurveTo(centerX - 10*s, centerY - 25*s, centerX - 5*s, centerY - 15*s);
                 ctx.fill();
             }
             if (bp === 'guitar') {
                 // Guitar Body
                 ctx.fillStyle = '#8B4513';
                 ctx.beginPath();
                 ctx.ellipse(centerX, centerY, 12*s, 18*s, -0.2, 0, Math.PI*2);
                 ctx.fill();
                 ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(centerX, centerY, 5*s, 0, Math.PI*2); ctx.fill();
                 // Neck
                 ctx.fillStyle = '#5D4037';
                 ctx.fillRect(centerX - 3*s, centerY - 30*s, 6*s, 20*s);
             }
             if (bp === 'oxygen_tank') {
                 ctx.fillStyle = '#FFF'; ctx.strokeStyle = '#AAA'; ctx.lineWidth = 1*s;
                 ctx.fillRect(centerX - 12*s, centerY - 15*s, 24*s, 35*s);
                 ctx.strokeRect(centerX - 12*s, centerY - 15*s, 24*s, 35*s);
                 // Tubes
                 ctx.strokeStyle = '#CCC'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX, centerY - 15*s); ctx.quadraticCurveTo(centerX, centerY - 25*s, centerX - 10*s, centerY - 20*s); ctx.stroke();
             }
             if (bp === 'katanas') {
                 ctx.strokeStyle = '#333'; ctx.lineWidth = 3*s;
                 // X shape
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX + 15*s, centerY - 15*s); ctx.lineTo(centerX - 15*s, centerY + 15*s); ctx.stroke();
                 // Hilts
                 ctx.fillStyle = '#000';
                 ctx.fillRect(centerX - 18*s, centerY - 18*s, 5*s, 5*s);
                 ctx.fillRect(centerX + 13*s, centerY - 18*s, 5*s, 5*s);
             }
             if (bp === 'sword') {
                 ctx.strokeStyle = '#555'; ctx.lineWidth = 4*s;
                 ctx.beginPath(); ctx.moveTo(centerX - 15*s, centerY - 15*s); ctx.lineTo(centerX + 15*s, centerY + 15*s); ctx.stroke();
                 // Hilt (Basket)
                 ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(centerX - 15*s, centerY - 15*s, 5*s, 0, Math.PI*2); ctx.fill();
             }
             if (bp === 'hockey_sticks') {
                 ctx.strokeStyle = '#D2B48C'; ctx.lineWidth = 3*s; // Wood
                 // Crossed
                 ctx.beginPath(); ctx.moveTo(centerX - 10*s, centerY - 20*s); ctx.lineTo(centerX + 10*s, centerY + 20*s); ctx.stroke();
                 ctx.beginPath(); ctx.moveTo(centerX + 10*s, centerY - 20*s); ctx.lineTo(centerX - 10*s, centerY + 20*s); ctx.stroke();
                 // Blades at bottom
                 ctx.fillStyle = '#000'; // Tape
                 ctx.fillRect(centerX + 8*s, centerY + 18*s, 8*s, 4*s);
                 ctx.fillRect(centerX - 16*s, centerY + 18*s, 8*s, 4*s);
             }
             if (bp === 'staff') {
                 ctx.strokeStyle = '#8B4513'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX + 15*s, centerY - 30*s); ctx.lineTo(centerX - 15*s, centerY + 30*s); ctx.stroke();
                 // Orb (Optimized)
                 const orbX = centerX + 15*s;
                 const orbY = centerY - 30*s;
                 const orbR = 5*s;
                 const glowR = orbR + 15;
                 const orbGrad = ctx.createRadialGradient(orbX, orbY, 0, orbX, orbY, glowR);
                 orbGrad.addColorStop(0, '#00FFFF');
                 orbGrad.addColorStop(orbR/glowR, '#00FFFF');
                 orbGrad.addColorStop(1, 'rgba(0, 255, 255, 0)');
                 ctx.fillStyle = orbGrad;
                 ctx.beginPath(); ctx.arc(orbX, orbY, glowR, 0, Math.PI*2); ctx.fill();
             }
             if (bp === 'windup_key') {
                 ctx.strokeStyle = '#C0C0C0'; ctx.lineWidth = 3*s;
                 ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(centerX, centerY + 10*s); ctx.stroke();
                 // Handle
                 ctx.lineWidth = 2*s;
                 ctx.beginPath(); ctx.arc(centerX - 5*s, centerY, 5*s, 0, Math.PI*2); ctx.stroke();
                 ctx.beginPath(); ctx.arc(centerX + 5*s, centerY, 5*s, 0, Math.PI*2); ctx.stroke();
             }
        }

        // 9. Jersey Number (Layer 5)
        if(!skin.includes('alien') && !skin.includes('robot') && skinObj.number) {
            ctx.fillStyle = skinObj.numberColor || "#FFF";
            ctx.font = `bold ${12 * s}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText(skinObj.number, p.x, torsoY + bodyH * 0.6);
        }

        // 10. Shot Meter (Layer 6)
        if (state === 'JUMPING') {
            const style = getCurrentStyle();
            let maxVz = (style.modifiers.jumpVelocity !== undefined) ? style.modifiers.jumpVelocity : 9;
            if (maxVz <= 0.5) maxVz = 9;

            const curVz = getCurrentVz();
            const targetVz = getReleaseTargetVz(maxVz);
            const dist = maxVz - targetVz;

            // Reversal Logic: Fill to target (1.0), then empty
            let progress = 1.0 - (Math.abs(curVz - targetVz) / dist);
            progress = Math.max(0, Math.min(1, progress));

            const groundY = p.y + (player3D.z * s);
            const meterY = groundY - (130 * s * sizeMod.h);
            const cx = p.x + (60 * s); const radius = 50 * s;

            const thresh = calculateShotThreshold();
            const greenWidth = thresh / dist;

            // Green zone at the top (100%)
            let gStart = 1.0 - greenWidth;
            let gEnd = 1.0;
            gStart = Math.max(0, gStart);

            if (playerData.meterEnabled) {
                drawShotMeter(cx, meterY, radius * (playerData.meterScale || 1.0), s, progress, gStart, playerData.meterShape || 'arc', gEnd);
            }
        }
    }
    function getProjectedY(gDist, currentDist, horizonY) {
        if (gDist <= 0) { const p = project(HOOP_POS.x, HOOP_POS.y, 0); return p ? p.y : horizonY; }
        const ratio = gDist / currentDist;
        const wx = HOOP_POS.x + (player3D.x - HOOP_POS.x) * ratio; const wy = HOOP_POS.y + (player3D.y - HOOP_POS.y) * ratio;
        const p = project(wx, wy, 0); return p ? p.y : canvas.height;
    }

    function drawMountainLayer(layer, horizonY, dx, scale) {
        if (playerData.graphics === 'HIGH') {
            if (!layer.gradient) {
                const grad = ctx.createLinearGradient(0, horizonY - 150, 0, horizonY);
                grad.addColorStop(0, layer.color);
                grad.addColorStop(1, '#1a1a1a');
                layer.gradient = grad;
            }
            ctx.fillStyle = layer.gradient;
        } else {
            ctx.fillStyle = layer.color;
        }

        if (!scale) scale = 1.0;

        ctx.beginPath();
        ctx.moveTo((layer.points[0].x * scale) + dx, horizonY);
        layer.points.forEach(p => { ctx.lineTo((p.x * scale) + dx, horizonY - (p.y * scale)); });
        ctx.lineTo((layer.points[layer.points.length-1].x * scale) + dx, horizonY);
        ctx.fill();
    }

    function drawBackground() {
        // Optimization: Per-frame camera calculation
        const dxToHoop = HOOP_POS.x - player3D.x;
        const dyToHoop = HOOP_POS.y - player3D.y;
        const angleToHoop = Math.atan2(dyToHoop, dxToHoop);
        const camRotation = -angleToHoop - Math.PI / 2;
        const camSin = Math.sin(camRotation);
        const camCos = Math.cos(camRotation);
        const camZoom = 698;
        const camHeight = 84000 / camZoom;

        if (!g_camCache) g_camCache = {};
        g_camCache.rotation = camRotation;
        g_camCache.sinRot = camSin;
        g_camCache.cosRot = camCos;
        g_camCache.cameraZoom = camZoom;
        g_camCache.cameraHeight = camHeight;
        // Ensure globals are updated
        cameraZoom = camZoom;
        cameraHeight = camHeight;

        const horizonY = (canvas.height - 120) * 0.5;

        if (!bgCache || bgCache.distanceLevel !== distanceLevel) {
            bgCache = { distanceLevel: distanceLevel, pastFloors: [] };
            const currentDist = 10 + (distanceLevel * 5);
            const court = getCourtDetails(currentDist);

            // Sky
            const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.6);
            skyGrad.addColorStop(0, court.sky1); skyGrad.addColorStop(1, court.sky2);
            bgCache.sky = skyGrad;

            // Current Floor
            if (playerData.graphics === 'HIGH') {
                 // Bake texture for high graphics
                 const fCv = document.createElement('canvas');
                 fCv.width = canvas.width;
                 fCv.height = Math.ceil(canvas.height - horizonY);
                 const fCtx = fCv.getContext('2d');

                 // Base Gradient
                 const grad = fCtx.createLinearGradient(0, 0, 0, fCv.height);
                 grad.addColorStop(0, court.ground1); grad.addColorStop(1, court.ground2);
                 fCtx.fillStyle = grad;
                 fCtx.fillRect(0, 0, fCv.width, fCv.height);

                 // Procedural Textures based on Type
                 if (court.type === 'grass' || court.type === 'tree') {
                     // Grass Blades
                     fCtx.strokeStyle = 'rgba(0,0,0,0.1)';
                     fCtx.lineWidth = 1;
                     const blades = fCv.width * fCv.height * 0.02;
                     for(let i=0; i<blades; i++) {
                         const x = Math.random() * fCv.width;
                         const y = Math.random() * fCv.height;
                         const len = 2 + Math.random() * 3;
                         fCtx.beginPath();
                         fCtx.moveTo(x, y);
                         fCtx.lineTo(x, y - len);
                         fCtx.stroke();
                     }
                     // Noise
                     fCtx.fillStyle = 'rgba(0,0,0,0.05)';
                     for(let i=0; i<blades/2; i++) {
                         fCtx.fillRect(Math.random()*fCv.width, Math.random()*fCv.height, 2, 2);
                     }
                 }
                 else if (court.type === 'castle') {
                     // Asphalt / Pavement Noise
                     fCtx.fillStyle = 'rgba(255,255,255,0.05)';
                     const noise = fCv.width * fCv.height * 0.1;
                     for(let i=0; i<noise; i++) {
                         fCtx.fillRect(Math.random()*fCv.width, Math.random()*fCv.height, 1, 1);
                     }
                     fCtx.fillStyle = 'rgba(0,0,0,0.1)';
                     for(let i=0; i<noise; i++) {
                         fCtx.fillRect(Math.random()*fCv.width, Math.random()*fCv.height, 1, 1);
                     }
                     // Cracks
                     fCtx.strokeStyle = 'rgba(0,0,0,0.4)';
                     fCtx.lineWidth = 2;
                     for(let i=0; i<5; i++) {
                         let cx = Math.random() * fCv.width;
                         let cy = Math.random() * fCv.height;
                         fCtx.beginPath();
                         fCtx.moveTo(cx, cy);
                         for(let j=0; j<5; j++) {
                             cx += (Math.random()-0.5)*50;
                             cy += (Math.random()-0.5)*50;
                             fCtx.lineTo(cx, cy);
                         }
                         fCtx.stroke();
                     }
                 }
                 else if (court.type === 'mountain') {
                     // Ice / Snow Gloss
                     // Scratches (Skate marks)
                     fCtx.strokeStyle = 'rgba(255,255,255,0.3)';
                     fCtx.lineWidth = 1;
                     for(let i=0; i<200; i++) {
                         const sx = Math.random() * fCv.width;
                         const sy = Math.random() * fCv.height;
                         fCtx.beginPath();
                         fCtx.moveTo(sx, sy);
                         fCtx.quadraticCurveTo(sx + (Math.random()-0.5)*100, sy + (Math.random()-0.5)*50, sx + (Math.random()-0.5)*200, sy + (Math.random()-0.5)*100);
                         fCtx.stroke();
                     }
                     // Reflections (Fake)
                     const gradRef = fCtx.createLinearGradient(0, 0, fCv.width, fCv.height);
                     gradRef.addColorStop(0, 'rgba(255,255,255,0)');
                     gradRef.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                     gradRef.addColorStop(1, 'rgba(255,255,255,0)');
                     fCtx.fillStyle = gradRef;
                     fCtx.fillRect(0, 0, fCv.width, fCv.height);
                 }
                 else if (court.type === 'water') {
                     // Ripples
                     fCtx.strokeStyle = 'rgba(255,255,255,0.1)';
                     fCtx.lineWidth = 2;
                     for(let i=0; i<fCv.height; i+=5) {
                         const offset = Math.sin(i * 0.1) * 20;
                         fCtx.beginPath();
                         fCtx.moveTo(0, i);
                         fCtx.lineTo(fCv.width, i + offset);
                         fCtx.stroke();
                     }
                 }
                 else if (court.type === 'space') {
                     // Craters / Dust
                     fCtx.fillStyle = 'rgba(0,0,0,0.2)';
                     for(let i=0; i<20; i++) {
                         const r = 10 + Math.random() * 40;
                         const cx = Math.random() * fCv.width;
                         const cy = Math.random() * fCv.height;
                         fCtx.beginPath();
                         fCtx.arc(cx, cy, r, 0, Math.PI*2);
                         fCtx.fill();
                     }
                     fCtx.fillStyle = 'rgba(255,255,255,0.05)';
                     for(let i=0; i<500; i++) {
                         fCtx.fillRect(Math.random()*fCv.width, Math.random()*fCv.height, 2, 2);
                     }
                 }

                 bgCache.floorImage = fCv;
            } else {
                 const currentZoneGrad = ctx.createLinearGradient(0, horizonY, 0, canvas.height);
                 currentZoneGrad.addColorStop(0, court.ground1); currentZoneGrad.addColorStop(1, court.ground2);
                 bgCache.currentFloor = currentZoneGrad;
            }

            // Past Floors
            for (let i = 0; i < COURT_ZONES.length; i++) {
                const z = COURT_ZONES[i];
                let zStart = (i === 0) ? 0 : COURT_ZONES[i-1].limit;
                let zEnd = z.limit;
                if (zStart >= currentDist) break;
                let drawEnd = Math.min(zEnd, currentDist);
                const yTop = getProjectedY(zStart, currentDist, horizonY); const yBottom = getProjectedY(drawEnd, currentDist, horizonY);
                if ((yBottom - yTop) > 0.5) {
                    const grad = ctx.createLinearGradient(0, yTop, 0, yBottom);
                    grad.addColorStop(0, z.ground1); grad.addColorStop(1, z.ground2);
                    bgCache.pastFloors.push({ y: yTop, h: (yBottom - yTop) + 2, grad: grad });
                }
            }
        }

        // DRAW FROM CACHE
        ctx.fillStyle = bgCache.sky; ctx.fillRect(0, 0, canvas.width, canvas.height);

        // SUN / MOON / STARS
        if (distanceLevel > 8) {
             // Simple stars
             ctx.fillStyle = 'rgba(255,255,255,0.8)';
             // Seeded random stars (reusing clouds speed for variation or just simple hash)
             for(let i=0; i<30; i++) {
                 let sx = (i * 137) % canvas.width;
                 let sy = (i * 59) % (horizonY * 0.8);
                 ctx.beginPath(); ctx.arc(sx, sy, 1 + (i%2), 0, Math.PI*2); ctx.fill();
             }
        } else {
             // Sun
             if (playerData.graphics === 'HIGH') {
                 // Better Sun with glow
                 const sunX = 700, sunY = 80;
                 const glow = ctx.createRadialGradient(sunX, sunY, 20, sunX, sunY, 120);
                 glow.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                 glow.addColorStop(0.4, 'rgba(255, 165, 0, 0.4)');
                 glow.addColorStop(1, 'rgba(255, 69, 0, 0)');
                 ctx.fillStyle = glow;
                 ctx.beginPath(); ctx.arc(sunX, sunY, 120, 0, Math.PI*2); ctx.fill();
                 ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(sunX, sunY, 40, 0, Math.PI*2); ctx.fill();
             } else {
                 ctx.fillStyle = sunGradient;
                 ctx.beginPath(); ctx.arc(700, 80, 80, 0, Math.PI*2); ctx.fill();
             }
        }

        // BACKGROUND MOUNTAINS
        const mountainScale = 1.0 / (1.0 + (distanceLevel - 1) * 0.01);

        mountainLayers.forEach(layer => {
             const shift = (player3D.x + player3D.y) * layer.speed;
             const loopWidth = 2000 * mountainScale;
             const offset = shift % loopWidth;
             let startX = -offset;
             if (startX > 0) startX -= loopWidth;

             let currentX = startX;
             while(currentX < canvas.width) {
                 drawMountainLayer(layer, horizonY, currentX, mountainScale);
                 currentX += loopWidth;
             }
        });

        // CLOUDS
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        clouds.forEach(c => {
             c.x += c.speed;
             if(c.x > canvas.width + 200) c.x = -200;
             let xPos = c.x;
             let yPos = c.y;
             ctx.beginPath();
             c.puffs.forEach(p => {
                 ctx.moveTo(xPos + p.dx * c.scale, yPos + p.dy * c.scale);
                 ctx.arc(xPos + p.dx * c.scale, yPos + p.dy * c.scale, p.r * c.scale, 0, Math.PI*2);
             });
             ctx.fill();
        });

        if (bgCache.floorImage) {
             ctx.drawImage(bgCache.floorImage, 0, horizonY);
        } else {
             ctx.fillStyle = bgCache.currentFloor; ctx.fillRect(0, horizonY, canvas.width, canvas.height - horizonY);
        }

        bgCache.pastFloors.forEach(f => {
            ctx.fillStyle = f.grad; ctx.fillRect(0, f.y, canvas.width, f.h);
        });

        ctx.beginPath(); ctx.moveTo(0, horizonY); ctx.lineTo(canvas.width, horizonY); ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.stroke();

        // 3D OBJECTS
        g_poolIndex = 0;
        g_renderList.length = 0;

        // Use cached camera values (already calculated at top of function)

        // OPTIMIZATION: Cull objects far beyond the player
        // Player moves away from hoop. d.dist approximates distance from hoop (in pixels).
        // Objects with d.dist >> playerDistFromHoop are behind the camera.
        const playerDistFromHoop = Math.sqrt(Math.pow(player3D.x - HOOP_POS.x, 2) + Math.pow(player3D.y - HOOP_POS.y, 2));
        const cullDist = playerDistFromHoop + 3000; // Margin for scatter and frustum depth

        // OPTIMIZATION: Start iteration from visible range
        // Objects with d.dist << playerDistFromHoop are too far in the distance to be seen (sub-pixel scale).
        // We assume a max visible depth of ~15000 pixels.
        const startDist = Math.max(0, playerDistFromHoop - 15000);
        let startIndex = 0;
        if (startDist > 1000) {
             startIndex = binarySearchLowerBound(decors, startDist);
        }

        for (let i = startIndex; i < decors.length; i++) {
            const d = decors[i];

            // Optimization: Stop processing if objects are too far behind the player (out of view)
            if (d.dist > cullDist) break;

            // Fast Z-Check
            const dx = d.x - player3D.x;
            const dy = d.y - player3D.y;
            // ry calculation: dx * sin + dy * cos
            const ry = dx * camSin + dy * camCos;
            // cameraOffset is 400 in project()
            const depth = 400 - ry;
            if (depth <= 0) continue;

            // Inline projection
            const rx = dx * camCos - dy * camSin;
            const scale = camZoom / depth;
            const screenX = canvas.width / 2 + (rx * scale);
            const screenY = horizonY + (camHeight - 0) * scale; // z is 0

            const obj = getRenderItem();
            obj.type = 'decor';
            obj.depth = depth;
            obj.x = screenX;
            obj.y = screenY;
            obj.scale = scale;
            obj.zoneType = d.zoneType;
            obj.variant = d.variant;
            obj.seed = d.seed;
            g_renderList.push(obj);
        }

        const hoopProj = project(HOOP_POS.x, HOOP_POS.y, HOOP_POS.z);
        if (hoopProj) {
            const obj = getRenderItem();
            obj.type = 'hoop';
            obj.depth = hoopProj.depth;
            obj.x = hoopProj.x; obj.y = hoopProj.y; obj.scale = hoopProj.scale;
            g_renderList.push(obj);
        }

        const playerProj = project(player3D.x, player3D.y, player3D.z);
        if (playerProj) {
            const obj = getRenderItem();
            obj.type = 'player';
            obj.depth = playerProj.depth;
            obj.x = playerProj.x; obj.y = playerProj.y; obj.scale = playerProj.scale;
            g_renderList.push(obj);
        }

        const shadowProj = project(player3D.x, player3D.y, 0);
        if (shadowProj) {
            const obj = getRenderItem();
            obj.type = 'shadow';
            obj.depth = shadowProj.depth;
            obj.x = shadowProj.x; obj.y = shadowProj.y; obj.scale = shadowProj.scale;
            g_renderList.push(obj);
        }

        activeBalls.forEach(b => {
            if (b.active) {
                const ballProj = project(b.x, b.y, b.z);
                if (ballProj) {
                    const obj = getRenderItem();
                    obj.type = 'ball';
                    obj.depth = ballProj.depth;
                    obj.x = ballProj.x; obj.y = ballProj.y; obj.scale = ballProj.scale;
                    obj.ballRef = b;
                    g_renderList.push(obj);
                }
            }
        });

        particles.forEach(p => {
             const proj = project(p.x, p.y, p.z);
             if(proj) {
                 const obj = getRenderItem();
                 obj.type = 'smoke';
                 // Force streak fire particles behind the player (depth > 400)
                 if (p.isFireParticle && p.customHue !== undefined) {
                     obj.depth = Math.max(proj.depth, 420);
                 } else {
                     obj.depth = proj.depth;
                 }
                 obj.x = proj.x; obj.y = proj.y; obj.scale = proj.scale;
                 obj.alpha = p.alpha;
                 obj.color = p.color;
                 g_renderList.push(obj);
             }
        });

        g_renderList.sort((a, b) => b.depth - a.depth);
        g_renderList.forEach(obj => {
            if (obj.type === 'decor') drawDecor(obj, obj.zoneType, obj.variant, obj.seed);
            if (obj.type === 'hoop') drawHoop(obj);
            if (obj.type === 'shadow') drawShadow(obj);
            if (obj.type === 'player') drawPlayer(obj);
            if (obj.type === 'ball') drawBall(obj, obj.ballRef);
            if (obj.type === 'smoke') drawSmoke(obj, obj.alpha, obj.color);
        });

        // Draw Weather overlay on top of 3D scene but behind UI
        weather.draw(project);

        if (feedbackTimer > 0) {
            ctx.save(); ctx.font = "900 60px 'Arial Black'";
            ctx.fillStyle = feedback === "MUY BIEN!" || feedback === "CHANCEUX!" || feedback === "Swish" || feedback.includes('MONEY') || feedback === "SUR LA LIGNE!" || feedback === "OUF!" || feedback.includes('S√âRIE') ? "#00FF00" : "#FF0000";
            if (feedback === "DERNI√àRE CHANCE !") ctx.fillStyle = "#FFA500";
            ctx.strokeStyle = "white"; ctx.lineWidth = 2; ctx.textAlign = "center";
            ctx.fillText(feedback, canvas.width/2, 200); ctx.strokeText(feedback, canvas.width/2, 200);
            ctx.restore();
        }
    }

    // Achievement Logic Helpers
    function unlockAchievement(id) {
        if (!playerData.unlockedAchievements.includes(id)) {
            playerData.unlockedAchievements.push(id);
            const ach = ACHIEVEMENTS.find(a => a.id === id);
            if(ach) {
                playerData.tacos += ach.reward;
                saveData();
                showNotification(ach.name, ach.reward);
                updateUI();
            }
        }
    }

    function checkAchievements(context) {
        const dist = 10 + (distanceLevel * 5);
        const ls = playerData.lifetimeStats;

        // Dynamic Check for New Achievements
        ACHIEVEMENTS.forEach(ach => {
            if (ach.type === 'distance' && context === 'score') {
                if (dist >= ach.threshold) unlockAchievement(ach.id);
            }
            if (ach.type === 'streak' && (context === 'streak' || context === 'score')) {
                if (currentStreak >= ach.threshold) unlockAchievement(ach.id);
            }
        });

        if (context === 'score') {
            unlockAchievement('rookie');
            if (ls.makes >= 100) unlockAchievement('veteran');
             if (dist >= 25) unlockAchievement('amateur'); if (dist >= 50) unlockAchievement('sniper');
            if (dist >= 75) unlockAchievement('pro');
            if (dist >= 100) { unlockAchievement('parking_lot'); unlockAchievement('urban_legend'); }
            if (dist >= 125) unlockAchievement('longshot'); if (dist >= 150) unlockAchievement('levis_legend');
            if (dist >= 300) unlockAchievement('chateau');
            if (dist >= 1000) unlockAchievement('mountain');
            if (dist >= 2000) unlockAchievement('astronaut');
            if (dist >= 5000) unlockAchievement('demigod');
            if (playerData.difficulty >= 3) unlockAchievement('daredevil');
            if (playerData.difficulty >= 2) unlockAchievement('hard_mode');
        }
        if(context === 'shot_stats') {
             if(ls.shots >= 500) unlockAchievement('ball_hog');
             if(ls.misses >= 50) unlockAchievement('bricklayer');
        }
        if(context === 'contest') {
             if(contestData.score > 10) unlockAchievement('contest_winner');
             if(contestData.score > 20) unlockAchievement('contest_perfect');
        }
        if (context === 'shop') {
            if (playerData.unlockedSkins.length >= 5) unlockAchievement('fashionista');
            if (playerData.unlockedSkins.length >= 10) unlockAchievement('wardrobe_malfunction');
            if (playerData.unlockedSkins.length >= 15) unlockAchievement('collector');
            if (playerData.stats.income >= 5) unlockAchievement('sweet_tooth');
            if (playerData.stats.aim >= 5) unlockAchievement('hawkeye');
            if (playerData.stats.luck >= 5) unlockAchievement('leprechaun');
            if (playerData.stats.moonwalk >= 5) unlockAchievement('moonwalker_pro');
            const animalsOwned = new Set();
            playerData.unlockedSkins.forEach(skinId => { const s = SKINS_DB.find(x => x.id === skinId); if(s) animalsOwned.add(s.animal); });
            if(animalsOwned.size >= 3) unlockAchievement('zoo');
        }
        if (context === 'lucky') unlockAchievement('lucky');
        if (context === 'skin') {
            const s = playerData.currentSkin;
            if(s.includes('robot') || s.includes('alien') || s.includes('astronaut')) unlockAchievement('cosplay');
            if(s.includes('lumberjack') || s.includes('hockey')) unlockAchievement('eh');
            if(s.includes('zombie') || s.includes('vampire') || s.includes('devil')) unlockAchievement('spooky');
            if(s.includes('poutine')) unlockAchievement('poutine_chef');
        }
        if (playerData.tacos >= 100) unlockAchievement('pocket_change');
        if (playerData.tacos >= 500) unlockAchievement('tycoon');
        if (playerData.tacos >= 2000) unlockAchievement('millionaire');
    }

    function showNotification(name, reward) {
        const notifText = document.getElementById('notifText');
        notifText.innerText = `${name} (+${reward} Tacos)`;
        notif.style.display = 'block'; setTimeout(() => { notif.style.display = 'none'; }, 3000);
    }

    function renderAchievements() {
        const list = document.getElementById('achList');
        list.innerHTML = '';
        ACHIEVEMENTS.forEach(ach => {
            const unlocked = playerData.unlockedAchievements.includes(ach.id);
            const div = document.createElement('div');
            div.className = `ach-row ${unlocked ? 'unlocked' : ''}`;
            div.innerHTML = `<div style="display:flex; align-items:center;"><div class="ach-icon">${unlocked ? 'üèÜ' : 'üîí'}</div><div class="ach-info"><h4>${ach.name}</h4><span>${ach.desc}</span></div></div>${unlocked ? '<div style="color:#00FF00">‚úì</div>' : ''}`;
            list.appendChild(div);
        });
    }

    // --- GAME ACTIONS ---
    function startJump() {
        if (state !== 'IDLE') return;
        AudioSystem.init();
        state = 'JUMPING';
        feedback = "";

        const style = getCurrentStyle();
        const jv = (style.modifiers.jumpVelocity !== undefined) ? style.modifiers.jumpVelocity : 9;

        if (jv <= 0.5) {
            isGroundedShot = true;
            groundShotTimer = 0;
            player3D.vz = 0;
        } else {
            isGroundedShot = false;
            player3D.vz = jv;
        }
    }
    function releaseShot() {
        if (state !== 'JUMPING') return;

        const style = getCurrentStyle();
        let maxVz = (style.modifiers.jumpVelocity !== undefined) ? style.modifiers.jumpVelocity : 9;

        const currentVz = getCurrentVz();
        const targetVz = getReleaseTargetVz(maxVz);

        // Calculate error relative to the chosen release point
        // If target is 0 and current is 0, error is 0.
        // If target is 5 and current is 5, error is 0.
        // We use absolute difference for the check.
        const timingError = currentVz - targetVz;

        shoot(timingError);
    }
    function retryShot() {
        player3D.z = 0; player3D.vz = 0;
        state = 'IDLE';
        activeBalls = []; // Clear any remaining balls
    }

    function shoot(timingError) {
        state = 'SHOOTING';

        if (playerData.currentStyle === 'airbud') airbudJumpTime = 0;

        playerData.lifetimeStats.shots++;
        checkAchievements('shot_stats');

        const style = getCurrentStyle();
        const styleId = style.id;
        const mods = style.modifiers;

        let threshold = calculateShotThreshold();
        if (!playerData.meterEnabled) threshold *= 1.2;

        const dx = HOOP_POS.x - player3D.x; const dy = HOOP_POS.y - player3D.y;

        let spawnZ = 120;
        if (styleId === 'airbud') spawnZ = 95;
        if (styleId === 'telekinesis' || styleId === 'peekaboo') spawnZ = 130;

        let newBall = {
            x: player3D.x,
            y: player3D.y,
            z: player3D.z + spawnZ,
            vx: 0, vy: 0, vz: 0,
            active: true,
            isFire: (currentStreak >= 5 && currentGameMode !== 'TIME_ATTACK'),
            trail: [],
            rotationX: 0,
            isWindow: false
        };

        let flightTime = Math.min(120, 40 + (distanceLevel * 0.8));
        if(mods.speed) flightTime /= mods.speed;

        // Enforce minimum arc (parabola)
        flightTime = Math.max(32, flightTime);

        newBall.vx = (dx / flightTime); newBall.vy = (dy / flightTime); newBall.vz = (HOOP_POS.z - newBall.z + 0.5 * GRAVITY * flightTime * (flightTime - 1)) / flightTime;

        let isMiss = Math.abs(timingError) > threshold;

        // "Sur La Ligne" Bonus: 28% forgiveness zone (0.32 / 0.25 = 1.28)
        if (isMiss && Math.abs(timingError) < threshold * 1.28) {
            if(Math.random() > 0.5) { isMiss = false; feedback = "SUR LA LIGNE!"; feedbackTimer = 30; }
        }

        if (isMiss) {
            const luckChance = (playerData.stats.luck - 1) * 0.0111;
            let finalLuckChance = luckChance;
            if(mods.luckBonus) finalLuckChance *= mods.luckBonus;

            if (Math.random() < finalLuckChance) { feedback = "CHANCEUX!"; feedbackTimer = 30; checkAchievements('lucky'); }
            else {
                // Reconstruct accuracy magnitude for visuals
                // accuracy = 0.25 * (timingError / threshold)
                const accuracyMagnitude = 0.25 * (timingError / threshold);

                const len = Math.sqrt(dx*dx + dy*dy); const perpX = -dy / len; const perpY = dx / len;
                const scatter = (Math.random() > 0.5 ? 1 : -1) * Math.abs(accuracyMagnitude) * 15;
                newBall.vx += perpX * scatter; newBall.vy += perpY * scatter; newBall.vz -= Math.abs(accuracyMagnitude) * 5;

                if (Math.abs(timingError) > threshold * 3) {
                    feedback = "VITRE CASS√âE !";
                    newBall.isWindow = true;
                } else {
                    feedback = Math.abs(accuracyMagnitude) > 0.5 ? "AIRBALL" : "BRIQUE";
                    newBall.isWindow = false;
                }
                feedbackTimer = 30;
            }
        }

        activeBalls.push(newBall);

        // Legacy Sync: Update global ball for compatibility
        ball = Object.assign({}, newBall);
    }

    function handleScore(b) {
        const targetBall = b || ball;
        AudioSystem.playSwish();
        targetBall.active = false; playerData.lifetimeStats.makes++; currentStreak++;

        // Daily Challenge Hooks
        checkDailyProgress('makes', 1);
        checkDailyProgress('streak', currentStreak);

        checkAchievements('streak');
        crowdCheerTimer = 60;
        if(currentGameMode === 'CONTEST') {
            const isMoneyBall = (contestData.ballsInRack === 4);
            const points = isMoneyBall ? 2 : 1;
            contestData.score += points;
            if (currentStreak >= 3) { feedback = `S√âRIE DE ${currentStreak}!`; } else { feedback = isMoneyBall ? "MONEY BALL! (+2)" : "Swish (+1)"; }
            feedbackTimer = 30; updateContestUI(); state = 'RESETTING'; setTimeout(nextLevel, 500);
        } else if (currentGameMode === 'TIME_ATTACK') {
             timeAttackData.score++;
             if (currentStreak >= 3) { feedback = `S√âRIE DE ${currentStreak}!`; } else { feedback = "Swish (+1)"; }
             feedbackTimer = 30; updateContestUI();
        } else {
            consecutiveMisses = 0;
            if (currentStreak >= 3) { feedback = `S√âRIE DE ${currentStreak} üî•`; } else { feedback = "Swish"; }
            feedbackTimer = 60; state = 'RESETTING'; setTimeout(nextLevel, 1000);
        }
    }

    function handleMiss(b) {
        const targetBall = b || ball;
        if(state === 'GAMEOVER') return;
        AudioSystem.playFloorHit();
        targetBall.active = false;
        playerData.lifetimeStats.misses++; currentStreak = 0; checkAchievements('shot_stats');
        if(currentGameMode === 'CONTEST') {
            feedback = "Manqu√©"; feedbackTimer = 30; state = 'RESETTING'; setTimeout(nextLevel, 500);
        } else if (currentGameMode === 'TIME_ATTACK') {
             feedback = "Manqu√©"; feedbackTimer = 30;
        } else {
            consecutiveMisses++; updateUI();
            const maxMisses = 2 + (playerData.stats.extraLives || 0);
            if (consecutiveMisses >= maxMisses) {
                feedback = "TERMIN√â !"; feedbackTimer = 60; state = 'GAMEOVER'; setTimeout(openShop, 1500);
            } else {
                feedback = "DERNI√àRE CHANCE !"; feedbackTimer = 60; state = 'RESETTING'; setTimeout(retryShot, 1500);
            }
        }
    }

    function updateParticles(dt) {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.z += p.vz * dt;
            p.life -= dt;
            p.scale += (p.isFireParticle ? -0.01 : 0.05) * dt;
            p.alpha = p.life / p.maxLife;

            if (p.isFireParticle) {
                const r = p.life / p.maxLife;
                if (p.customHue !== undefined) {
                    // Dynamic Streak Fire: White -> Bright -> Base -> Dark
                    if (r > 0.8) p.color = `hsla(${p.customHue}, 100%, 95%, ${p.alpha})`;
                    else if (r > 0.5) p.color = `hsla(${p.customHue}, 100%, 75%, ${p.alpha})`;
                    else if (r > 0.2) p.color = `hsla(${p.customHue}, 100%, 50%, ${p.alpha})`;
                    else p.color = `hsla(${p.customHue}, 30%, 30%, ${p.alpha})`;
                } else {
                    // Classic Fire: White -> Yellow -> Orange -> Dark Grey
                    if (r > 0.8) p.color = `rgba(255, 255, 255, ${p.alpha})`;
                    else if (r > 0.5) p.color = `rgba(255, 255, 0, ${p.alpha})`;
                    else if (r > 0.2) p.color = `rgba(255, 69, 0, ${p.alpha})`;
                    else p.color = `rgba(50, 50, 50, ${p.alpha})`;
                }
            }

            if (p.life <= 0) {
                particles[i] = particles[particles.length - 1];
                particles.pop();
            }
        }
    }

    function update(dt) {
        updateParticles(dt);
        if (crowdCheerTimer > 0) crowdCheerTimer -= dt;
        weather.update(dt);

        // Character Streak Fire (Super Saiyan Effect)
        if (currentStreak >= 10 && state !== 'GAMEOVER') {
             const spawnCount = 2;
             for(let k=0; k<spawnCount; k++) {
                 if (Math.random() < 0.175 * dt) {
                     const hue = getStreakFireHue(currentStreak);
                     const life = 15 + Math.random() * 15;

                     // Spawn in a cylinder around player to create "outline"
                     const angle = Math.random() * Math.PI * 2;
                     const radius = 25 + Math.random() * 10;

                     particles.push({
                         x: player3D.x + Math.cos(angle) * radius,
                         y: player3D.y + Math.sin(angle) * radius * 0.4,
                         z: player3D.z + Math.random()*90,
                         vx: Math.cos(angle) * 0.5,
                         vy: Math.sin(angle) * 0.5,
                         vz: 6 + Math.random()*6, // Fast upward energy
                         life: life, maxLife: life,
                         scale: 1.5 + Math.random(),
                         alpha: 0.8,
                         isFireParticle: true,
                         customHue: hue
                     });
                 }
             }
        }

        if (state === 'SHOP' || state === 'ACHIEVEMENTS' || state === 'STATS') return;

        if(currentGameMode === 'CONTEST' && state !== 'GAMEOVER') {
            if(contestData.timer > 0) {
                contestData.timer -= (1/60) * dt;
                if(contestData.timer <= 0) { contestData.timer = 0; endContest(); }
                if(Math.ceil(contestData.timer) !== lastDisplayedContestTime) { updateContestUI(); }
            }
        }

        if(currentGameMode === 'TIME_ATTACK' && state !== 'GAMEOVER') {
            if(timeAttackData.timer > 0) {
                timeAttackData.timer -= (1/60) * dt;
                if(timeAttackData.timer <= 0) {
                    timeAttackData.timer = 0;
                    endTimeAttack();
                }
                if(Math.ceil(timeAttackData.timer) !== lastDisplayedContestTime) { updateContestUI(); }
            }
        }
        if (state === 'JUMPING') {
            if (isGroundedShot) {
                groundShotTimer += dt;
                if (groundShotTimer > 60) {
                    shoot(20); // Force bad shot
                }
            } else {
                player3D.z += player3D.vz * dt; player3D.vz -= GRAVITY * dt;
                if (player3D.z <= 0) { player3D.z = 0; player3D.vz = 0; state = 'GAMEOVER'; feedback = "MARCH√â!"; feedbackTimer = 60; setTimeout(openShop, 1500); }
            }
        }
        if (state === 'SHOOTING') {
            if (playerData.currentStyle === 'airbud') airbudJumpTime += 1 * dt;
            if (player3D.z > 0) { player3D.z += player3D.vz * dt; player3D.vz -= GRAVITY * dt; if (player3D.z < 0) player3D.z = 0; }
            if (currentGameMode === 'TIME_ATTACK' && player3D.z <= 0) {
                state = 'IDLE';
                player3D.z = 0;
            }
        }

        // Process Active Balls
        for (let i = activeBalls.length - 1; i >= 0; i--) {
            let b = activeBalls[i];
            if (b.active) {
                if (b.isFire) {
                     // Update Trail
                     if (playerData.graphics === 'HIGH') {
                         if (!b.trail) b.trail = [];
                         b.trail.push({ x: b.x, y: b.y, z: b.z });
                         if (b.trail.length > 20) b.trail.shift();
                     }

                     // Emit Fire Particles
                     if (Math.random() < 1.0 * dt) {
                         const life = 20 + Math.random() * 20;
                         let customHue = undefined;
                         if (currentStreak >= 10) {
                             customHue = getStreakFireHue(currentStreak);
                         }
                         particles.push({
                             x: b.x + (Math.random()-0.5)*15,
                             y: b.y + (Math.random()-0.5)*15,
                             z: b.z + (Math.random()-0.5)*15,
                             vx: (Math.random()-0.5)*5,
                             vy: (Math.random()-0.5)*5,
                             vz: (Math.random()-0.5)*5,
                             life: life, maxLife: life,
                             scale: 0.8 + Math.random()*0.5, alpha: 1.0,
                             isFireParticle: true,
                             customHue: customHue
                         });
                     }
                } else {
                    if(b.trail && b.trail.length > 0) b.trail = [];
                }

                const prevZ = b.z;
                const prevX = b.x;
                const prevY = b.y;

                b.rotationX -= 0.2 * dt;

                b.x += b.vx * dt; b.y += b.vy * dt; b.z += b.vz * dt; b.vz -= GRAVITY * dt;

                // Collision Logic
                if (prevZ >= HOOP_POS.z && b.z <= HOOP_POS.z) {
                    let t = 0;
                    if (prevZ !== b.z) {
                         t = (HOOP_POS.z - prevZ) / (b.z - prevZ);
                    }
                    const crossX = prevX + (b.x - prevX) * t;
                    const crossY = prevY + (b.y - prevY) * t;

                    const distToHoopCenter = Math.sqrt(Math.pow(crossX - HOOP_POS.x, 2) + Math.pow(crossY - HOOP_POS.y, 2));
                    if (distToHoopCenter < 25) { handleScore(b); continue; }

                    if (b.isWindow) {
                        AudioSystem.playWindowBreak();
                    } else if (feedback !== "AIRBALL") {
                        AudioSystem.playBrick();
                    }
                }
                const distToHoop = Math.sqrt(Math.pow(HOOP_POS.x - player3D.x, 2) + Math.pow(HOOP_POS.y - player3D.y, 2));
                const currentDist = Math.sqrt(Math.pow(b.x - player3D.x, 2) + Math.pow(b.y - player3D.y, 2));

                if (b.z < -50 || currentDist > distToHoop + 5000) { b.active = false; handleMiss(b); continue; }
                if (b.z <= 0) { b.z = 0; b.active = false; handleMiss(b); continue; }
            } else {
                activeBalls.splice(i, 1);
            }
        }
        if (feedbackTimer > 0) feedbackTimer -= 1 * dt;
    }

    // --- HELPER FUNCTIONS ---
    function nextLevel() {
        if(currentGameMode === 'CONTEST') {
            contestData.ballsInRack++;
            if(contestData.ballsInRack >= 5) {
                contestData.rack++; contestData.ballsInRack = 0;
                if(contestData.rack > 5) { endContest(); return; }
                else { setPlayerPositionForRack(contestData.rack); }
            }
            updateContestUI(); state = 'IDLE';
        } else if (currentGameMode === 'TIME_ATTACK') {
             // Continuous play, no level reset logic needed here usually
        } else {
            const baseReward = 1 * distanceLevel * playerData.difficulty;
            const multiplier = 1 + (playerData.stats.income - 1) * 0.5;
            let reward = Math.ceil(baseReward * multiplier);

            // New Streak Multiplier: +0.1x per shot in row
            if (currentStreak > 0) {
                reward = Math.ceil(reward * (1 + currentStreak * 0.1));
            }

            if (currentStreak > 1) reward += currentStreak * 2;
            playerData.tacos += reward;
            const jump = (playerData.stats.moonwalk !== undefined) ? playerData.stats.moonwalk : 1;

            // Hook Distance Challenge
            checkDailyProgress('distance', jump * 5);

            distanceLevel += jump;
            const currentDistanceVal = 10 + (distanceLevel * 5);
            if (currentDistanceVal > playerData.highScore) { playerData.highScore = currentDistanceVal; }
            saveData(); checkAchievements('score');
            player3D.x -= 15 * jump; player3D.y += 15 * jump; player3D.z = 0; player3D.vz = 0; state = 'IDLE'; updateUI();
            invalidateBackgroundCache();
        }
    }

    function endContest() {
        state = 'GAMEOVER'; feedback = "TERMIN√â !"; feedbackTimer = 120;

        // Increased Reward (x25 instead of x10)
        const reward = contestData.score * 25;
        playerData.tacos += reward;

        checkDailyProgress('contest_score', contestData.score);
        checkDailyProgress('play_contest', 1);

        checkAchievements('contest'); saveData(); setTimeout(openShop, 2000);
    }

    function startTimeAttack() {
        timeAttackData = { timer: 60, score: 0, active: true };
        currentStreak = 0;
        activeBalls = []; // Clear any existing balls

        // 30ft Position
        player3D.x = 619; player3D.y = 207; player3D.z = 0; player3D.vz = 0;

        document.getElementById('classic-stats').style.display = 'none';

        // Setup Contest UI for Time Attack
        document.getElementById('contest-ui').style.display = 'block';

        // Update Labels for Time Attack
        const rackVal = document.getElementById('contestRack');
        if (rackVal && rackVal.parentElement) {
            const label = rackVal.parentElement.querySelector('.sb-label');
            if (label) label.innerText = "RECORD";
            rackVal.innerText = (playerData.timeAttackHighScore || 0);
        }

        state = 'IDLE';
        updateUI();
        updateContestUI();

        invalidateBackgroundCache();
    }

    function endTimeAttack() {
        timeAttackData.active = false;
        state = 'GAMEOVER';

        // Reward (Increased from x5 to x15)
        const reward = timeAttackData.score * 15 * playerData.difficulty;
        playerData.tacos += reward;

        checkDailyProgress('time_attack_score', timeAttackData.score);
        checkDailyProgress('play_time_attack', 1);

        // Save High Score
        let isRecord = false;
        if (!playerData.timeAttackHighScore || timeAttackData.score > playerData.timeAttackHighScore) {
            playerData.timeAttackHighScore = timeAttackData.score;
            isRecord = true;
        }

        if (isRecord) {
            feedback = `NOUVEAU RECORD: ${timeAttackData.score}!`;
        } else {
            feedback = `SCORE: ${timeAttackData.score} (RECORD: ${playerData.timeAttackHighScore})`;
        }

        feedbackTimer = 180;

        saveData();
        setTimeout(openShop, 3000);
    }

    function updateUI() {
        scoreEl.innerText = playerData.tacos;
        if(currentGameMode === 'CLASSIC') {
            const maxMisses = 2 + (playerData.stats.extraLives || 0);
            missValEl.innerText = `${consecutiveMisses}/${maxMisses}`;
            const dist = 10 + (distanceLevel * 5); const c = getCourtDetails(dist); courtNameEl.innerText = c.name;
        } else if (currentGameMode === 'CONTEST') {
            courtNameEl.innerText = "CONCOURS 3 POINTS";
        } else if (currentGameMode === 'TIME_ATTACK') {
            courtNameEl.innerText = "TIME ATTACK";
            // Update Timer/Score in UI loop, but title here is good
        }
    }

    function setPlayerPositionForRack(rackNum) {
        // Shift contest positions too (+133)
        if(rackNum === 1) { player3D.x = 333; player3D.y = 500; }
        else if(rackNum === 2) { player3D.x = 383; player3D.y = 400; }
        else if(rackNum === 3) { player3D.x = 433; player3D.y = 300; }
        else if(rackNum === 4) { player3D.x = 483; player3D.y = 200; }
        else if(rackNum === 5) { player3D.x = 533; player3D.y = 100; }
        player3D.z = 0; player3D.vz = 0;
        invalidateBackgroundCache();
    }

    function updateContestUI() {
        if (currentGameMode === 'CONTEST') {
            const newTime = Math.ceil(contestData.timer);
            contestTimeEl.innerText = newTime;
            lastDisplayedContestTime = newTime;
            contestScoreEl.innerText = contestData.score;
            contestRackEl.innerText = contestData.rack;
        } else if (currentGameMode === 'TIME_ATTACK') {
            const newTime = Math.ceil(timeAttackData.timer);
            contestTimeEl.innerText = newTime;
            lastDisplayedContestTime = newTime;
            contestScoreEl.innerText = timeAttackData.score;
            // Best score
            const best = playerData.timeAttackHighScore || 0;
            // Need to re-query if the element was replaced?
            // Actually innerText on the span with id 'contestRack' should work if ID is preserved.
            const rEl = document.getElementById('contestRack');
            if (rEl) rEl.innerText = best;
        }
    }

    function startContest() {
        contestData = { timer: 60, score: 0, rack: 1, ballsInRack: 0, isActive: true };
        lastDisplayedContestTime = -1;
        currentStreak = 0;

        document.getElementById('classic-stats').style.display = 'none';
        contestUI.style.display = 'block';

        // Reset labels
        const rackVal = document.getElementById('contestRack');
        if (rackVal && rackVal.parentElement) {
            const label = rackVal.parentElement.querySelector('.sb-label');
            if (label) label.innerText = "RACK";
        }

        setPlayerPositionForRack(1);

        state = 'IDLE';
        updateUI();
        updateContestUI();
        playerData.lifetimeStats.contests++;
    }

    function resetGame() {
        activeBalls = []; // Clear all balls on reset
        if(currentGameMode === 'CONTEST') { startContest(); }
        else if(currentGameMode === 'TIME_ATTACK') { startTimeAttack(); }
        else {
            distanceLevel = 1; consecutiveMisses = 0;
            player3D = { x: 433, y: 300, z: 0, vz: 0 };
            document.getElementById('classic-stats').style.display = 'flex';
            contestUI.style.display = 'none';
            state = 'IDLE'; updateUI();
            invalidateBackgroundCache();
        }
    }

    // --- UI FUNCTIONS ---
    window.openShop = function() {
        if(state !== 'IDLE' && state !== 'GAMEOVER') return;
        state = 'SHOP'; shopUI.style.display = 'block'; achUI.style.display = 'none'; statsUI.style.display = 'none';
        document.getElementById('diffSlider').value = playerData.difficulty;
        updateDifficulty(); updateShopUI();
    }
    window.openAchievements = function() {
        if(state !== 'IDLE' && state !== 'GAMEOVER') return;
        state = 'ACHIEVEMENTS'; achUI.style.display = 'block'; shopUI.style.display = 'none'; statsUI.style.display = 'none'; renderAchievements();
    }
    window.openStats = function() {
        if(state !== 'IDLE' && state !== 'GAMEOVER' && state !== 'STATS') return;
        state = 'STATS';
        shopUI.style.display = 'none';
        achUI.style.display = 'none';
        statsUI.style.display = 'block';
        const ls = playerData.lifetimeStats;
        document.getElementById('statShots').innerText = ls.shots;
        document.getElementById('statMakes').innerText = ls.makes;
        document.getElementById('statMisses').innerText = ls.misses;
        document.getElementById('statContests').innerText = ls.contests;
        document.getElementById('statBestDist').innerText = playerData.highScore + " pi";
        document.getElementById('statTimeAttack').innerText = playerData.timeAttackHighScore || 0;
        let acc = 0;
        if(ls.shots > 0) acc = ((ls.makes / ls.shots) * 100).toFixed(1);
        document.getElementById('statAccuracy').innerText = acc + "%";

        // Daily Challenge UI Update
        const dc = playerData.dailyChallenge;
        if (dc && dc.id) {
            const def = DAILY_CHALLENGES.find(c => c.id === dc.id);
            if (def) {
                document.getElementById('dailyDesc').innerText = def.desc;
                let pct = (dc.progress / def.target) * 100;
                if (pct > 100) pct = 100;
                document.getElementById('dailyBar').style.width = pct + "%";

                let statusText = dc.progress + " / " + def.target;
                if (dc.claimed) {
                    statusText = "COMPL√âT√â !";
                    document.getElementById('dailyBar').style.background = "#FFD700";
                } else {
                    document.getElementById('dailyBar').style.background = "#00FF00";
                }
                document.getElementById('dailyProgressText').innerText = statusText;
                document.getElementById('dailyRewardText').innerText = "+" + def.reward + " Tacos";
            }
        }

        const btnMob = document.getElementById('btnToggleMobile');
        if(btnMob) btnMob.innerText = playerData.mobileControls ? "TOUCH: ON" : "TOUCH: OFF";
        const btnGraph = document.getElementById('btnToggleGraphics');
        if(btnGraph) btnGraph.innerText = (playerData.graphics === 'HIGH') ? "QUALIT√â: HAUTE" : "QUALIT√â: BASSE";
        const btnMeter = document.getElementById('btnToggleMeter');
        if(btnMeter) btnMeter.innerText = playerData.meterEnabled ? "VIS√âE: OUI" : "VIS√âE: NON";
        const btnShape = document.getElementById('btnCycleMeterShape');
        if(btnShape) {
            let shapeName = playerData.meterShape || 'arc';
            btnShape.innerText = "FORME: " + shapeName.toUpperCase();
        }
        const sld = document.getElementById('meterSizeSlider');
        if(sld) {
            const sc = playerData.meterScale || 1.0;
            sld.value = sc;
            document.getElementById('meterSizeLabel').innerText = Math.round(sc*100) + "%";
        }
    }
    window.toggleMeter = function() {
        playerData.meterEnabled = !playerData.meterEnabled;
        saveData(); openStats(); // Refresh UI
    }
    window.cycleMeterShape = function() {
        const shapes = ['arc', 'vertical', 'horizontal', 'orb', 'triangle', 'diamond', 'ring', 'chevron'];
        let idx = shapes.indexOf(playerData.meterShape);
        if (idx < 0) idx = 0;
        idx = (idx + 1) % shapes.length;
        playerData.meterShape = shapes[idx];
        saveData(); openStats(); // Refresh UI
    }
    window.updateMeterScale = function() {
        const val = parseFloat(document.getElementById('meterSizeSlider').value);
        playerData.meterScale = val;
        document.getElementById('meterSizeLabel').innerText = Math.round(val*100) + "%";
        saveData();
    }
    window.updateReleaseTiming = function() {
        const val = parseInt(document.getElementById('releaseTimingSlider').value);
        playerData.releaseTiming = val;
        const labels = ["SAUT (TR√àS T√îT)", "POINT (T√îT)", "POUSS√âE (NORMAL)", "L√ÇCHER (TARD)"];
        document.getElementById('releaseTimingLabel').innerText = labels[val];
        saveData();
    }
    window.attemptReset = function() {
        const btn = document.getElementById('btnReset');
        if (resetStage === 0) { resetStage = 1; btn.innerText = "S√õR ? (CLIQUEZ ENCORE)"; btn.style.background = "#FF0000"; return; }
        playerData = JSON.parse(JSON.stringify(defaultData)); saveData();
        updateUI(); closeStats(); resetGame();
        resetStage = 0; btn.innerText = "R√âINITIALISER PROGRESSION"; btn.style.background = "#8B0000"; feedback = "RESET!"; feedbackTimer = 60;
    }
    window.unlockAllSkins = function() {
        if(resetStage === 0) {
            const btn = document.getElementById('btnUnlock');
            resetStage = 2; // Different stage for unlock
            btn.innerText = "S√õR ? (CLIQUEZ ENCORE)";
            btn.style.background = "#800080";
            return;
        }
        if(resetStage === 2) {
            SKINS_DB.forEach(skin => {
                if(!playerData.unlockedSkins.includes(skin.id)) {
                    playerData.unlockedSkins.push(skin.id);
                }
            });
            checkAchievements('shop');
            saveData();
            updateShopUI();
            const btn = document.getElementById('btnUnlock');
            btn.innerText = "TRICHEUR !";
            btn.disabled = true;
            resetStage = 0;
            showNotification("TRICHEUR !", 0);
        }
    }
    window.closeShop = function() { state = 'IDLE'; shopUI.style.display = 'none'; if(feedback === "TERMIN√â !" || feedback === "MARCH√â!") resetGame(); }
    window.closeAchievements = function() { state = 'IDLE'; achUI.style.display = 'none'; if(feedback === "TERMIN√â !" || feedback === "MARCH√â!") resetGame(); }
    window.closeStats = function() {
        state = 'IDLE'; statsUI.style.display = 'none'; resetStage = 0;
        const btn = document.getElementById('btnReset'); if(btn) { btn.innerText = "R√âINITIALISER PROGRESSION"; btn.style.background = "#8B0000"; }
        if(feedback === "TERMIN√â !" || feedback === "MARCH√â!") resetGame();
    }
    window.updateDifficulty = function() {
        const val = parseFloat(document.getElementById('diffSlider').value);
        playerData.difficulty = val;
        const label = document.getElementById('diffLabel');
        label.innerText = `x${val.toFixed(1)} Tacos`;
        if(val === 1) { label.innerText = "NORMAL (x1.0)"; label.style.color = "#00FF00"; }
        else if (val < 2.5) { label.innerText = `DIFFICILE (x${val.toFixed(1)})`; label.style.color = "#FFFF00"; }
        else { label.innerText = `L√âVIS LEGEND (x${val.toFixed(1)})`; label.style.color = "#FF0000"; }
        saveData();
    }
    window.getUpgradeCost = function(statName) {
        const lvl = playerData.purchasedStats[statName];
        if (statName === 'income') return Math.floor(25 * Math.pow(lvl, 2));
        if (statName === 'aim') return Math.floor(50 * Math.pow(lvl, 2));
        if (statName === 'luck') return Math.floor(150 * Math.pow(lvl, 2));
        if (statName === 'moonwalk') return Math.floor(150 * Math.pow(lvl, 2));
        if (statName === 'extraLives') return Math.floor(1000 * Math.pow(2, lvl));
        return 999;
    }
    window.buyUpgrade = function(stat) {
        if (stat === 'luck' && playerData.purchasedStats.luck >= 10) return;
        const cost = getUpgradeCost(stat);
        if (playerData.tacos >= cost) {
            playerData.tacos -= cost;
            playerData.purchasedStats[stat]++;
            playerData.stats[stat] = playerData.purchasedStats[stat]; // Auto-equip
            saveData();
            updateShopUI();
            updateUI();
            checkAchievements('shop');
        }
    }
    window.changeStatLevel = function(stat, delta) {
        const current = playerData.stats[stat];
        const max = playerData.purchasedStats[stat];
        const min = 0;

        let next = current + delta;
        if (next < min) next = min;
        if (next > max) next = max;

        if (next !== current) {
            playerData.stats[stat] = next;
            saveData();
            updateShopUI();
            updateUI();
        }
    }
    window.changeAnimal = function(dir) {
        viewingAnimalIndex += dir;
        if(viewingAnimalIndex < 0) viewingAnimalIndex = ANIMALS.length - 1;
        if(viewingAnimalIndex >= ANIMALS.length) viewingAnimalIndex = 0;
        viewingSkinIndex = 0; updateShopUI();
    }
    window.changeSkin = function(dir) {
        const currentAnimal = ANIMALS[viewingAnimalIndex];
        const animalSkins = SKINS_DB.filter(s => s.animal === currentAnimal);
        viewingSkinIndex += dir;
        if(viewingSkinIndex < 0) viewingSkinIndex = animalSkins.length - 1;
        if(viewingSkinIndex >= animalSkins.length) viewingSkinIndex = 0;
        updateShopUI();
    }
    window.buyOrEquipSkin = function() {
        const currentAnimal = ANIMALS[viewingAnimalIndex];
        const animalSkins = SKINS_DB.filter(s => s.animal === currentAnimal);
        const skin = animalSkins[viewingSkinIndex];
        const isUnlocked = playerData.unlockedSkins.includes(skin.id);
        if (isUnlocked) { playerData.currentSkin = skin.id; checkAchievements('skin'); }
        else if (playerData.tacos >= skin.cost) {
            playerData.tacos -= skin.cost; playerData.unlockedSkins.push(skin.id); playerData.currentSkin = skin.id;
            checkAchievements('shop'); checkAchievements('skin');
        }
        saveData(); updateShopUI(); updateUI();
    }
    window.changeShootingStyle = function(dir) {
        viewingStyleIndex += dir;
        if(viewingStyleIndex < 0) viewingStyleIndex = SHOOTING_STYLES.length - 1;
        if(viewingStyleIndex >= SHOOTING_STYLES.length) viewingStyleIndex = 0;
        updateShopUI();
    }
    window.buyOrEquipShootingStyle = function() {
        const style = SHOOTING_STYLES[viewingStyleIndex];
        if(!playerData.unlockedStyles) playerData.unlockedStyles = ['classic']; // Safety
        const isUnlocked = playerData.unlockedStyles.includes(style.id);

        if (isUnlocked) {
            playerData.currentStyle = style.id;
        } else if (playerData.tacos >= style.cost) {
            playerData.tacos -= style.cost;
            playerData.unlockedStyles.push(style.id);
            playerData.currentStyle = style.id;
        }
        saveData(); updateShopUI(); updateUI();
    }
    window.toggleHandedness = function() {
        playerData.isLefty = !playerData.isLefty;
        saveData(); updateShopUI();
    }
    window.toggleMobileControls = function() {
        playerData.mobileControls = !playerData.mobileControls;
        saveData(); updateShopUI(); updateMobileControlsUI();
        const btn = document.getElementById('btnToggleMobile');
        if(btn) btn.innerText = playerData.mobileControls ? "TOUCH: ON" : "TOUCH: OFF";
    }
    window.toggleGraphics = function() {
        playerData.graphics = (playerData.graphics === 'HIGH') ? 'LOW' : 'HIGH';
        saveData();
        const btn = document.getElementById('btnToggleGraphics');
        if(btn) btn.innerText = (playerData.graphics === 'HIGH') ? "QUALIT√â: HAUTE" : "QUALIT√â: BASSE";
        invalidateBackgroundCache(); // Redraw background next frame
    }
    window.updateMobileControlsUI = function() {
        const btn = document.getElementById('mobileShootBtn');
        if(playerData.mobileControls && state !== 'STARTUP') btn.style.display = 'block';
        else btn.style.display = 'none';
    }

    function checkOrientation() {
        if (!playerData.mobileControls) return;
        const overlay = document.getElementById('orientation-overlay');
        const fsBtn = document.getElementById('btn-force-fullscreen');

        if (window.innerHeight > window.innerWidth) {
            overlay.style.display = 'flex';
            fsBtn.style.display = 'none';
        } else {
            overlay.style.display = 'none';
            checkFullscreenState();
        }
    }

    function checkFullscreenState() {
        if (!playerData.mobileControls) return;
        const fsBtn = document.getElementById('btn-force-fullscreen');
        const isFS = document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;

        if (!isFS) {
            fsBtn.style.display = 'flex';
        } else {
            fsBtn.style.display = 'none';
        }
    }

    window.forceFullscreen = function() {
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen().catch(e => console.log(e));
        } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        }
        checkFullscreenState();
    }

    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);
    document.addEventListener('fullscreenchange', checkFullscreenState);
    document.addEventListener('webkitfullscreenchange', checkFullscreenState);

    window.choosePlatform = function(mode) {
        AudioSystem.init();
        playerData.mobileControls = (mode === 'mobile');
        playerData.platformChosen = true;

        if (mode === 'mobile') {
            const elem = document.documentElement;
            const fsPromise = (elem.requestFullscreen) ? elem.requestFullscreen() : (elem.webkitRequestFullscreen ? elem.webkitRequestFullscreen() : null);

            if (fsPromise && fsPromise.catch) {
                fsPromise.catch(e => {
                    console.log("Fullscreen failed or rejected:", e);
                    checkFullscreenState(); // Show fallback button if failed
                });
            }

            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(e => console.log(e));
            }
            setTimeout(checkOrientation, 500);
        }

        saveData();
        startGame();
    }
    function checkStartup() {
        if(!playerData.platformChosen) {
            state = 'STARTUP';
            document.getElementById('startup-ui').style.display = 'flex';
            document.getElementById('scorebug-container').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
        } else {
            startGame();
        }
    }
    function startGame() {
        state = 'IDLE';
        document.getElementById('startup-ui').style.display = 'none';
        document.getElementById('scorebug-container').style.display = 'flex';
        document.getElementById('controls').style.display = 'flex';
        updateUI();
        updateMobileControlsUI();
    }
    function renderUpgradeControl(statName, containerId) {
        const active = playerData.stats[statName];
        const purchased = playerData.purchasedStats[statName];
        const container = document.getElementById(containerId);
        if (!container) return;

        let html = '';

        // Down Arrow ([-]) - Visible if active level > 0
        if (active > 0) {
            html += `<button class="btn" onclick="changeStatLevel('${statName}', -1)" style="padding: 8px 12px; margin-right:5px;">‚¨áÔ∏è</button>`;
        }

        // Up Arrow ([+]) or Buy Button
        if (active < purchased) {
            // Navigate up through owned levels
            html += `<button class="btn" onclick="changeStatLevel('${statName}', 1)" style="padding: 8px 12px;">‚¨ÜÔ∏è</button>`;
        } else {
            // Buy next level
            if (statName === 'luck' && purchased >= 10) {
                html += `<button class="btn" disabled>MAX</button>`;
            } else {
                const cost = getUpgradeCost(statName);
                const disabled = playerData.tacos < cost ? 'disabled' : '';
                html += `<button class="btn" ${disabled} onclick="buyUpgrade('${statName}')">Acheter (${cost})</button>`;
            }
        }

        container.innerHTML = html;

        // Update Label Level
        const lblId = 'lvl' + statName.charAt(0).toUpperCase() + statName.slice(1);
        const lbl = document.getElementById(lblId);
        if (lbl) lbl.innerText = active;
    }

    window.updateShopUI = function() {
        document.getElementById('shopTacos').innerText = playerData.tacos;

        renderUpgradeControl('income', 'ctrl_income');
        renderUpgradeControl('aim', 'ctrl_aim');
        renderUpgradeControl('luck', 'ctrl_luck');
        renderUpgradeControl('moonwalk', 'ctrl_moonwalk');
        renderUpgradeControl('extraLives', 'ctrl_extraLives');

        // Skin UI
        const currentAnimal = ANIMALS[viewingAnimalIndex];
        const animalSkins = SKINS_DB.filter(s => s.animal === currentAnimal);
        const skin = animalSkins[viewingSkinIndex];
        document.getElementById('animalName').innerText = currentAnimal.toUpperCase();
        document.getElementById('skinName').innerText = skin.name;
        const btn = document.getElementById('btnEquipSkin');
        const status = document.getElementById('skinStatus');
        const isUnlocked = playerData.unlockedSkins.includes(skin.id);
        const isEquipped = playerData.currentSkin === skin.id;
        if (isEquipped) { status.innerText = "√âquip√©"; btn.style.display = 'none'; }
        else if (isUnlocked) { status.innerText = "Poss√©d√©"; btn.style.display = 'inline-block'; btn.innerText = "√âquiper"; btn.disabled = false; }
        else { status.innerText = `Co√ªt: ${skin.cost} Tacos`; btn.style.display = 'inline-block'; btn.innerText = "Acheter"; btn.disabled = playerData.tacos < skin.cost; }

        // Style UI
        const style = SHOOTING_STYLES[viewingStyleIndex];
        document.getElementById('styleName').innerText = style.name;
        document.getElementById('styleDesc').innerText = style.desc;
        const btnStyle = document.getElementById('btnEquipStyle');
        const statusStyle = document.getElementById('styleStatus');
        const isUnlockedStyle = playerData.unlockedStyles ? playerData.unlockedStyles.includes(style.id) : (style.id === 'classic');
        const isEquippedStyle = playerData.currentStyle === style.id;

        if (isEquippedStyle) { statusStyle.innerText = "√âquip√©"; btnStyle.style.display = 'none'; }
        else if (isUnlockedStyle) { statusStyle.innerText = "Poss√©d√©"; btnStyle.style.display = 'inline-block'; btnStyle.innerText = "√âquiper"; btnStyle.disabled = false; }
        else { statusStyle.innerText = `Co√ªt: ${style.cost} Tacos`; btnStyle.style.display = 'inline-block'; btnStyle.innerText = "Acheter"; btnStyle.disabled = playerData.tacos < style.cost; }

        const btnHand = document.getElementById('btnToggleHand');
        btnHand.innerText = playerData.isLefty ? "MAIN: GAUCHER" : "MAIN: DROITIER";
    }
    window.toggleMode = function() {
        if(state !== 'IDLE' && state !== 'GAMEOVER') return;
        if(currentGameMode === 'CLASSIC') {
            currentGameMode = 'CONTEST';
            document.getElementById('modeBtnText').innerText = "CONCOURS";
        } else if (currentGameMode === 'CONTEST') {
            currentGameMode = 'TIME_ATTACK';
            document.getElementById('modeBtnText').innerText = "TIME ATTACK";
        } else {
            currentGameMode = 'CLASSIC';
            document.getElementById('modeBtnText').innerText = "CLASSIQUE";
        }
        resetGame();
    }
    window.toggleMuteUI = function() {
        if (!AudioSystem.ctx) AudioSystem.init();
        const isMuted = AudioSystem.toggleMute();
        const btn = document.getElementById('btn-mute');
        if (btn) btn.innerText = isMuted ? "üîá" : "üîä";
    }
    window.prevTrack = function() {
        if (!AudioSystem.ctx) AudioSystem.init();
        AudioSystem.changeTrack(-1);
    }
    window.nextTrack = function() {
        if (!AudioSystem.ctx) AudioSystem.init();
        AudioSystem.changeTrack(1);
    }

    // --- GAME LOOP ---
    function drawStartupScene() {
        // Dark Background
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Calculate positions for 2D Composition (Giant Cat + Hoop)
        // We will mock project() returns manually or just draw directly using screen coordinates
        // since we want a specific poster layout regardless of 3D camera.

        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const scale = 2.0; // Base scale

        // 1. Hoop (Right side of center)
        const hoopX = centerX + 150;
        const hoopY = centerY + 50;
        const hoopP = { x: hoopX, y: hoopY, scale: scale * 1.5 };

        // Draw Hoop Manually (reuse drawHoop logic but simplified or just call it if it's robust)
        // drawHoop depends on projection for the pole... let's mock it
        ctx.fillStyle = '#444'; ctx.fillRect(hoopX - 5, hoopY, 10, 300); // Pole
        // Backboard/Rim
        const bbW = 60 * hoopP.scale; const bbH = 40 * hoopP.scale; const bbX = hoopX - bbW/2; const bbY = hoopY - bbH - 10*hoopP.scale;
        ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(bbX, bbY, bbW, bbH);
        ctx.strokeStyle = '#333'; ctx.lineWidth = 2*hoopP.scale; ctx.strokeRect(bbX, bbY, bbW, bbH);
        ctx.fillStyle = '#CE1126'; ctx.fillRect(bbX + bbW*0.35, bbY + bbH*0.6, bbW*0.3, bbH*0.3);
        ctx.beginPath(); ctx.ellipse(hoopX, hoopY, 18 * hoopP.scale, 5 * hoopP.scale, 0, 0, Math.PI * 2);
        ctx.strokeStyle = 'orange'; ctx.lineWidth = 4 * hoopP.scale; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(hoopX - 15*hoopP.scale, hoopY); ctx.lineTo(hoopX - 10*hoopP.scale, hoopY + 20*hoopP.scale); ctx.lineTo(hoopX + 10*hoopP.scale, hoopY + 20*hoopP.scale); ctx.lineTo(hoopX + 15*hoopP.scale, hoopY);
        ctx.strokeStyle = 'white'; ctx.lineWidth = 1*hoopP.scale; ctx.stroke();

        // 2. Giant Taco Cat (Left side of center)
        const catX = centerX - 150;
        const catY = centerY + 50;
        const catP = { x: catX, y: catY, scale: scale * 3.5 }; // Giant
        drawDecor(catP, 'tacocat', 'default', 0.5);

        // 3. Fire Ball (In the hoop)
        const ballP = { x: hoopX, y: hoopY + 20, scale: scale * 1.5 };
        drawBallSprite(ballP.x, ballP.y, ballP.scale, true, Date.now() / -500);
    }

    function draw() {
        if (state === 'STARTUP') {
            drawStartupScene();
        } else {
            drawBackground();
            drawBroadcastLowerThird();
        }
    }

    let lastTime = 0;
    let accumulator = 0;
    const FIXED_STEP = 1000 / 60; // 60 FPS physics (16.666ms)

    function loop(timestamp) {
        requestAnimationFrame(loop);
        if (!lastTime) lastTime = timestamp;
        let frameTime = timestamp - lastTime;
        lastTime = timestamp;

        // Prevent spiral of death if browser hangs
        if (frameTime > 250) frameTime = 250;

        accumulator += frameTime;

        if (typeof GamepadController !== 'undefined') {
            GamepadController.update();
        }

        while (accumulator >= FIXED_STEP) {
            // update() expects dt in "frames" (1.0 = 16.66ms)
            // Since our logic was built around 1.0 being ~60fps, we pass 1.0.
            update(1.0);
            accumulator -= FIXED_STEP;
        }

        draw();
    }

    // --- GAMEPAD CONTROLLER ---
    const GamepadController = {
        active: false,
        focusedElement: null,
        focusIndex: 0,
        focusableElements: [],
        lastButtonState: {},
        lastState: null,
        navDelay: 0,

        // Mapping (Standard)
        BTN_A: 0, BTN_B: 1, BTN_X: 2, BTN_Y: 3,
        BTN_UP: 12, BTN_DOWN: 13, BTN_LEFT: 14, BTN_RIGHT: 15,

        update: function() {
            const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
            const gp = gamepads[0] || gamepads[1] || gamepads[2] || gamepads[3]; // Check all slots
            if (!gp) return;

            // Only activate if a button is pressed or previously active
            if (!this.active && gp.buttons.some(b => b.pressed)) this.active = true;
            if (!this.active) return;

            // Check State Change
            if (this.lastState !== state) {
                this.refreshFocusList();
                this.lastState = state;
            }

            // Navigation
            this.handleNavigation(gp);

            // Actions
            this.handleActions(gp);

            // Save state
            for(let i=0; i<gp.buttons.length; i++) {
                this.lastButtonState[i] = gp.buttons[i].pressed;
            }
        },

        isPressed: function(gp, btnIndex) {
            return gp.buttons[btnIndex] && gp.buttons[btnIndex].pressed && !this.lastButtonState[btnIndex];
        },

        isReleased: function(gp, btnIndex) {
            return gp.buttons[btnIndex] && !gp.buttons[btnIndex].pressed && this.lastButtonState[btnIndex];
        },

        handleNavigation: function(gp) {
            if (this.navDelay > 0) {
                this.navDelay--;
                return;
            }

            // Check D-Pad
            let dx = 0; let dy = 0;
            if (gp.buttons[12] && gp.buttons[12].pressed) dy = -1;
            if (gp.buttons[13] && gp.buttons[13].pressed) dy = 1;
            if (gp.buttons[14] && gp.buttons[14].pressed) dx = -1;
            if (gp.buttons[15] && gp.buttons[15].pressed) dx = 1;

            // Check Left Stick (Threshold 0.5)
            if (gp.axes[0] && Math.abs(gp.axes[0]) > 0.5) dx = Math.sign(gp.axes[0]);
            if (gp.axes[1] && Math.abs(gp.axes[1]) > 0.5) dy = Math.sign(gp.axes[1]);

            if (dx !== 0 || dy !== 0) {
                this.moveFocus(dx, dy);
                this.navDelay = 12; // ~200ms debounce
            }
        },

        moveFocus: function(dx, dy) {
            this.refreshFocusList();
            if (this.focusableElements.length === 0) return;

            // Slider Handling (Left/Right)
            if (this.focusedElement && this.focusedElement.tagName === 'INPUT' && this.focusedElement.type === 'range' && dx !== 0) {
                const step = parseFloat(this.focusedElement.step) || 1;
                const val = parseFloat(this.focusedElement.value);
                const min = parseFloat(this.focusedElement.min);
                const max = parseFloat(this.focusedElement.max);

                let newVal = val;
                if (dx > 0) newVal = Math.min(max, val + step);
                if (dx < 0) newVal = Math.max(min, val - step);

                if (newVal !== val) {
                    this.focusedElement.value = newVal;
                    this.focusedElement.dispatchEvent(new Event('input'));
                }
                return;
            }

            // Navigation Logic
            // Simple mapping: Up/Left -> Prev, Down/Right -> Next
            // This works well for the vertical lists in modals and horizontal list in main menu
            let direction = (dx + dy);
            // Bias vertical for Up/Down, horizontal for Left/Right?
            // Actually, simply summing works for standard lists.
            // But Left (-1) + Down (+1) = 0.
            // Let's strictly prioritize:
            if (dy !== 0) direction = dy;
            else if (dx !== 0) direction = dx;

            if (direction > 0) this.focusIndex++;
            else if (direction < 0) this.focusIndex--;

            if (this.focusIndex < 0) this.focusIndex = this.focusableElements.length - 1;
            if (this.focusIndex >= this.focusableElements.length) this.focusIndex = 0;

            this.applyFocus();
        },

        refreshFocusList: function() {
            let containerSelector = '';
            if (state === 'STARTUP') containerSelector = '#startup-ui';
            else if (state === 'IDLE') containerSelector = '#controls';
            else if (state === 'SHOP') containerSelector = '#shopUI';
            else if (state === 'STATS') containerSelector = '#statsUI';
            else if (state === 'ACHIEVEMENTS') containerSelector = '#achUI';

            if (!containerSelector) {
                this.clearFocus();
                return;
            }

            const container = document.querySelector(containerSelector);
            if(!container) return;

            const all = Array.from(container.querySelectorAll('button, .ui-btn, input'));
            this.focusableElements = all.filter(el => {
                return el.offsetParent !== null && !el.disabled && el.style.display !== 'none';
            });

            if (!this.focusedElement || !this.focusableElements.includes(this.focusedElement)) {
                this.focusIndex = 0;
                this.applyFocus();
            } else {
                this.focusIndex = this.focusableElements.indexOf(this.focusedElement);
            }
        },

        applyFocus: function() {
            document.querySelectorAll('.gamepad-focus').forEach(el => el.classList.remove('gamepad-focus'));
            this.focusedElement = this.focusableElements[this.focusIndex];
            if (this.focusedElement) {
                this.focusedElement.classList.add('gamepad-focus');
                // Scroll if needed (for long lists)
                if(this.focusedElement.scrollIntoView) {
                    this.focusedElement.scrollIntoView({ behavior: 'auto', block: 'nearest' });
                }
            }
        },

        clearFocus: function() {
            document.querySelectorAll('.gamepad-focus').forEach(el => el.classList.remove('gamepad-focus'));
            this.focusedElement = null;
            this.focusableElements = [];
        },

        handleActions: function(gp) {
            // A Button: Select/Click
            if (this.isPressed(gp, this.BTN_A)) {
                if (this.focusedElement) {
                    this.focusedElement.click();
                    this.refreshFocusList();
                }
            }

            // B Button: Back
            if (this.isPressed(gp, this.BTN_B)) {
                if (state === 'SHOP') closeShop();
                else if (state === 'STATS') closeStats();
                else if (state === 'ACHIEVEMENTS') closeAchievements();
            }

            // X Button: Shoot (Game Action)
            if (this.isPressed(gp, this.BTN_X)) {
                if (state === 'GAMEOVER') openShop();
                else if (state === 'IDLE') startJump();
            }
            if (this.isReleased(gp, this.BTN_X)) {
                if (state === 'JUMPING') releaseShot();
            }
        }
    };

    // Start buttons
    const mobBtn = document.getElementById('mobileShootBtn');
    mobBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (state === 'GAMEOVER') openShop(); else if (state === 'IDLE') startJump();
    }, {passive: false});
    mobBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (state === 'JUMPING') releaseShot();
    }, {passive: false});

    window.addEventListener('keydown', (e) => {
        if(state === 'SHOP') { if(e.code === 'Escape') closeShop(); return; }
        if(state === 'ACHIEVEMENTS') { if(e.code === 'Escape') closeAchievements(); return; }
        if(state === 'STATS') { if(e.code === 'Escape') closeStats(); return; }
        if(e.code === 'KeyP') openShop(); if(e.code === 'KeyO') openAchievements(); if(e.code === 'KeyS') openStats();
        if (e.code === 'Space' && !spacePressed) { spacePressed = true; if (state === 'GAMEOVER') openShop(); else if (state === 'IDLE') startJump(); }
    });
    window.addEventListener('keyup', (e) => { if (e.code === 'Space') { spacePressed = false; if (state === 'JUMPING') releaseShot(); } });
    window.addEventListener('mousedown', (e) => {
        if(e.target.closest('.modal') || e.target.closest('.ui-btn') || e.target.closest('.broadcast-btn') || e.target.closest('.broadcast-icon-btn')) return;
        if (state === 'IDLE' && playerData.mobileControls) return;
        if (state === 'GAMEOVER') openShop(); else if (state === 'IDLE') startJump();
    });
    window.addEventListener('mouseup', () => {
        if (state === 'JUMPING' && playerData.mobileControls) return;
        if (state === 'JUMPING') releaseShot();
    });

    // Initial resize call
    resizeGame();
    checkStartup();
    // Start loop
    requestAnimationFrame(loop);
</script>
</body>
</html>
