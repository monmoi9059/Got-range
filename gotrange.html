<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Taco Basket Ball - Qu√©bec √âdition (Remastered)</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #game-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 800px;
            height: 600px;
            background: #000;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            transform-origin: center;
        }

        canvas {
            border: 8px solid #5D4037;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5);
            border-radius: 4px;
            width: 100%;
            height: 100%;
            display: block;
            box-sizing: border-box;
        }

        /* UI Overlay Elements */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .hud-text {
            position: absolute;
            font-weight: 900;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
        }

        #title { top: 20px; left: 20px; font-size: 42px; color: #FFD700; text-shadow: 3px 3px 0 #8B0000; font-style: italic; }
        #score-box { top: 70px; left: 20px; font-size: 1.2em; text-align: left; }
        #strikes-box { top: 20px; right: 20px; font-size: 1.5em; color: #FF4500; }
        #court-name { top: 60px; right: 20px; font-size: 1.5em; color: rgba(255,255,255,0.7); font-style: italic; text-align: right; text-transform: uppercase; }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: auto;
            z-index: 20;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        .ui-btn {
            background: linear-gradient(to bottom, #FFD700, #DAA520);
            color: #000;
            border: 2px solid #fff;
            padding: 8px 18px;
            cursor: pointer;
            font-weight: 800;
            border-radius: 6px;
            box-shadow: 0 4px 0 #B8860B;
            transition: transform 0.1s, background 0.1s;
            font-size: 16px;
            text-transform: uppercase;
        }
        .ui-btn:active { transform: translateY(4px); box-shadow: 0 0 0 #B8860B; }
        .ui-btn:hover { background: #fff; }

        /* Modals */
        .modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 550px;
            max-height: 85%;
            overflow-y: auto;
            background: rgba(30, 30, 30, 0.98);
            border: 4px solid #DAA520;
            padding: 25px;
            color: white;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 50px rgba(0,0,0,0.9);
            border-radius: 15px;
            opacity: 0;
            transition: opacity 0.2s, transform 0.2s;
        }
        .modal.open { display: block; opacity: 1; transform: translate(-50%, -50%) scale(1); }

        /* Modal Content Styling */
        .modal-header { color: #FFD700; margin-bottom: 20px; font-size: 2.2em; text-shadow: 2px 2px #d32f2f; font-weight: 800; border-bottom: 2px solid #555; padding-bottom: 10px; }
        .upgrade-row { display: flex; justify-content: space-between; align-items: center; background: rgba(255,255,255,0.05); margin: 10px 0; padding: 15px; border-radius: 8px; border: 1px solid #444; text-align: left; }
        .difficulty-row { background: rgba(0, 0, 0, 0.6); border: 1px solid #FFD700; margin: 15px 0; padding: 15px; border-radius: 8px; text-align: left; }
        input[type=range] { width: 100%; margin: 15px 0; cursor: pointer; accent-color: #FFD700; }

        .ach-row {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.5); border: 1px solid #555;
            margin: 8px 0; padding: 12px; border-radius: 8px; text-align: left;
            opacity: 0.7; transition: 0.3s;
        }
        .ach-row.unlocked {
            border-color: #00FF00; background: linear-gradient(to right, rgba(0, 100, 0, 0.4), rgba(0, 50, 0, 0.2));
            opacity: 1; box-shadow: 0 0 10px rgba(0, 255, 0, 0.1);
        }
        .ach-icon { font-size: 28px; margin-right: 15px; }

        .skin-viewer { margin-top: 20px; border-top: 2px solid #555; padding-top: 15px; background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; }
        .skin-nav { display: flex; justify-content: center; align-items: center; gap: 15px; margin: 10px 0; }
        .selector-label { width: 180px; font-size: 1.2em; color: #FFD700; font-weight: bold; text-transform: uppercase; }

        .btn { background: linear-gradient(to bottom, #228B22, #006400); color: white; border: none; padding: 8px 20px; cursor: pointer; font-weight: bold; border-radius: 4px; box-shadow: 0 3px 0 #004d00; }
        .btn:active { transform: translateY(3px); box-shadow: none; }
        .btn:disabled { background: #555; cursor: not-allowed; box-shadow: none; transform: none; color: #888; }
        .btn-close { background: #d32f2f; width: 100%; margin-top: 20px; box-shadow: 0 4px 0 #8B0000; }

        /* Notifications */
        #notification {
            position: absolute;
            bottom: 150px; left: 50%; transform: translateX(-50%);
            background: linear-gradient(to right, #000, #333);
            border: 2px solid #FFD700; color: #FFD700;
            padding: 15px 40px; border-radius: 50px;
            font-size: 1.2em; font-weight: bold;
            display: none; z-index: 200; text-align: center;
            box-shadow: 0 0 25px #FFD700;
            animation: popUp 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popUp { from { bottom: 100px; opacity: 0; } to { bottom: 150px; opacity: 1; } }

        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 10px; }
        ::-webkit-scrollbar-track { background: #333; }
        ::-webkit-scrollbar-thumb { background: #DAA520; border-radius: 5px; }

        /* Helper Classes */
        .text-green { color: #00FF00; }
        .text-gold { color: #FFD700; }
        .text-red { color: #FF0000; }
        .w-100 { width: 100%; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="title" class="hud-text">TACO BASKET BALL</div>
        <div id="score-box" class="hud-text">
            <p>Tacos: <span id="scoreVal" class="text-green">0</span></p>
            <div id="classic-stats">
                <p>Distance: <span id="distVal" class="text-green">10 ft</span></p>
                <p>Record: <span id="highScoreVal" class="text-gold">10 ft</span></p>
            </div>
        </div>
        <div id="strikes-box" class="hud-text">MISS: <span id="missVal">0</span>/2</div>
        <div id="court-name" class="hud-text">COUR ARRI√àRE</div>

        <div id="notification">
            <div>üèÜ SUCC√àS D√âBLOQU√â !</div>
            <div id="notifText" style="color:white; font-size:0.8em; margin-top:5px;">Rookie</div>
        </div>
    </div>

    <div id="controls">
        <div class="ui-btn" onclick="Game.toggleMode()">MODE: <span id="modeBtnText">CLASSIQUE</span></div>
        <div class="ui-btn" onclick="UI.openShop()">BOUTIQUE [P]</div>
        <div class="ui-btn" onclick="UI.openAchievements()">TROPH√âES [O]</div>
        <div class="ui-btn" onclick="UI.openStats()">STATS [S]</div>
    </div>

    <!-- UI TEMPLATES (Populated by JS) -->
    <div id="shopUI" class="modal">
        <div class="modal-header">TACO MERCADO</div>
        <p>Tacos: <span id="shopTacos" class="text-gold" style="font-size: 1.2em;">0</span></p>
        <div id="shop-content"></div>
        <button class="btn btn-close" onclick="UI.closeAll()">FERMER</button>
    </div>

    <div id="achUI" class="modal">
        <div class="modal-header">SALLE DES TROPH√âES</div>
        <div id="achList" style="text-align: left;"></div>
        <button class="btn btn-close" onclick="UI.closeAll()">FERMER</button>
    </div>

    <div id="statsUI" class="modal">
        <div class="modal-header">STATISTIQUES</div>
        <div id="statsContent" style="text-align:left; font-size:1.2em; padding:10px;"></div>
        <button id="btnReset" class="btn" style="background: #8B0000; margin-top: 20px; width: 100%; border: 1px solid #ff4444;" onclick="Game.attemptReset()">R√âINITIALISER PROGRESSION</button>
        <button class="btn btn-close" onclick="UI.closeAll()">FERMER</button>
    </div>
</div>

<script>
/**
 * TACO BASKET BALL - REMASTERED
 * Organized into Classes for cleaner architecture.
 */

// --- 1. CONFIGURATION & DATA ---
const CONSTANTS = {
    GRAVITY: 0.5,
    HOOP_POS: { x: 600, y: 150, z: 130 },
    CANVAS_WIDTH: 800,
    CANVAS_HEIGHT: 600
};

const DATA = {
    ACHIEVEMENTS: [
        { id: 'rookie', name: 'Recrue', desc: 'Premier panier marqu√©', reward: 10 },
        { id: 'veteran', name: 'V√©t√©ran', desc: 'Marquer 100 paniers au total', reward: 150 },
        { id: 'ball_hog', name: 'Ball Hog', desc: 'Tirer 500 fois', reward: 100 },
        { id: 'bricklayer', name: 'Briqueur', desc: 'Rater 50 tirs', reward: 25 },
        { id: 'amateur', name: 'Amateur', desc: 'Atteindre 25 pi', reward: 25 },
        { id: 'sniper', name: 'Sniper', desc: 'Atteindre 50 pi', reward: 50 },
        { id: 'pro', name: 'Pro Shooter', desc: 'Atteindre 75 pi', reward: 75 },
        { id: 'parking_lot', name: 'Parking', desc: 'Atteindre 100 pi', reward: 100 },
        { id: 'longshot', name: 'Longue Distance', desc: 'Atteindre 125 pi', reward: 125 },
        { id: 'levis_legend', name: 'L√©vis Legend', desc: 'Atteindre 150 pi', reward: 200 },
        { id: 'interstellar', name: 'Interstellaire', desc: 'Atteindre 200 pi', reward: 300 },
        { id: 'moonwalker', name: 'Marcheur Lunaire', desc: 'Atteindre 500 pi', reward: 500 },
        { id: 'demigod', name: 'Demi-Dieu', desc: 'Atteindre 1000 pi', reward: 1000 },
        { id: 'contest_winner', name: 'Roi du Concours', desc: 'Score > 10 au Concours', reward: 200 },
        { id: 'contest_perfect', name: 'Perfection', desc: 'Score > 20 au Concours', reward: 500 },
        { id: 'pocket_change', name: 'Fond de poche', desc: 'Avoir 100 Tacos', reward: 10 },
        { id: 'tycoon', name: 'Taco Tycoon', desc: 'Avoir 500 Tacos', reward: 50 },
        { id: 'millionaire', name: 'Millionaire', desc: 'Avoir 2000 Tacos', reward: 200 },
        { id: 'sweet_tooth', name: 'Bec Sucr√©', desc: 'Sirop √ârable Niv 5', reward: 100 },
        { id: 'hawkeye', name: 'Oeil de Lynx', desc: 'Vis√©e Assist√©e Niv 5', reward: 100 },
        { id: 'leprechaun', name: 'Chanceux', desc: 'Taco Grease Niv 5', reward: 100 },
        { id: 'fashionista', name: 'Fashionista', desc: 'D√©bloquer 5 skins', reward: 100 },
        { id: 'wardrobe_malfunction', name: 'Garde-robe Pleine', desc: 'D√©bloquer 10 skins', reward: 300 },
        { id: 'collector', name: 'Collectionneur', desc: 'D√©bloquer 15 skins', reward: 500 },
        { id: 'zoo', name: 'Gardien de Zoo', desc: 'Skins pour 3 animaux diff√©rents', reward: 150 },
        { id: 'lucky', name: 'Chance Pure', desc: 'Avoir un rebond chanceux', reward: 25 },
        { id: 'daredevil', name: 'Casse-cou', desc: 'Marquer en difficult√© max', reward: 50 },
        { id: 'hard_mode', name: 'Travaillant', desc: 'Marquer en mode Difficile', reward: 25 },
        { id: 'cosplay', name: 'Cosplay', desc: '√âquiper Robot/Alien/Ninja', reward: 20 },
        { id: 'eh', name: 'Canadien', desc: '√âquiper B√ªcheron ou Hockey', reward: 20 },
        { id: 'spooky', name: 'Effrayant', desc: '√âquiper Zombie/Vampire/Diable', reward: 20 },
        { id: 'urban_legend', name: 'L√©gende Urbaine', desc: 'Jouer sur le Terrain de Rue', reward: 50 },
        { id: 'ice_cold', name: 'Glace', desc: 'Jouer sur la Patinoire', reward: 100 },
        { id: 'astronaut_training', name: 'Cadet Spatial', desc: 'Jouer sur la Lune', reward: 150 }
    ],
    COURT_ZONES: [
        { limit: 50, name: "COUR ARRI√àRE", type: 'grass', ground1: '#228B22', ground2: '#32CD32', sky1: '#87CEEB', sky2: '#FFF' },
        { limit: 100, name: "PARC DE LA PAIX", type: 'tree', ground1: '#8B4513', ground2: '#D2691E', sky1: '#87CEEB', sky2: '#E0FFFF' },
        { limit: 200, name: "VIEUX-L√âVIS", type: 'castle', ground1: '#8B0000', ground2: '#A52A2A', sky1: '#4682B4', sky2: '#87CEEB' },
        { limit: 350, name: "TERRAIN DE RUE", type: 'castle', ground1: '#696969', ground2: '#808080', sky1: '#4682B4', sky2: '#87CEEB' },
        { limit: 500, name: "FOR√äT BOR√âALE", type: 'tree', ground1: '#006400', ground2: '#2F4F4F', sky1: '#2E8B57', sky2: '#8FBC8F' },
        { limit: 750, name: "LA PATINOIRE", type: 'mountain', ground1: '#E0FFFF', ground2: '#FFFFFF', sky1: '#87CEEB', sky2: '#F0F8FF' },
        { limit: 1000, name: "FLEUVE ST-LAURENT", type: 'water', ground1: '#00008B', ground2: '#1E90FF', sky1: '#191970', sky2: '#4169E1' },
        { limit: 1500, name: "MONT-SAINTE-ANNE", type: 'mountain', ground1: '#F0FFFF', ground2: '#E0FFFF', sky1: '#87CEEB', sky2: '#00BFFF' },
        { limit: 2500, name: "HAUTE ATMOSPH√àRE", type: 'space', ground1: '#483D8B', ground2: '#6A5ACD', sky1: '#000080', sky2: '#000000' },
        { limit: 4000, name: "BASE LUNAIRE", type: 'space', ground1: '#808080', ground2: '#A9A9A9', sky1: '#000000', sky2: '#191970' },
        { limit: 6000, name: "MARS", type: 'space', ground1: '#8B4513', ground2: '#CD853F', sky1: '#FF4500', sky2: '#000000' },
        { limit: 8000, name: "LE NETHER", type: 'space', ground1: '#8B0000', ground2: '#2F0000', sky1: '#330000', sky2: '#000000' },
        { limit: 9999999, name: "DIMENSION TACO", type: 'grass', ground1: '#FF00FF', ground2: '#00FFFF', sky1: '#FFFF00', sky2: '#FF0000' }
    ],
    SKINS_DB: [
        { id: 'rat_classic', animal: 'rat', name: 'Classique', cost: 0 },
        { id: 'rat_lumberjack', animal: 'rat', name: 'B√ªcheron', cost: 500 },
        { id: 'rat_mariachi', animal: 'rat', name: 'El Mariachi', cost: 1000 },
        { id: 'rat_luchador', animal: 'rat', name: 'Luchador', cost: 1500 },
        { id: 'rat_alien', animal: 'rat', name: 'Alien', cost: 3000 },
        { id: 'rat_zombie', animal: 'rat', name: 'Zombie', cost: 3000 },
        { id: 'rat_astronaut', animal: 'rat', name: 'Astronaute', cost: 5000 },
        { id: 'rat_ninja', animal: 'rat', name: 'Ninja', cost: 5000 },
        { id: 'rat_robot', animal: 'rat', name: 'Robot', cost: 5000 },
        { id: 'rat_pirate', animal: 'rat', name: 'Pirate', cost: 1500 },
        { id: 'rat_clown', animal: 'rat', name: 'Clown', cost: 1500 },
        { id: 'rat_vampire', animal: 'rat', name: 'Vampire', cost: 3000 },
        { id: 'rat_chef', animal: 'rat', name: 'Chef', cost: 750 },
        { id: 'rat_hockey', animal: 'rat', name: 'Joueur Hockey', cost: 7500 },
        { id: 'rat_poutine', animal: 'rat', name: 'Poutine', cost: 7500 },
        { id: 'rat_king', animal: 'rat', name: 'Roi', cost: 10000 },
        { id: 'rat_wizard', animal: 'rat', name: 'Sorcier', cost: 10000 },
        { id: 'rat_devil', animal: 'rat', name: 'Diable', cost: 15000 },
        { id: 'rat_angel', animal: 'rat', name: 'Ange', cost: 15000 },
        { id: 'cat_classic', animal: 'cat', name: 'Classique', cost: 250 },
        { id: 'cat_tabby', animal: 'cat', name: 'Tigr√©', cost: 1000 },
        { id: 'cat_tuxedo', animal: 'cat', name: 'Tuxedo', cost: 1000 },
        { id: 'dog_classic', animal: 'dog', name: 'Classique', cost: 250 },
        { id: 'dog_dalmation', animal: 'dog', name: 'Dalmatien', cost: 1000 },
        { id: 'dog_pug', animal: 'dog', name: 'Carlin', cost: 1500 },
        { id: 'bear_classic', animal: 'bear', name: 'Classique', cost: 500 },
        { id: 'bear_panda', animal: 'bear', name: 'Panda', cost: 3000 },
        { id: 'bear_polar', animal: 'bear', name: 'Polaire', cost: 3000 },
        { id: 'rabbit_classic', animal: 'rabbit', name: 'Classique', cost: 250 },
        { id: 'rabbit_jack', animal: 'rabbit', name: 'Li√®vre', cost: 1000 },
        { id: 'rabbit_magic', animal: 'rabbit', name: 'Magicien', cost: 2500 },
        { id: 'beaver_classic', animal: 'beaver', name: 'Classique', cost: 500 },
        { id: 'beaver_lumber', animal: 'beaver', name: 'B√ªcheron', cost: 1500 },
        { id: 'moose_classic', animal: 'moose', name: 'Classique', cost: 750 },
        { id: 'moose_royal', animal: 'moose', name: 'Royal', cost: 5000 },
        { id: 'penguin_classic', animal: 'penguin', name: 'Classique', cost: 750 },
        { id: 'penguin_emperor', animal: 'penguin', name: 'Empereur', cost: 3000 },
        { id: 'raccoon_classic', animal: 'raccoon', name: 'Classique', cost: 500 },
        { id: 'raccoon_bandit', animal: 'raccoon', name: 'Bandit', cost: 1500 }
    ],
    ANIMALS: ['rat', 'cat', 'dog', 'bear', 'rabbit', 'beaver', 'moose', 'penguin', 'raccoon']
};

// --- 2. CORE CLASSES ---

class Vector3 {
    constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
    add(v) { this.x+=v.x; this.y+=v.y; this.z+=v.z; return this; }
    copy() { return new Vector3(this.x, this.y, this.z); }
}

class Particle {
    constructor(x, y, z, color, type) {
        this.x = x; this.y = y; this.z = z;
        this.color = color;
        this.type = type; // 'confetti', 'dust', 'trail'
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.vz = (Math.random() * 5) + 2;
        this.life = 1.0;
        this.decay = Math.random() * 0.02 + 0.01;
        if(type === 'dust') { this.vz = Math.random() * 2; this.decay = 0.05; }
        if(type === 'trail') { this.vx *= 0.1; this.vy *= 0.1; this.vz = 0; this.decay = 0.1; }
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.z += this.vz;
        if(this.type !== 'trail') this.vz -= CONSTANTS.GRAVITY * 0.5;
        this.life -= this.decay;
        // Bounce floor
        if(this.z < 0) { this.z = 0; this.vz *= -0.5; this.vx *= 0.8; this.vy *= 0.8; }
    }
}

class BackgroundElement {
    constructor() {
        this.reset();
    }
    reset() {
        // Place elements far behind the hoop (High Positive Distance)
        // Hoop is at (600, 150). Player at (300, 300).
        // Vector Hoop->Player is (-300, 150).
        // "Behind Hoop" is (300 + d, 150 - d).

        const dist = 1000 + Math.random() * 4000;
        this.x = 600 + dist * 0.7 + (Math.random() - 0.5) * 2000;
        this.y = 150 - dist * 0.7; // "Up and Right" in world space, which is "Forward/North"
        this.z = 200 + Math.random() * 500;

        this.type = Math.random() > 0.5 ? 'cloud' : 'bird';
        this.speed = (Math.random() * 2 + 1) * (Math.random() > 0.5 ? 1 : -1);
    }
    update() {
        this.x += this.speed;
        // Reset if drifted too far laterally
        // (Simplified reset for now)
    }
}

class GameState {
    constructor() {
        const saved = JSON.parse(localStorage.getItem('tacoSaveData'));
        const def = {
            tacos: 0, level: 1, difficulty: 1.0, highScore: 10,
            stats: { income: 1, aim: 1, luck: 1, moonwalk: 1, extraLives: 0 },
            lifetimeStats: { shots: 0, makes: 0, misses: 0, contests: 0 },
            unlockedSkins: ['rat_classic'], currentSkin: 'rat_classic', unlockedAchievements: []
        };
        this.data = saved || def;
        // Fix migrations
        if(!this.data.unlockedAchievements) this.data.unlockedAchievements = [];
        if(!this.data.stats) this.data.stats = def.stats;

        this.mode = 'CLASSIC'; // CLASSIC or CONTEST
        this.state = 'IDLE'; // IDLE, JUMPING, SHOOTING, RESETTING, GAMEOVER

        this.player = { pos: new Vector3(300, 300, 0), vel: new Vector3(0,0,0), animTime: 0 };
        this.ball = { pos: new Vector3(0,0,0), vel: new Vector3(0,0,0), active: false, rotation: 0 };
        this.camera = { zoom: 800, height: 180, targetZoom: 800 };

        this.session = {
            resetStage: 0,
            distanceLevel: 1,
            consecutiveMisses: 0,
            streak: 0,
            feedback: '',
            feedbackTimer: 0,
            screenShake: 0
        };

        this.contest = { timer: 60, score: 0, rack: 1, ballsInRack: 0 };

        this.particles = [];
        this.decor = [];
        this.bgElements = [];

        // Init Decor
        for(let i=0; i<300; i++) {
            const dist = Math.random() * 10000;
            const pathX = 600 - (dist * 0.7);
            const pathY = 150 + (dist * 0.7);
            const scatter = (Math.random() - 0.5) * 1200;
            this.decor.push({ x: pathX + scatter, y: pathY + scatter, dist: dist });
        }
        for(let i=0; i<40; i++) this.bgElements.push(new BackgroundElement());
    }

    save() { localStorage.setItem('tacoSaveData', JSON.stringify(this.data)); }
}

const Game = {
    state: null,
    canvas: null,
    ctx: null,
    lastTime: 0,

    init() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.canvas.width = CONSTANTS.CANVAS_WIDTH;
        this.canvas.height = CONSTANTS.CANVAS_HEIGHT;
        this.state = new GameState();

        window.addEventListener('resize', this.resize.bind(this));
        this.resize();

        Input.init();
        this.loop(0);
        UI.update();
    },

    resize() {
        const winW = window.innerWidth;
        const winH = window.innerHeight;
        const scale = Math.min(winW / 800, winH / 600) * 0.95;
        document.getElementById('game-container').style.transform = `translate(-50%, -50%) scale(${scale})`;
    },

    loop(timestamp) {
        requestAnimationFrame(this.loop.bind(this));
        if (!this.lastTime) this.lastTime = timestamp;
        const dt = Math.min((timestamp - this.lastTime) / 16.666, 4); // Cap dt
        this.lastTime = timestamp;

        this.update(dt);
        Renderer.draw(this.ctx, this.state);
    },

    update(dt) {
        const s = this.state;

        // Background Elements
        s.bgElements.forEach(bg => bg.update());

        // Particles
        s.particles.forEach(p => p.update());
        s.particles = s.particles.filter(p => p.life > 0);

        // Screen Shake decay
        if(s.session.screenShake > 0) s.session.screenShake *= 0.9;
        if(s.session.feedbackTimer > 0) s.session.feedbackTimer -= dt;

        // Anim Time
        s.player.animTime += dt * 0.1;

        // Game Logic
        if (s.state === 'JUMPING') {
            s.player.pos.z += s.player.vel.z * dt;
            s.player.vel.z -= CONSTANTS.GRAVITY * dt;
            if (s.player.pos.z <= 0) {
                s.player.pos.z = 0; s.player.vel.z = 0;
                this.handleFail("MARCH√â!");
            }
        }

        if (s.state === 'SHOOTING') {
            // Player lands
            if (s.player.pos.z > 0) {
                s.player.pos.z += s.player.vel.z * dt;
                s.player.vel.z -= CONSTANTS.GRAVITY * dt;
                if(s.player.pos.z < 0) s.player.pos.z = 0;
            }

            if (s.ball.active) {
                // Ball Physics
                s.ball.pos.x += s.ball.vel.x * dt;
                s.ball.pos.y += s.ball.vel.y * dt;
                s.ball.pos.z += s.ball.vel.z * dt;
                s.ball.vel.z -= CONSTANTS.GRAVITY * dt;
                s.ball.rotation += 0.2 * dt;

                // Trail
                if(Math.random() < 0.3) this.spawnParticle(s.ball.pos, 'trail');

                // Check collision with hoop
                const hoopDist = Math.hypot(s.ball.pos.x - CONSTANTS.HOOP_POS.x, s.ball.pos.y - CONSTANTS.HOOP_POS.y);

                // Simple distance check for make
                if (Math.abs(s.ball.pos.z - CONSTANTS.HOOP_POS.z) < 10 && hoopDist < 25) {
                    this.handleScore();
                    return;
                }

                // Ground hit
                if (s.ball.pos.z <= 0) {
                    s.ball.pos.z = 0;
                    s.ball.active = false;
                    this.spawnParticles(s.ball.pos, 10, '#888', 'dust');
                    this.handleMiss();
                }

                // Too far
                const distFromPlayer = Math.hypot(s.ball.pos.x - s.player.pos.x, s.ball.pos.y - s.player.pos.y);
                if (distFromPlayer > 5000) { s.ball.active = false; this.handleMiss(); }
            }
        }

        // Camera Lerp
        const dxToHoop = CONSTANTS.HOOP_POS.x - s.player.pos.x;
        const dyToHoop = CONSTANTS.HOOP_POS.y - s.player.pos.y;
        const distToHoop = Math.sqrt(dxToHoop*dxToHoop + dyToHoop*dyToHoop);
        let idealZoom = 380 * (400 + distToHoop) / Math.max(100, distToHoop);
        idealZoom = Math.min(1000, Math.max(400, idealZoom));

        // Smooth camera
        s.camera.zoom += (idealZoom - s.camera.zoom) * 0.05 * dt;
    },

    spawnParticle(pos, type) {
        this.state.particles.push(new Particle(pos.x, pos.y, pos.z, '#FFF', type));
    },

    spawnParticles(pos, count, color, type) {
        for(let i=0; i<count; i++) {
            this.state.particles.push(new Particle(pos.x, pos.y, pos.z, color, type));
        }
    },

    startJump() {
        if(this.state.state !== 'IDLE') return;
        this.state.state = 'JUMPING';
        this.state.player.vel.z = 9;
        this.state.session.feedback = "";
    },

    releaseShot() {
        if(this.state.state !== 'JUMPING') return;
        const timingError = this.state.player.vel.z; // Higher is earlier release
        this.shoot(timingError);
    },

    shoot(timingError) {
        const s = this.state;
        s.state = 'SHOOTING';
        s.data.lifetimeStats.shots++;

        // Calculation
        let aimBonus = (s.data.stats.aim - 1);
        let dampener = 6.0 + aimBonus;
        const distPenalty = 1.0 + Math.pow(s.session.distanceLevel, 1.25) * 0.06;
        let accuracy = (timingError / dampener) * s.data.difficulty * distPenalty;

        // Setup Ball
        s.ball.active = true;
        s.ball.pos = s.player.pos.copy();
        s.ball.pos.z += 120; // Release height

        const dx = CONSTANTS.HOOP_POS.x - s.player.pos.x;
        const dy = CONSTANTS.HOOP_POS.y - s.player.pos.y;
        const flightTime = Math.min(120, 40 + (s.session.distanceLevel * 0.8));

        s.ball.vel.x = dx / flightTime;
        s.ball.vel.y = dy / flightTime;
        s.ball.vel.z = (CONSTANTS.HOOP_POS.z - s.ball.pos.z + 0.5 * CONSTANTS.GRAVITY * flightTime * (flightTime - 1)) / flightTime;

        // Apply inaccuracy
        let isMiss = Math.abs(accuracy) > 0.25;
        if(isMiss) {
             const luckChance = (s.data.stats.luck - 1) * 0.05;
             if(Math.random() < luckChance) {
                 isMiss = false; s.session.feedback = "CHANCEUX!";
                 Achievements.check('lucky');
             } else {
                 const scatter = (Math.random() > 0.5 ? 1 : -1) * Math.abs(accuracy) * 15;
                 const len = Math.hypot(dx, dy);
                 s.ball.vel.x += (-dy/len) * scatter;
                 s.ball.vel.y += (dx/len) * scatter;
                 s.ball.vel.z -= Math.abs(accuracy) * 5;
                 s.session.feedback = Math.abs(accuracy) > 0.5 ? "AIRBALL" : "BRIQUE";
             }
        }
    },

    handleScore() {
        const s = this.state;
        s.ball.active = false;
        s.data.lifetimeStats.makes++;
        s.session.streak++;
        s.session.consecutiveMisses = 0;

        // Effects
        this.spawnParticles(CONSTANTS.HOOP_POS, 50, '#FFD700', 'confetti');
        s.session.screenShake = 10;
        s.session.feedback = s.session.streak >= 3 ? `S√âRIE DE ${s.session.streak} üî•` : "SWISH!";
        s.session.feedbackTimer = 60;

        // Rewards
        const baseReward = 1 * s.session.distanceLevel * s.data.difficulty;
        const multiplier = 1 + (s.data.stats.income - 1) * 0.5;
        let reward = Math.ceil(baseReward * multiplier);
        if (s.session.streak > 1) reward += s.session.streak * 2;
        s.data.tacos += reward;

        // Progression
        const jump = s.data.stats.moonwalk || 1;
        s.session.distanceLevel += jump;

        Achievements.check('score');
        s.save();
        UI.update();

        s.state = 'RESETTING';
        setTimeout(() => this.nextLevel(), 1000);
    },

    handleMiss() {
        const s = this.state;
        s.ball.active = false;
        s.data.lifetimeStats.misses++;
        s.session.streak = 0;
        s.session.consecutiveMisses++;

        s.session.screenShake = 5;

        const maxMisses = 2 + (s.data.stats.extraLives || 0);
        if (s.session.consecutiveMisses >= maxMisses) {
            this.handleFail("TERMIN√â !");
        } else {
            s.session.feedback = "DERNI√àRE CHANCE !";
            s.session.feedbackTimer = 60;
            s.state = 'RESETTING';
            setTimeout(() => {
                s.state = 'IDLE'; s.player.pos.z = 0; s.player.vel.z = 0;
            }, 1000);
        }
        UI.update();
    },

    handleFail(msg) {
        this.state.session.feedback = msg;
        this.state.session.feedbackTimer = 120;
        this.state.state = 'GAMEOVER';
        setTimeout(() => UI.openShop(), 1500);
    },

    nextLevel() {
        const s = this.state;
        // Move player
        const jump = s.data.stats.moonwalk || 1;
        s.player.pos.x -= 15 * jump;
        s.player.pos.y += 15 * jump;
        s.player.pos.z = 0;
        s.player.vel.z = 0;

        s.state = 'IDLE';
        UI.update();
    },

    toggleMode() {
        // Simple toggle for now, can expand later
        const s = this.state;
        s.mode = s.mode === 'CLASSIC' ? 'CONTEST' : 'CLASSIC';
        document.getElementById('modeBtnText').innerText = s.mode;
        this.attemptReset(); // Reset when changing modes
    },

    attemptReset() {
        const s = this.state;
        const btn = document.getElementById('btnReset');
        if (s.session.resetStage === 0) {
            s.session.resetStage = 1;
            btn.innerText = "S√õR ? (CLIQUEZ ENCORE)";
            btn.style.background = "#FF0000";
            return;
        }

        // Reset Logic
        s.data = {
            tacos: 0, level: 1, difficulty: 1.0, highScore: 10,
            stats: { income: 1, aim: 1, luck: 1, moonwalk: 1, extraLives: 0 },
            lifetimeStats: { shots: 0, makes: 0, misses: 0, contests: 0 },
            unlockedSkins: ['rat_classic'], currentSkin: 'rat_classic', unlockedAchievements: []
        };
        s.save();

        s.session.resetStage = 0;
        s.session.distanceLevel = 1;
        s.session.consecutiveMisses = 0;
        s.player.pos = new Vector3(300, 300, 0);
        s.state = 'IDLE';
        s.session.feedback = "RESET!";
        s.session.feedbackTimer = 60;

        btn.innerText = "R√âINITIALISER PROGRESSION";
        btn.style.background = "#8B0000";
        UI.update();
        UI.closeAll();
        UI.populateShop(); // refresh shop UI with reset data
    }
};

const Achievements = {
    check(context) {
        const s = Game.state;
        const d = s.data;
        const dist = 10 + (s.session.distanceLevel * 5);

        const unlock = (id) => {
            if(!d.unlockedAchievements.includes(id)) {
                d.unlockedAchievements.push(id);
                const ach = DATA.ACHIEVEMENTS.find(a => a.id === id);
                if(ach) {
                    d.tacos += ach.reward;
                    UI.notify(ach.name, ach.reward);
                }
            }
        };

        if (context === 'score') {
            unlock('rookie');
            if(d.lifetimeStats.makes >= 100) unlock('veteran');
            if(dist >= 50) unlock('sniper');
            if(d.difficulty >= 2) unlock('hard_mode');
        }
    }
};

const UI = {
    viewingAnimalIndex: 0,
    viewingSkinIndex: 0,

    update() {
        const s = Game.state;
        document.getElementById('scoreVal').innerText = s.data.tacos;
        if(s.mode === 'CLASSIC') {
            const dist = 10 + (s.session.distanceLevel * 5);
            document.getElementById('distVal').innerText = dist + " pi";
            const max = 2 + (s.data.stats.extraLives || 0);
            document.getElementById('missVal').innerText = s.session.consecutiveMisses + "/" + max;
            document.getElementById('highScoreVal').innerText = s.data.highScore + " pi";

            // Find court name
            const zone = DATA.COURT_ZONES.find(z => dist < z.limit) || DATA.COURT_ZONES[DATA.COURT_ZONES.length-1];
            document.getElementById('court-name').innerText = zone.name;
        } else {
             document.getElementById('court-name').innerText = "CONCOURS";
        }
    },
    notify(name, reward) {
        const n = document.getElementById('notification');
        document.getElementById('notifText').innerText = `${name} (+${reward})`;
        n.style.display = 'block';
        setTimeout(() => n.style.display = 'none', 3000);
    },
    openShop() { document.getElementById('shopUI').classList.add('open'); this.populateShop(); Game.state.state = 'SHOP'; },
    openAchievements() { document.getElementById('achUI').classList.add('open'); this.populateAch(); Game.state.state = 'ACHIEVEMENTS'; },
    openStats() { document.getElementById('statsUI').classList.add('open'); this.populateStats(); Game.state.state = 'STATS'; },
    closeAll() {
        document.querySelectorAll('.modal').forEach(m => m.classList.remove('open'));
        if(Game.state.state !== 'GAMEOVER') Game.state.state = 'IDLE';
    },

    // --- Shop Logic ---
    populateShop() {
        const d = Game.state.data;
        document.getElementById('shopTacos').innerText = d.tacos;
        const container = document.getElementById('shop-content');
        container.innerHTML = '';

        // Difficulty Slider
        const diffRow = document.createElement('div'); diffRow.className = 'difficulty-row';
        diffRow.innerHTML = `<div><strong>DIFFICULT√â:</strong> <span id="diffLabel" class="${d.difficulty>1?'text-gold':'text-green'}">x${d.difficulty.toFixed(1)}</span></div><input type="range" min="1" max="3" step="0.5" value="${d.difficulty}" onchange="UI.setDifficulty(this.value)">`;
        container.appendChild(diffRow);

        // Upgrades
        const upgrades = [
            { id: 'income', name: "Sirop d'√ârable", desc: "Tacos x0.5/niv", costBase: 25 },
            { id: 'aim', name: "Vis√©e Assist√©e", desc: "Meilleure pr√©cision", costBase: 50 },
            { id: 'luck', name: "Taco Grease", desc: "Chance rebond", costBase: 75 },
            { id: 'moonwalk', name: "Moonwalk", desc: "Distance saut√©e", costBase: 150 },
            { id: 'extraLives', name: "Vie Extra", desc: "Coups manqu√©s permis", costBase: 1000, multi: 2 }
        ];

        upgrades.forEach(u => {
            const lvl = d.stats[u.id] || (u.id==='extraLives'?0:1);
            const cost = u.multi ? Math.floor(u.costBase * Math.pow(u.multi, lvl)) : Math.floor(u.costBase * Math.pow(lvl, 2));
            const row = document.createElement('div'); row.className = 'upgrade-row';
            row.innerHTML = `<div><strong class="text-gold">${u.name}</strong> (Niv ${lvl})<br><small style="color:#aaa">${u.desc}</small></div><button class="btn" onclick="UI.buyUpgrade('${u.id}')" ${d.tacos < cost ? 'disabled' : ''}>Acheter (${cost})</button>`;
            container.appendChild(row);
        });

        // Skin Viewer
        const viewer = document.createElement('div'); viewer.className = 'skin-viewer';
        const animal = DATA.ANIMALS[this.viewingAnimalIndex];
        const skins = DATA.SKINS_DB.filter(s => s.animal === animal);
        const skin = skins[this.viewingSkinIndex];

        viewer.innerHTML = `
            <div class="skin-nav"><button class="btn" onclick="UI.changeAnimal(-1)">&lt;</button><span class="selector-label">${animal}</span><button class="btn" onclick="UI.changeAnimal(1)">&gt;</button></div>
            <div class="skin-nav"><button class="btn" onclick="UI.changeSkin(-1)">&lt;</button><span class="selector-label">${skin.name}</span><button class="btn" onclick="UI.changeSkin(1)">&gt;</button></div>
            <button class="btn w-100" onclick="UI.buySkin('${skin.id}')" ${(!d.unlockedSkins.includes(skin.id) && d.tacos < skin.cost) ? 'disabled' : ''}>
                ${d.currentSkin === skin.id ? '√âQUIP√â' : (d.unlockedSkins.includes(skin.id) ? '√âQUIPER' : `ACHETER (${skin.cost})`)}
            </button>
        `;
        container.appendChild(viewer);
    },

    setDifficulty(val) {
        Game.state.data.difficulty = parseFloat(val);
        Game.state.save();
        this.populateShop();
    },

    buyUpgrade(id) {
        const d = Game.state.data;
        // Re-calc cost (duplicated logic, strictly should be method)
        const u = { costBase: (id==='income'?25:id==='aim'?50:id==='luck'?75:id==='moonwalk'?150:1000) };
        const lvl = d.stats[id];
        const cost = id==='extraLives' ? Math.floor(1000 * Math.pow(2, lvl)) : Math.floor(u.costBase * Math.pow(lvl, 2));

        if(d.tacos >= cost) {
            d.tacos -= cost;
            d.stats[id]++;
            Game.state.save();
            this.update();
            this.populateShop();
        }
    },

    changeAnimal(dir) {
        this.viewingAnimalIndex += dir;
        if(this.viewingAnimalIndex < 0) this.viewingAnimalIndex = DATA.ANIMALS.length - 1;
        if(this.viewingAnimalIndex >= DATA.ANIMALS.length) this.viewingAnimalIndex = 0;
        this.viewingSkinIndex = 0;
        this.populateShop();
    },

    changeSkin(dir) {
        const animal = DATA.ANIMALS[this.viewingAnimalIndex];
        const skins = DATA.SKINS_DB.filter(s => s.animal === animal);
        this.viewingSkinIndex += dir;
        if(this.viewingSkinIndex < 0) this.viewingSkinIndex = skins.length - 1;
        if(this.viewingSkinIndex >= skins.length) this.viewingSkinIndex = 0;
        this.populateShop();
    },

    buySkin(id) {
        const d = Game.state.data;
        const skin = DATA.SKINS_DB.find(s => s.id === id);
        if(d.unlockedSkins.includes(id)) {
            d.currentSkin = id;
        } else if (d.tacos >= skin.cost) {
            d.tacos -= skin.cost;
            d.unlockedSkins.push(id);
            d.currentSkin = id;
        }
        Game.state.save();
        this.populateShop();
    },

    populateAch() {
        const list = document.getElementById('achList');
        list.innerHTML = '';
        DATA.ACHIEVEMENTS.forEach(ach => {
            const unlocked = Game.state.data.unlockedAchievements.includes(ach.id);
            list.innerHTML += `<div class="ach-row ${unlocked?'unlocked':''}"><div><span class="ach-icon">${unlocked?'üèÜ':'üîí'}</span> <strong>${ach.name}</strong><br><small>${ach.desc}</small></div>${unlocked?'<span class="text-green">‚úì</span>':''}</div>`;
        });
    },

    populateStats() {
        const ls = Game.state.data.lifetimeStats;
        document.getElementById('statsContent').innerHTML = `
            <p>Tirs: ${ls.shots}</p>
            <p>Paniers: ${ls.makes}</p>
            <p>Rat√©s: ${ls.misses}</p>
            <p>Pr√©cision: ${ls.shots>0 ? ((ls.makes/ls.shots)*100).toFixed(1) : 0}%</p>
        `;
    }
};

const Input = {
    init() {
        window.addEventListener('keydown', e => {
            if(e.code === 'Space') { if(Game.state.state === 'IDLE') Game.startJump(); }
            if(e.code === 'KeyP') UI.openShop();
            if(e.code === 'KeyO') UI.openAchievements();
            if(e.code === 'KeyS') UI.openStats();
            if(e.code === 'Escape') UI.closeAll();
        });
        window.addEventListener('keyup', e => {
            if(e.code === 'Space') { if(Game.state.state === 'JUMPING') Game.releaseShot(); }
        });
        window.addEventListener('mousedown', e => {
            if(e.target.closest('.ui-btn') || e.target.closest('.modal')) return;
            if(Game.state.state === 'IDLE') Game.startJump();
        });
        window.addEventListener('mouseup', () => { if(Game.state.state === 'JUMPING') Game.releaseShot(); });
    }
};

const Renderer = {
    project(v, s) {
        const cam = s.camera;
        const dxToHoop = CONSTANTS.HOOP_POS.x - s.player.pos.x;
        const dyToHoop = CONSTANTS.HOOP_POS.y - s.player.pos.y;

        const angleToHoop = Math.atan2(dyToHoop, dxToHoop);
        const rotation = -angleToHoop - Math.PI/2;

        const dx = v.x - s.player.pos.x;
        const dy = v.y - s.player.pos.y;

        const rx = dx * Math.cos(rotation) - dy * Math.sin(rotation);
        const ry = dx * Math.sin(rotation) + dy * Math.cos(rotation);

        const cameraOffset = 400;
        const depth = cameraOffset - ry;

        if (depth <= 0) return null;

        const scale = cam.zoom / depth;
        const screenX = CONSTANTS.CANVAS_WIDTH / 2 + (rx * scale);

        // Screenshake
        const shakeX = (Math.random()-0.5) * s.session.screenShake;
        const shakeY = (Math.random()-0.5) * s.session.screenShake;

        const horizonY = (CONSTANTS.CANVAS_HEIGHT - 120) * 0.5;
        const screenY = horizonY + (cam.height - v.z) * scale;

        return { x: screenX + shakeX, y: screenY + shakeY, scale: scale, depth: depth };
    },

    getJoint(x, y, length, angle) { return { x: x + Math.cos(angle) * length, y: y + Math.sin(angle) * length }; },

    draw(ctx, s) {
        ctx.clearRect(0,0, ctx.canvas.width, ctx.canvas.height);

        const currentDist = 10 + (s.session.distanceLevel * 5);
        const court = DATA.COURT_ZONES.find(z => currentDist < z.limit) || DATA.COURT_ZONES[DATA.COURT_ZONES.length-1];

        // Sky
        const skyGrad = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height * 0.6);
        skyGrad.addColorStop(0, court.sky1); skyGrad.addColorStop(1, court.sky2);
        ctx.fillStyle = skyGrad; ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        // BG Elements (Parallax)
        s.bgElements.forEach(bg => {
            // Simple parallax logic: shift position based on camera but slower
            const paraX = bg.x + (s.player.pos.x * 0.5);
            const proj = this.project(new Vector3(s.player.pos.x + bg.x, s.player.pos.y + bg.y, bg.z), s);
            if(proj) {
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                if(bg.type === 'bird') {
                     ctx.beginPath(); ctx.moveTo(proj.x, proj.y); ctx.lineTo(proj.x-5*proj.scale, proj.y-2*proj.scale); ctx.lineTo(proj.x+5*proj.scale, proj.y-2*proj.scale); ctx.fill();
                } else {
                     ctx.beginPath(); ctx.arc(proj.x, proj.y, 40*proj.scale, 0, Math.PI*2); ctx.fill();
                }
            }
        });

        // Floor
        const horizonY = (ctx.canvas.height - 120) * 0.5;
        const groundGrad = ctx.createLinearGradient(0, horizonY, 0, ctx.canvas.height);
        groundGrad.addColorStop(0, court.ground1); groundGrad.addColorStop(1, court.ground2);
        ctx.fillStyle = groundGrad; ctx.fillRect(0, horizonY, ctx.canvas.width, ctx.canvas.height - horizonY);

        let renderList = [];

        // Decors
        s.decor.forEach(d => {
             const proj = this.project(new Vector3(d.x, d.y, 0), s);
             const dist = Math.hypot(d.x - CONSTANTS.HOOP_POS.x, d.y - CONSTANTS.HOOP_POS.y);
             const zone = DATA.COURT_ZONES.find(z => dist < z.limit) || DATA.COURT_ZONES[DATA.COURT_ZONES.length-1];
             if(proj) renderList.push({ type: 'decor', depth: proj.depth, proj: proj, zone: zone });
        });

        // Hoop
        const hoopProj = this.project(new Vector3(CONSTANTS.HOOP_POS.x, CONSTANTS.HOOP_POS.y, CONSTANTS.HOOP_POS.z), s);
        if(hoopProj) renderList.push({ type: 'hoop', depth: hoopProj.depth, proj: hoopProj });

        // Player
        const playerProj = this.project(s.player.pos, s);
        if(playerProj) renderList.push({ type: 'player', depth: playerProj.depth, proj: playerProj });

        // Shadow
        const shadowProj = this.project(new Vector3(s.player.pos.x, s.player.pos.y, 0), s);
        if(shadowProj) renderList.push({ type: 'shadow', depth: shadowProj.depth, proj: shadowProj });

        // Ball
        if(s.ball.active) {
            const ballProj = this.project(s.ball.pos, s);
            if(ballProj) renderList.push({ type: 'ball', depth: ballProj.depth, proj: ballProj });
        }

        // Particles
        s.particles.forEach(p => {
             const proj = this.project(new Vector3(p.x, p.y, p.z), s);
             if(proj) renderList.push({ type: 'particle', depth: proj.depth, proj: proj, obj: p });
        });

        // Sort & Draw
        renderList.sort((a,b) => b.depth - a.depth);
        renderList.forEach(item => {
            if(item.type === 'hoop') this.drawHoop(ctx, item.proj);
            if(item.type === 'player') this.drawPlayer(ctx, item.proj, s);
            if(item.type === 'shadow') this.drawShadow(ctx, item.proj);
            if(item.type === 'ball') this.drawBall(ctx, item.proj, s);
            if(item.type === 'decor') this.drawDecor(ctx, item.proj, item.zone);
            if(item.type === 'particle') this.drawParticle(ctx, item.proj, item.obj);
        });

        this.drawUI(ctx, s);
    },

    drawHoop(ctx, p) {
        const s = p.scale;
        const bbW = 60 * s; const bbH = 40 * s;
        const bbX = p.x - bbW/2; const bbY = p.y - bbH - 10*s;

        ctx.fillStyle = '#444'; ctx.fillRect(p.x - 2*s, p.y, 4*s, 500*s);
        ctx.fillStyle = 'rgba(255,255,255,0.9)'; ctx.fillRect(bbX, bbY, bbW, bbH);
        ctx.strokeStyle = '#333'; ctx.lineWidth = 2*s; ctx.strokeRect(bbX, bbY, bbW, bbH);
        ctx.fillStyle = '#CE1126'; ctx.fillRect(bbX + bbW*0.35, bbY + bbH*0.6, bbW*0.3, bbH*0.3);
        ctx.beginPath(); ctx.ellipse(p.x, p.y, 18 * s, 5 * s, 0, 0, Math.PI * 2);
        ctx.strokeStyle = 'orange'; ctx.lineWidth = 4 * s; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(p.x - 15*s, p.y); ctx.lineTo(p.x - 10*s, p.y + 20*s); ctx.lineTo(p.x + 10*s, p.y + 20*s); ctx.lineTo(p.x + 15*s, p.y);
        ctx.strokeStyle = 'white'; ctx.lineWidth = 1*s; ctx.stroke();
    },

    drawPlayer(ctx, p, state) {
        const s = p.scale;
        const skinId = state.data.currentSkin;
        const skinData = DATA.SKINS_DB.find(x => x.id === skinId);
        const animal = skinData ? skinData.animal : 'rat';

        // Squash & Stretch
        let sy = 1, sx = 1;
        if(state.state === 'JUMPING' && state.player.vel.z > 0) { sy = 1.1; sx = 0.9; }
        if(state.state === 'JUMPING' && state.player.vel.z < 0) { sy = 0.95; sx = 1.05; }
        // Idle breathe
        if(state.state === 'IDLE') { sy = 1 + Math.sin(state.player.animTime) * 0.02; }

        // Setup sizes
        let sizeMod = { w: 1, h: 1, head: 1 };
        if(animal === 'bear') sizeMod = { w: 1.4, h: 1.1, head: 1.2 };

        let bodyW = 20 * s * sizeMod.w * sx;
        let bodyH = 40 * s * sizeMod.h * sy;
        let legLen = 30 * s;
        let torsoY = p.y - legLen - bodyH;
        let headY = torsoY - (10 * s * sizeMod.head);

        // Colors
        let fur = '#555';
        if(animal==='rat') fur='#696969';
        if(animal==='cat') fur='#808080';
        if(animal==='dog') fur='#8B4513';
        if(animal==='rabbit') fur='#FFF';

        let torsoColor = fur;
        if(skinId.includes('lumberjack')) torsoColor = '#b30000';

        // Draw Legs
        this.drawLimb(ctx, p.x - 8*s, p.y - legLen, p.x - 10*s, p.y, 7*s, fur);
        this.drawLimb(ctx, p.x + 8*s, p.y - legLen, p.x + 10*s, p.y, 7*s, fur);

        // Arms Logic
        // Define joint positions for more complex animation
        const shoulderY = torsoY + 5*s;
        const shoulderX = 12 * s; // offset from center
        const armLen = 20 * s;

        // Default Angles (Idle)
        let lUpperAngle = Math.PI/2 - 0.2;
        let lLowerAngle = Math.PI/2 - 0.1;
        let rUpperAngle = Math.PI/2 + 0.2;
        let rLowerAngle = Math.PI/2 + 0.1;
        let rWristAngle = 0;

        if (state.state === 'SHOOTING') {
            // Jordan/Curry Follow Through
            // Right Arm (Shooter): High, extended, wrist flopped
            rUpperAngle = -Math.PI/2 - 0.4; // Up and slightly forward
            rLowerAngle = -Math.PI/2 - 0.4; // Straight extension
            rWristAngle = Math.PI/1.5;      // Goose neck (flop down)

            // Left Arm (Guide): Up but to side
            lUpperAngle = -Math.PI/2 + 0.5;
            lLowerAngle = -Math.PI/2 + 0.2;
        } else if (state.state === 'JUMPING') {
            // Charging shot (arms up)
            lUpperAngle = -Math.PI/2 + 0.2;
            lLowerAngle = -Math.PI/2 + 0.4;
            rUpperAngle = -Math.PI/2 - 0.2;
            rLowerAngle = -Math.PI/2 - 0.4;
        } else if(state.state === 'IDLE') {
            // Breathe
            const breathe = Math.sin(state.player.animTime) * 0.1;
            lUpperAngle += breathe;
            rUpperAngle -= breathe;
        }

        // Draw Left Arm (Behind Body)
        this.drawArm(ctx, p.x - shoulderX, shoulderY, lUpperAngle, lLowerAngle, armLen, fur, false);

        // Body
        this.drawRoundedRect(ctx, p.x - bodyW/2, torsoY, bodyW, bodyH, 10*s, torsoColor);

        // Draw Right Arm (In Front of Body)
        this.drawArm(ctx, p.x + shoulderX, shoulderY, rUpperAngle, rLowerAngle, armLen, fur, true, rWristAngle);

        // Head
        ctx.fillStyle = fur;
        ctx.beginPath(); ctx.arc(p.x, headY, 12*s*sizeMod.head, 0, Math.PI*2); ctx.fill();

        // Ears (Simple)
        if(animal==='rat' || animal==='bear') {
             ctx.beginPath(); ctx.arc(p.x-12*s, headY-5*s, 7*s, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.arc(p.x+12*s, headY-5*s, 7*s, 0, Math.PI*2); ctx.fill();
        } else if (animal==='rabbit') {
             ctx.beginPath(); ctx.ellipse(p.x-8*s, headY-20*s, 5*s, 15*s, -0.2, 0, Math.PI*2); ctx.fill();
             ctx.beginPath(); ctx.ellipse(p.x+8*s, headY-20*s, 5*s, 15*s, 0.2, 0, Math.PI*2); ctx.fill();
        }

        // Shot Meter (NBA 2K Style)
        if(state.state === 'JUMPING') {
            const maxVz = 9;
            const curVz = Math.abs(state.player.vel.z);
            let progress = 1.0 - (curVz / maxVz);
            progress = Math.max(0, Math.min(1, progress));

            const groundY = p.y + (state.player.pos.z * s);
            const meterY = groundY - (130 * s * sizeMod.h);
            const cx = p.x + (60 * s);
            const radius = 50 * s;

            // Background Arc
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 10*s;
            ctx.lineCap = 'round';
            ctx.arc(cx, meterY, radius, 0, -Math.PI / 2, true);
            ctx.stroke();

            // Green Window Calculation
            const damp = 6.0 + (state.data.stats.aim - 1);
            const pen = Math.min(4.0, 1.0 + (state.session.distanceLevel * 0.04));
            const thresh = (0.25 * damp) / (state.data.difficulty * pen);
            const greenStart = 1.0 - (thresh / maxVz);

            // Green Zone
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0,255,0,0.6)';
            ctx.lineWidth = 10*s;
            ctx.arc(cx, meterY, radius, -Math.PI/2 * Math.max(0, greenStart), -Math.PI/2, true);
            ctx.stroke();

            // Filling Arc (The actual meter)
            ctx.beginPath();
            if (progress > greenStart) ctx.strokeStyle = '#00FF00';
            else if (progress > 0.6) ctx.strokeStyle = '#FFFF00';
            else ctx.strokeStyle = '#FF4500';

            ctx.lineWidth = 8*s;
            ctx.arc(cx, meterY, radius, 0, -Math.PI/2 * progress, true);
            ctx.stroke();
        }
    },

    drawArm(ctx, sx, sy, a1, a2, len, width, color, isRight, wristAngle = 0) {
        // Upper Arm
        const elbow = this.getJoint(sx, sy, len, a1);
        this.drawLimb(ctx, sx, sy, elbow.x, elbow.y, width, color);

        // Forearm
        const wrist = this.getJoint(elbow.x, elbow.y, len * 0.9, a2); // Forearm slightly shorter
        this.drawLimb(ctx, elbow.x, elbow.y, wrist.x, wrist.y, width * 0.85, color); // Forearm slightly thinner

        // Hand
        ctx.save();
        ctx.translate(wrist.x, wrist.y);
        ctx.rotate(a2 + wristAngle);
        ctx.fillStyle = color;
        // Draw Hand (mitten shape)
        const handW = width * 1.2;
        const handH = width * 1.5;
        ctx.beginPath();
        ctx.ellipse(0, handH/2, handW/2, handH/2, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    },

    drawLimb(ctx, x1, y1, x2, y2, width, color) {
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const dx = Math.sin(angle) * (width / 2);
        const dy = Math.cos(angle) * (width / 2);

        ctx.beginPath();
        ctx.moveTo(x1 - dx, y1 + dy);
        ctx.lineTo(x2 - dx, y2 + dy);
        ctx.arc(x2, y2, width / 2, angle + Math.PI / 2, angle - Math.PI / 2);
        ctx.lineTo(x1 + dx, y1 - dy);
        ctx.arc(x1, y1, width / 2, angle - Math.PI / 2, angle + Math.PI / 2);
        ctx.closePath();

        ctx.fillStyle = color;
        ctx.fill();

        // Slight shading for realism
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 1;
        ctx.stroke();
    },

    drawRoundedRect(ctx, x, y, w, h, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.roundRect(x, y, w, h, r); ctx.fill();
    },

    drawBall(ctx, p, s) {
        ctx.fillStyle = '#FF6600';
        ctx.beginPath(); ctx.arc(p.x, p.y, 8*p.scale, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#000'; ctx.lineWidth = 1*p.scale;
        ctx.beginPath(); ctx.arc(p.x, p.y, 8*p.scale, 0, Math.PI*2); ctx.stroke();
        // Detail
        ctx.beginPath(); ctx.arc(p.x, p.y, 8*p.scale, 0, Math.PI*2); ctx.stroke();
    },

    drawShadow(ctx, p) {
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(p.x, p.y, 20*p.scale, 6*p.scale, 0, 0, Math.PI*2); ctx.fill();
    },

    drawDecor(ctx, p, zone) {
        const s = p.scale;
        if(zone.type === 'grass') {
            ctx.fillStyle = '#228B22';
            ctx.beginPath(); ctx.arc(p.x, p.y, 15*s, Math.PI, 0); ctx.fill();
            ctx.fillStyle = '#32CD32'; ctx.beginPath(); ctx.arc(p.x, p.y-10*s, 10*s, 0, Math.PI*2); ctx.fill();
        } else if (zone.type === 'tree') {
            ctx.fillStyle = '#8B4513'; ctx.fillRect(p.x-5*s, p.y-20*s, 10*s, 20*s);
            ctx.fillStyle = '#006400'; ctx.beginPath(); ctx.moveTo(p.x-20*s, p.y-15*s); ctx.lineTo(p.x+20*s, p.y-15*s); ctx.lineTo(p.x, p.y-60*s); ctx.fill();
        } else if (zone.type === 'castle') {
             ctx.fillStyle = '#555'; ctx.fillRect(p.x-10*s, p.y-40*s, 20*s, 40*s);
             ctx.beginPath(); ctx.moveTo(p.x-15*s, p.y-40*s); ctx.lineTo(p.x+15*s, p.y-40*s); ctx.lineTo(p.x, p.y-60*s); ctx.fill();
        } else {
             ctx.fillStyle = '#777'; ctx.beginPath(); ctx.arc(p.x, p.y, 10*s, Math.PI, 0); ctx.fill();
        }
    },

    drawParticle(ctx, p, obj) {
        ctx.fillStyle = obj.color;
        const s = p.scale;
        if(obj.type === 'confetti') {
            ctx.save();
            ctx.translate(p.x, p.y); ctx.rotate(obj.life * 10);
            ctx.fillRect(-3*s, -3*s, 6*s, 6*s);
            ctx.restore();
        } else {
            ctx.globalAlpha = obj.life;
            ctx.beginPath(); ctx.arc(p.x, p.y, (obj.type==='dust'? 5 : 2)*s, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    },

    drawUI(ctx, s) {
        if(s.session.feedbackTimer > 0) {
            ctx.font = "900 60px 'Arial Black'";
            ctx.fillStyle = s.session.feedback.includes("SWISH") || s.session.feedback.includes("S√âRIE") ? "#00FF00" : "#FFF";
            if(s.session.feedback.includes("CHANCE")) ctx.fillStyle = "#FFD700";
            ctx.textAlign = "center";
            ctx.strokeStyle = "#000"; ctx.lineWidth = 3;
            ctx.fillText(s.session.feedback, ctx.canvas.width/2, 200);
            ctx.strokeText(s.session.feedback, ctx.canvas.width/2, 200);
        }
    }
};

window.onload = () => Game.init();
</script>
</body>
</html>